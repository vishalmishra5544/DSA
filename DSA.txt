MATHEMATICS AND BASICS:
//finding number of digits in a number
int numOfDigits(int n){
return floor(log10(n))+1;
}
//factorial
int fact(int n){
int res=1;
for(int i=n;i>=1;i--)
  res=res*i;
return res;  
}
//palindrome
int palindrome(int n){
int res=n,rev=0;
while(n>0){
 rev=rev*10+n%10;
 n=n/10;
}
return (res==rev);
}
//gcd or hcf
int gcd(int a,int b){
while(a!=b){
if(a>b) a=a-b;
if(b>a) b=b-a;
}
return a;
}
//peak element
  public:
    int findPeak(int arr[],int n,int l,int r){
        int mid=l+(r-l)/2;
        if((mid==n-1||arr[mid]>=arr[mid+1])&&(mid==0||arr[mid-1]<=arr[mid])){
           return mid;
       }else if(mid<n-1&&arr[mid]<arr[mid+1]){
           findPeak(arr,n,mid+1,r);
       }else if(mid>0 && arr[mid-1]>arr[mid]){
           findPeak(arr,n,l,mid-1);
       }
    }
    int peakElement(int arr[], int n)
    {
       // Your code here
       int l=0,r=n-1;
       return findPeak(arr,n,l,r);
       }
return a;
}
//lcm
int lcm(int a,int b){
return (a*b)/(gcd(a,b));
}
//check for prime
bool prime(int n){
if(n==1) return false;
if(n==2||n==3) return true;
if(n%2==0||n%3==0) return false;
for(int i=5;i*i<=n;i=i+6){
 if(n%i==0||n%(i+2)==0) return false;
}
return true;
}
//prime factors
void primeFactors(int n){
while(n%2==0){
n=n/2;
cout<<2<<endl;
}
while(n%3==0){
n=n/3;
cout<<3<<endl;
}
for(int i=5;i*i<=n;i=i+6){
 while(n%i==0){
 n=n/i;
 cout<<i<<endl;
 }
 while(n%(i+2)==0){
 n=n/(i+2);
 cout<<(i+2)<<endl;
 }
}
if(n>3)
 cout<<n<<endl;
}
//All divisors of a number
void allDivisors(int n){
for(int i=1;i*i<=n;i++){
 if(n%i==0) cout<<i<<endl;
}
for(;i>=1;i--){
 if(n%i==0) cout<<n/i<<endl;
}
}
//Sieve of erathosthenes //Prints all prime numbers till n;
void sieve(int n){
vector<bool> sieve(n+1,true);
for(int i=2;i*i<=n;i++){
 if(sieve[i]==true){
  for(int j=i*i;j<=n;j++){
  sieve[i]=false;
  }
 }
}
for(int i=2;i<=n;i++){
 if(sieve[i]==true) cout<<i<<endl;
}
}


BIT MANIPULATION:
 // Function to check if given number n is a power of two.
    bool isPowerofTwo(long long n){
        
        // Your code here    
        return (n>0)&&((n&(n-1))==0);
        
    }
// getting first set bit
unsigned int getFirstSetBit(int n)
    {
       return log2(n^(n&(n-1)))+1;
    }
//Function to find the first position with different bits.
    int posOfRightMostDiffBit(int m, int n)
    {
        // Your code here
        int i=m^n,res=-1;
        res=(log2(i^(i&(i-1)))+1);
        if(res>-1) return res;
        else return -1;
    }
// Function to check if Kth bit is set or not.
    bool checkKthBit(int n, int k)
    {
        // Your code here
        // It can be a one liner logic!! Think of it!!
        return n&(1<<k);
    }
//count set bit in an integer
 int setBits(int N) {
        // Write Your Code here
        int lookup[256]={0};
        for(int i=1;i<256;i++)
            lookup[i]=(i&1)+lookup[i/2];
        int res=0;
        while(N>0){
            res=res+lookup[N&0xff];
            N=N>>8;
        }
       return res;
    }
//count set bit from 1 to n
//method-1-DP LOOKUP
int lookup[n+1]={0};
for(int i=1;i<n;i++)
    lookup[i]=(i&1)+lookup[i/2];
int res=0;
for(int i=n;i>=1;i--){
    res=res+lookup[n&0xff];
 }
return res;
//method-2-o(logn)
 int countSetBits(int n){
        n++;
        int countsetbits=n/2,pairs=0,setbits=0,remainingsetbits=0;
        int powerof2=2;
        while(powerof2<=n){
        pairs=n/powerof2;
        setbits=(pairs/2)*powerof2;
        remainingsetbits=(pairs&1)?n%powerof2:0;
        countsetbits=countsetbits+setbits+remainingsetbits;
        powerof2=powerof2<<1;
        }
    return countsetbits;
    }
 // Function to find number of bits needed to be flipped to convert A to B
    int countBitsFlip(int a, int b){
        
        // Your logic her
        int n=a^b;
        return __builtin_popcount(n);
        
    }
//Function to check if the number is sparse or not.
    bool isSparse(int n)
    {
        // Your code
        int flag=0;
        while(n>0){ 
            if(flag==2) return 0;
            if(n&1==1) flag+=1;
            else flag=0;  
            n=n>>1;
        }
        if(flag==2) return 0;
        return 1;
    }
//longest consecutive ones
int maxConsecutiveOnes(int N)
    {
        // code here
         int n=N,flag=0,maxlen=0;
        while(n>0){ 
            if(n&1==1){  flag+=1;maxlen=max(maxlen,flag);}
            else flag=0;  
            n=n>>1;
        }
      return maxlen;
    }
//binary to gray code
 string binToGrey(string B) {
        // code here
        string g;
        g.push_back(B[0]);
        for(int i=1;i<B.length();i++){
            char res=(B[i-1]==B[i])?'0':'1';
            g.push_back(res);
            }
        return g;
    }
// gray code to binary    
    string greyToBin(string G) {
        // code here
        string b="";
        b.push_back(G[0]);
        for(int i=1;i<G.length();i++){
         char res=(b[i-1]==G[i])?'0':'1';
          b.push_back(res);
        }
        return b;
    }
 //Function to swap odd and even bits.
    unsigned int swapBits(unsigned int n)
    {
    	// Your code here
    for(int i=0;i<32;i=i+2){//since int is 32 bit and check for i and i+1 th at a time
    int ithbit=(n>>i)&1;//get ith bit
    int iplus1thbit=(n>>(i+1))&1;//get i+1 th bit
    n=n-(ithbit<<i)-(iplus1thbit<<(i+1))+(ithbit<<(i+1))+(iplus1thbit<<i);//remove ith bit and i+1 th bit and addnew swapped values of ith and i+1 th bit
    }
    return n;
    }
//Maximum AND value of any pair in an array.
int checkBits(int * arr,int n,int pattern){
        int count=0;
        for(int i=0;i<n;i++){
            if((arr[i]&pattern)==pattern)//if there is a num in arr which has his bit set then do count++
                count++;// so if two or more such num present then this bit can be included in our pattern or final res.
        }
        return count;
    }
    // Function for finding maximum AND value.
    int maxAND (int arr[], int N)
    {
        // Your code here
        int res=0,setbit,count=0;
        for(int i=31;i>=0;i--){
            setbit=res|(1<<i); //set i th bit and add res or pattern(a number which will have set bits only when two such num in arr are present having this bit set) till now to check if this bit can be included or not
            count=checkBits(arr,N,setbit);// check if this setbit can be included or not
            if(count>=2)//means there are 2 numbers having this bit set thus on doing their AND this bit will be included else not
                res=res|(1<<i);//include this setbit
            
        }
        return res;
    }


RECURSION:
//Print 1 to n without using loops
    void printTillN(int N)
    {
        // Write Your Code here
        if(N<=0) return;
        printTillN(N-1);
        cout<<N<<" ";
    }
//Sum of digits
 int sumOfDigits(int N){
        //code here
        int digit=0;
       while(N>0){
           digit+=N%10;
           N=N/10;
       }
       return digit;
    }
//count digits
int evenlyDivides(int N){
        //code here
        int digit=0,count=0,n=N;
        while(N>0){
            digit=N%10;
            if(digit!=0&&n%digit==0) count++;
            N=N/10;
        }
        return count;
    }
//Digital Roots -(get repeated sum until it becomes single digit and check if it is prime or not)
public:
    int DigitalRoot(int N){//get repeated sum until it becomes single digit
        if(N<=9) return N;
        
        return (N%9==0)?9:(N%9);
    }
    int digitisPrime(int n){
        for(int i=2;i*i<=n;i++){
            if(n%i==0) return 0;
        }
        return 1;
    }
    int digitalRoot(int N)
    {
        // Write Your Code here
        int ans=DigitalRoot(N);
        if(ans<=1) return 0;
        return digitisPrime(ans);
    }
//Nth fibonacci number
public:
    long long int nthFibonacci(long long int n){
        // code here
        int fib1=1,fib2=1,fib=0;
        if(n<=0) return 0;
        if(n==1||n==2) return 1;
        for(long long int i=3;i<=n;i++){
            fib=(fib1+fib2)%1000000007;
            fib2=fib1;
            fib1=fib;
        }
        return fib;
    }
//Tower of hanoi
public:
    // You need to complete this function

    // avoid space at the starting of the string in "move disk....."
    //long long int moves=1;
    void moves(int N,int from,int to,int aux){
        if(N<1) return;
        if(N==1) {
            cout<<"move disk "<<N<<" from rod "<<from<<" to rod "<<to<<"\n";
            return;
        }
        toh(N-1,from,aux,to);
        //move 1th from 1 to 3 ;
        cout<<"move disk "<<N<<" from rod "<<from<<" to rod "<<to<<"\n";
        toh(N-1,aux,to,from);
    }
    long long toh(int N, int from, int to, int aux) {
        // Your code here
        moves(N,from,to,aux);
        return pow(2,N)-1;
    }
//josephus problem
class Solution
{
    public:
    int josephus(int n, int k)
    {
       //Your code here
       if(n<=1) return 1;
       
       return (josephus(n-1,k)+k-1)%n+1;//adjustments as k%n +1 is treated as 1st in every call.and here ordering are from 1 to N
    }
};

// lucky numbers
bool myFun(int n, int x)
    {
        if(n%x == 0)
            return false;
        if(x > n)
            return true;
        return myFun(n-(n/x), x+1);    
    }
    bool isLucky(int n) {
        return myFun(n, 2);
    }
//Power of Numbers - given N,R(reverse of N) find N power R  (fast exponentiation)
 public:
    //You need to complete this fucntion
    
    long long power(int N,int R)
    {
       //Your code here
       long long int res=1,base=N;
       while(R>0){
           if(R&1){
           res=(res*base)%1000000007;
           }
           base=(base*base)%1000000007;
           R=R>>1;
       }
       return res;
        
    }
//power set using recursion -print in lexicographically order with duplicates also
	public:
	  vector<string> ans;
	  multimap<string,int> a;
	  void powerSet(string &s,int i,string curr=""){
	       if(i==s.length()){ 
	           //a[curr]++;
	           a.insert(pair<string,int>(curr,1));
	           return;
	       }
	       
	       powerSet(s,i+1,curr+s[i]);
	       powerSet(s,i+1,curr);
	   }
	  
		vector<string> AllPossibleStrings(string s){
		    // Code here
		    int i=0;
		    powerSet(s,i,"");
		    a.erase("");
		    for(auto itr=a.begin();itr!=a.end();itr++)
		       ans.push_back(itr->first);
		    return ans;
		}

//Possible words from phone digits
public:
    vector<string> ans;
    map<int,string> mp;
    map<string,int> res;
    void possible(int a[],int n,string curr,int i){
        if(i==n){
            res[curr]++;
            return;
        }
        int digit=a[i];
        int len=mp[digit].length();
        for(int j=0;j<len;j++){ //for this digit check its alphabet string and iterate over it by including one at a time and recursively calling for next digit's string and repeat till last digit in input array a is reached thus when i==n return.
        string temp=mp[digit];
        possible(a,n,curr+temp[j],i+1);
        
        }
    }
    //Function to find list of all words possible by pressing given numbers.
    vector<string> possibleWords(int a[], int N)
    {
        //Your code here
  //store mapping of digits with alphabets
   mp.insert({0,""});
   mp.insert(make_pair(1,""));
   mp.insert(make_pair(2,"abc"));
   mp.insert(make_pair(3,"def"));
   mp.insert(make_pair(4,"ghi"));
   mp.insert(make_pair(5,"jkl"));
   mp.insert(make_pair(6,"mno"));
   mp.insert(make_pair(7,"pqrs"));
   mp.insert(make_pair(8,"tuv"));
   mp.insert(make_pair(9,"wxyz"));
   
        possible(a,N,"",0);
        for(auto itr=res.begin();itr!=res.end();itr++)
           ans.push_back(itr->first);
        return ans;
    }



ARRAYS:
//Finding majority element(element appearing greater than N/2) 
//using moore's voting algo-O(n)
 int majorityElement(int arr[], int size)
    {        
        // your code here
        int major=arr[0],count=0;
        for(int i=0;i<size;i++){
            if(major==arr[i]){
                count++;
            }else count--;
            if(count==0){
                major=arr[i];
                count=1;
            } 
        }
        count=0;
        for(int i=0;i<size;i++){
            if(arr[i]==major)
             count++;
        }
        if(count>size/2)
         return major;
        else return -1;      
       
    }
//second max in array (but ensure largest should not be equal to second largest)
 int print2largest(int arr[], int arr_size)
    {
    	//code here.
    	int largest=arr[0],secondlargest=-1;
    	for(int i=1;i<arr_size;i++){
    	    if(arr[i]>largest){ secondlargest=largest;largest=arr[i];}
    	    else if(arr[i]>secondlargest &&arr[i]!=largest){secondlargest=arr[i];}
    	}
      return secondlargest;	
    }
//find max value of(a[i]-i)-(a[j]-j) such that i!=j
 int maxVal(int a[], int n) {
        int maxval=INT_MIN,minval=INT_MAX;
        for(int i=0;i<n;i++){
            if((a[i]-i)>maxval) maxval=(a[i]-i);
            if((a[i]-i)<minval) minval=(a[i]-i);
        }
     return maxval-minval;
    }
//reverse array in groups
public:
void reverse(vector<long long>& arr, int n,int i,int k){
    int low=i,high=min(i+k-1,n-1);
    while(low<high){
        swap(arr[low],arr[high]); 
        low++,high--;
    }
}
    //Function to reverse every sub-array group of size k.
    void reverseInGroups(vector<long long>& arr, int n, int k){
        // code here
        for(int i=0;i<n;i+=(k)){
            reverse(arr,n,i,k);
        }
    }
//Rotate array by d
 public:
    void reverseArr(int arr[], int n,int low,int high){
        while(low<high){
        swap(arr[low],arr[high]); 
        low++,high--;
      }
   }
    //Function to rotate an array by d elements in counter-clockwise direction. 
    void rotateArr(int arr[], int d, int n){
        // code here
        if(d>n){
            d=d-n;
        }
        reverseArr(arr,n,0,d-1);
        reverseArr(arr,n,d,(n-1));
        reverseArr(arr,n,0,n-1);
        
    }
//Maximum occurred integer-(given n ranges find max appearing element in the ranges given)
 public:
    // L and R are input array
    // maxx : maximum in R[]
    // n: size of array
    // arr[] : declared globally with size equal to maximum in L[] and R[]
    //Function to find the maximum occurred integer in all ranges.
    int maxOccured(int L[], int R[], int n, int maxx){
    
        // Your code here
        int arr[1000000];
        memset(arr,0,sizeof arr);
        for(int i=0;i<n;i++){
            arr[L[i]]++;//mark start of ith range as 1
            arr[R[i]+1]--;//mark end of ith range as -1;
        }
        int maxOccurrences=arr[0],maxAppearingNumber=0;
        for(int i=1;i<1000000;i++){//prefix sum to get max occuring value (no of ranges in which it appears)of all numbers from 0 to 100000 
            arr[i]=arr[i]+arr[i-1];
            if(maxOccurrences<arr[i]){
                maxOccurrences=arr[i];
                maxAppearingNumber=i;
            }
        }
        return maxAppearingNumber;
    }
//wave array
public:
    // arr: input array
    // n: size of array
    //Function to sort the array into a wave-like array.
    void convertToWave(vector<int>& arr, int n){
        
        // Your code here
        for(int i=1;i<n;i+=2){
            swap(arr[i],arr[i-1]);
        }
        
    }
//frequencies of limited range array elements (in o(1) aux space)
public:
  //Function to count the frequency of all elements from 1 to N in the array.
  void frequencyCount(vector<int>& arr,int n, int P)
  {
    int expectedPos, pos=0;
    while (pos<n)
    {
        expectedPos = arr[pos]-1;
        if (arr[pos] >0 && arr[pos]<=n && arr[expectedPos]>0)
        {
            arr[pos] = arr[expectedPos];
            arr[expectedPos] = -1;
        }
        else if (arr[pos] >0 && arr[pos]<=n)
        {
            arr[expectedPos]--;
            arr[pos++] = 0;
        }
        else
        {
            pos++;
        }
    }
    for (int i=0;i<n;i++)
    { if(arr[i]>0) arr[i]=0;
        arr[i]=abs(arr[i]);    
    } 
 }
// equilibrium point
 public:
    // Function to find equilibrium point in the array.
    // a: input array
    // n: size of array
    int equilibriumPoint(long long arr[], int n) {
    
        // Your code here
        
        for(int i=1;i<n;i++){
            arr[i]=arr[i]+arr[i-1]; 
       }
       for(int i=0;i<n;i++){
           if(i==0){
               if(arr[n-1]-arr[0]==0) return 1;
           }
           if(arr[i-1]==(arr[n-1]-arr[i-1]-(arr[i]-arr[i-1]))){
               return i+1;
           }
       }
       return -1;
    }
//Leaders in an array
 //Function to find the leaders in the array.
    public:
    vector<int> leaders(int a[], int n){
        // Code here
        int lastGreater=a[n-1];
        vector<int> v;
        v.push_back(a[n-1]);
        for(int i=n-2;i>=0;i--){
           if(a[i]>=lastGreater){ lastGreater=a[i]; v.push_back(a[i]);}
        }
        int l=0,r=v.size()-1;
        while(l<r){
            swap(v[l],v[r]);
            l++,r--;
        }
        return v;
    }
//smallest positive missing number -o(n) time & o(1) space
 public:
    //Function to find the smallest positive number missing from the array.
    int missingNumber(int arr[], int n) 
    { 
        // Your code here
       int find1=0;
       for(int i=0;i<n;i++){
           if(arr[i]==1){
               find1=1;
               break;
           }
       }
       if(find1==0) return 1;//as 1 is first missing no
       for(int i=0;i<n;i++){
           if(arr[i]<=0||arr[i]>n) arr[i]=1;
       }
       for(int i=0;i<n;i++){
           arr[(arr[i]-1)%n]+=n;
       }
       for(int i=0;i<n;i++){
           if(arr[i]<=n) return i+1;
       }
    return n+1;
    }
//Rearrange Array Alternately
public:
    // This function wants you to modify the given input
    // array and no need to return anything
    // arr: input array
    // n: size of array
    //Function to rearrange  the array elements alternately.
    void rearrange(long long *arr, int n) 
    { 
    	
    	// Your code here
    /*//when arr elements differ by 1
    int max_ele=arr[n-1],min_ele=arr[0],i=0;
    	while(i<n){
    	    if(i%2!=0){
    	     arr[i]=min_ele;
    	    i++;
    	    min_ele++;
    	    }
    	    else{
        	 arr[i]=max_ele;
        	 i++;
        	 max_ele--;
    	    }
    	}
    	*/ 
    	int maxindex=n-1,minindex=0,maxelement=arr[n-1]+1;
    	for(int i=0;i<n;i++){
    	    if(i%2==0){
    	    arr[i]=arr[i]+((arr[maxindex]%maxelement)*maxelement);
    	    maxindex--;
    	    }else{
    	        arr[i]=arr[i]+((arr[minindex]%maxelement)*maxelement);
    	        minindex++;
    	    }
    	}
    	for(int i=0;i<n;i++){
    	    arr[i]=arr[i]/maxelement;
    	}
    }
//Rearrange an array with o(1) extra space
public:
    // arr: input array
    // n: size of array
    //Function to rearrange an array so that arr[i] becomes arr[arr[i]]
    //with O(1) extra space.
    void arrange(long long arr[], int n) {
        // Your code here
        for(int i=0;i<n;i++){
            arr[i]+=(arr[arr[i]]%n)*n;
        }
        for(int i=0;i<n;i++){
            arr[i]=arr[i]/n;
        }
    }
//Maximum Index
public:
        
    // A[]: input array
    // N: size of array
    // Function to find the maximum index difference.
    int maxIndexDiff(int arr[], int N) 
    { 
        // Your code here
        int LMin[N],RMax[N];
        LMin[0]=arr[0];
        for(int i=1;i<N;i++){
            LMin[i]=min(arr[i],LMin[i-1]);
        }
        RMax[N-1]=arr[N-1];
        for(int i=N-2;i>=0;i--){
            RMax[i]=max(arr[i],RMax[i+1]);
        }
        int i=0,j=0,maxDiff=-1;
        while(i<N&&j<N){
            if(LMin[i]<=RMax[j]){
                maxDiff=max(maxDiff,j-i);
                j++;
            }else i++;
        }
        return maxDiff;
    }
//// Function to find the trapped water between the blocks.
    public:
    long long trappingWater(int arr[], int n){
        // code here
    int lmax[n],rmax[n];
        long long water=0,maxstorableht=0;
        lmax[0]=arr[0];
        for(int i=1;i<n;i++){
           lmax[i]=max(lmax[i-1],arr[i]);
        }
        rmax[n-1]=arr[n-1];
        for(int i=n-2;i>=0;i--){
            rmax[i]=max(rmax[i+1],arr[i]);
        }
        for(int i=1;i<n-1;i++){
            maxstorableht=min(lmax[i],rmax[i]);
            if(maxstorableht-arr[i]>0)
              water+=maxstorableht-arr[i];
        }
        return water;
    }
//public:
//Function to find the days of buying and selling stock for max profit.
vector<vector<int> > stockBuySell(vector<int> price, int n){
vector<vector<int>> ans;
        vector<int> v;
        int i = 0;
        while (i < n - 1) {
 
        // Find Local Minima
        // Note that the limit is (n-2) as we are
        // comparing present element to the next element
        while ((i < n - 1) && (price[i + 1] <= price[i]))
            i++;
 
        // If we reached the end, break
        // as no further solution possible
        if (i == n - 1)
            break;
 
        // Store the index of minima
        int buy = i++;
 
        // Find Local Maxima
        // Note that the limit is (n-1) as we are
        // comparing to previous element
        while ((i < n) && (price[i] >= price[i - 1]))
            i++;
 
        // Store the index of maxima
        int sell = i - 1;
        v.clear();
        v.push_back(buy);
        v.push_back(sell);
        ans.push_back(v);
        //if(i==n-1)break;
       }
       return ans;
    }
//check if array is sorted or not
public:
    bool arraySortedOrNot(int arr[], int n) {
        // code here
       for(int i=n-1;i>0;i--){
           if(arr[i]-arr[i-1]<0){      
             return false;
           }
        }
        return true;
    }
//check if array is rotated or not
public:	
	int findKRotation(int arr[], int n) {
	    // code here
	    int count=0;
	   for(int i=n-1;i>0;i--){
	       if(arr[i]-arr[i-1]<0) count=i;
	    }
	    return count;
	}
//kadane's algo -maxsubarraysum
public:
    // arr: input array
    // n: size of array
    //Function to find the sum of contiguous subarray with maximum sum.
    long long maxSubarraySum(int arr[], int n){
        
        // Your code here
        int maxsum=INT_MIN,currsum=0;
        for(int i=0;i<n;i++){
            currsum+=arr[i];
            maxsum=max(maxsum,currsum);
            if(currsum<0) currsum=0;
        }
        return maxsum;
        
    }
//longest subarray with atmost k even elements (use sliding window concept)
int main()
 {
	//code
	int t,n,k;
	cin>>t;
	while(t--){
	    cin>>n>>k;
	    int arr[n];
	    for(int i=0;i<n;i++){
	      cin>>arr[i];
	      if(arr[i]%2==0)
	         arr[i]=1;
	      else
	         arr[i]=0;
	    }
	    int sum=0,count=0,maxcount=0;
	    for(int i=0;i<n;i++){
	        if((sum+arr[i])<=k){
	            sum+=arr[i];
	            count++;
	        }else if(sum!=0){
	            sum=sum-arr[i-count]+arr[i];
	        }
	        maxcount=max(count,maxcount);
	    }
	    cout<<maxcount<<'\n';
	    
	}
	return 0;
}
//max circular subarray sum
 public:
    // arr: input array
    // num: size of array
    //function for standard kadane:
    int normalSubarraySum(int arr[],int n){
        int maxSum=INT_MIN,currSum=0;
        for(int i=0;i<n;i++){
            currSum+=arr[i];
            maxSum=max(currSum,maxSum);
            if(currSum<0) currSum=0;
        }
        return maxSum;
    }
//Function to find maximum circular subarray sum.
    int circularSubarraySum(int arr[], int n){
        
        // your code here
        int normal_sum=normalSubarraySum(arr,n);//non-wrap up sum or std sum
        if(normal_sum<0){
            return normal_sum;
        }
        int arr_sum=0;
        for(int i=0;i<n;i++){
            arr_sum+=arr[i];//to get total sum
            arr[i]=-arr[i];//to get minimum sum(middle elements sum) by passing this modified array to std kadane for max minimum sum.
        }
        int circular_sum=arr_sum+normalSubarraySum(arr,n);//wrap up sum(max circular sum)=total arr sum-middle elements sum
        return max(circular_sum,normal_sum);//max of( wrap up sum,non-wrap up sum or std sum)
    }


SEARCHING:
//search an element in an array  - linear search
  public:
    // Function to search x in arr
    // arr: input array
    // X: element to be searched for
    int search(int arr[], int N, int X)
    {
       for(int i=0;i<N;i++)
         if(arr[i]==X) return i;
         
       return -1;
    }
//Searching an element in a sorted array
 public:
    // Function to find element in sorted array
    // arr: input array
    // N: size of array
    // K: element to be searche
    int searchInSorted(int arr[], int N, int K) 
    { 
    
       // Your code here
       return (binary_search(arr,arr+N,K)==1)?1:-1;
       
    }
//Count the zeroes
int countZeroes(int arr[], int n) {
        // code here
    int left = 0;
        int right = n-1;
        
        while(left <= right){
            int mid = left + (right - left)/2;
            
            if(arr[mid] == 0){
                if(mid == 0 || arr[mid-1] != arr[mid] )
                    return n-mid;
                else 
                    right = mid - 1;
            }
            else 
                left = mid + 1;
        }
        return 0;
    }
//Square root of a number
public:
    long long int floorSqrt(long long int x) 
    {
        // Your code goes here 
        long long int last,i=1,mid,low=1,high;
       while(i<x){
                last=i;
                if(last*last==x) return last;
                i=i*2;
            
        }
        high=last;
        while(low<=high){
            mid=low+(high-low)/2;
            if(mid*mid==x) return mid;
            else if(mid*mid>x) high=mid-1;
            else {last=mid;low=mid+1;}
        }
      return last;
    
    }
//left most and right most index - first and last occurrence of x in v
 public:
    pair<long,long> indexes(vector<long long> v, long long x)
    {
        // code here
        bool find=binary_search(v.begin(),v.end(),x);
        if(find==true){
        auto last=upper_bound(v.begin(),v.end(),x);
        auto first=lower_bound(v.begin(),v.end(),x);
        return make_pair(first-v.begin(),last-v.begin()-1);
        }
        return make_pair(-1,-1);
    }
//Floor in a sorted array
 public:
    // Function to find floor of x
    // n: size of vector
    // x: element whose floor is to find
    int findFloor(vector<long long> v, long long n, long long x){
        
        // Your code here
        return upper_bound(v.begin(),v.end(),x)-v.begin()-1;
        
    }
//Minimum Number in a sorted rotated array  (distinct and without duplicates)
public:
    //Function to find the minimum element in sorted and rotated array.
    int minNumber(int arr[], int low, int high)
    {
        // Your code here
        int mid,len=high-low+1;
        while(low<=high){
            mid=low+(high-low)/2;
            if(mid==0) return arr[mid];
            if(arr[mid]>arr[mid+1]) return arr[mid+1];
            if(arr[mid-1]>arr[mid]) return arr[mid];
            else if(arr[mid]>arr[high]) low=mid+1;
            else high=mid-1;
        }
        
        
    }
// with duplicates
// Function to find minimum element
int findMin(int arr[], int low, int high)
{
    while(low < high)
    {
        int mid = low + (high - low)/2;
        if (arr[mid] == arr[high])
            high--;
        else if(arr[mid] > arr[high])
            low = mid + 1;
        else
            high = mid;
    }
    return arr[high];
}
//Two Repeated Elements
public:
    //Function to find two repeated elements. num are from 1 to N range and total N+2
    vector<int> twoRepeated (int arr[], int n) {
        // Your code here
       vector<int> res;
       for(int i=0;i<n+2;i++){
           if((arr[(arr[i]%(n+1))]/(n+1))<1){
               arr[(arr[i]%(n+1))]+=(n+1);
           }else res.push_back(arr[i]%(n+1));
       }
       return res;
    }
//Roof Top
 public:
    //Function to find maximum number of consecutive steps 
    //to gain an increase in altitude with each step.
    int maxStep(int arr[], int n)
    {
       //Your code here
       int steps=0,msteps=0;
       for(int i=1;i<n;i++){
           if(arr[i]>arr[i-1]){
               steps+=1;
               msteps=max(msteps,steps);
           }else{steps=0;}
       }
       return msteps;
    }
//Maximum Water Between Two Buildings
  public:
    int maxArea(int h[],int n){
        int ht=0,l=0,area=0,i=0,j=n-1,maxarea=0;
        //we move towards height which is greater for max area using 2 pointers
        while(i<j){
                ht=min(h[i],h[j]);
                l=(j-i-1);
                area=ht*l;
                maxarea=max(maxarea,area);
                if(h[i]<h[j]){
                    i++; 
                }else if(h[j]<h[i]){
                    j--;
                }else i++,j--;
            }
      return maxarea;
    }
    int maxCandy(int h[], int n) 
    { 
        // Your code goes here
            return maxArea(h,n);
       
    } 
//count more than n/k occurrences  -o(n) extra space
 //Function to find all elements in array that appear more than n/k times.
    int countOccurence(int arr[], int n, int k) {
        // Your code here
        unordered_map<int,int> mp;
        int count=0;
        for(int i=0;i<n;i++){
            mp[arr[i]]++;
        }
        if(k<1) return mp.size();
        for(auto it=mp.begin();it!=mp.end();it++){
            if(it->second>(n/k)) count++;
        }
        return count;
    }
   
//
public:
    bool isPossible(int arr[],int n,int m,int min_pages){
        int sum=0,noofstud=1;
        for(int i=0;i<n;i++){
            if(arr[i]>min_pages) return false;
            if(sum+arr[i]>min_pages){
                noofstud++;
                sum=arr[i];
                if(noofstud>m) return false;
            }else sum+=arr[i];
        }
        return true;
    }
    //Function to find minimum number of pages.
    int findPages(int arr[], int n, int m) 
    {
        //code here
        long long sum=0;
        if(n<m) return -1;
        int l,r,res=0;
        for(int i=0;i<n;i++){
            sum+=arr[i];
            mxpages=max(mxpages,arr[i]);
        }
        l=mxpages,r=sum;
        while(l<=r){
            int mid=(r+l)/2;
            if(isPossible(arr,n,m,mid)){
                res=mid;
                r=mid-1;
            }else l=mid+1;
        }
        return res;
    } 
//subarray with given sum
public:
    //Function to find a continuous sub-array which adds up to a given number.
    vector<int> subarraySum(int arr[], int n, long long sum)
    {
        // Your code here
        vector<int> ans;
       long long int curr_sum=arr[0],l=0,r=0;
        while(r<n){
            if(curr_sum==sum) {ans.push_back(l+1);ans.push_back(r+1); return ans;} //since positions
            else if(curr_sum>sum) {curr_sum=curr_sum-arr[l];l++;}
            else {r++;curr_sum=curr_sum+arr[r];}
        }
        ans.push_back(-1);
        return ans;
    }
//median of two sorted arrays of different sizes
public:
    double Median(vector<int>& A,vector<int>& B){
        int start=0,end=A.size(),merged_mid=(A.size()+B.size()+1)/2;
        while(start<=end){
            int mid=(start+end)/2;
            int leftAsize=mid,leftBsize=merged_mid-mid;
            int leftA=(leftAsize>0)?A[leftAsize-1]:INT_MIN;
            int leftB=(leftBsize>0)?B[leftBsize-1]:INT_MIN;
            int rightA=(leftAsize<A.size())?A[leftAsize]:INT_MAX;
            int rightB=(leftBsize<B.size())?B[leftBsize]:INT_MAX;
            if(leftA<=rightB&&leftB<=rightA){
                if((A.size()+B.size())%2==0){
                    return (max(leftA,leftB)+min(rightA,rightB))/2.0;
                }
                return max(leftA,leftB);
            }
            else if(leftA>rightB){
                end=mid-1;
            }else start=mid+1;
            
        }
        return 0.0;
        
    }
    double MedianOfArrays(vector<int>& array1, vector<int>& array2)
    {
        // Your code goes here
        int n=array1.size(),m=array2.size();
        if(n>m) return Median(array2,array1);
        else return Median(array1,array2);
    
    }

SORTING:

//Bubble sort
 public:
    //Function to sort the array using bubble sort algorithm.
    
    void bubbleSort(int arr[], int n)
    {
        // Your code here  
        bool flag=false;
        for(int pass=0;pass<n-1;pass++){//n-1 passes reqd
            for(int j=0;j<n-i-1;j++){//i elements are sorted in right part thus check for only n-i-1 left elements.
                if(arr[j+1]<arr[j]){
                 arr[j]=arr[j]+arr[j+1];
                 arr[j+1]=arr[j]-arr[j+1];
                 arr[j]=arr[j]-arr[j+1];
                 flag=true;
                }
            }
            if(flag==false) return;
        }
        return;
    }
//
 public:
    //Function to sort the array using insertion sort algorithm.
    void insertionSort(int arr[], int n)
    {
        //code here
        int j=0,key;
        for(int i=1;i<n;i++){//i is from 1 because we assume 0th is already inserted in empty array.
            j=i-1;//last element in sorted arr.
            key=arr[i];//store ith ele as it will be overwritten while creating space
            while(j>=0&&j<n&&arr[j]>key){//shift and create space if last>key
                arr[j+1]=arr[j];
                  j--;
                
            }
            arr[j+1]=key;//j will be last element in sorted arr and so place this key in space created at j+1 th.
        }
        return;
    }
//Quick sort
 //Function to sort an array using quick sort algorithm.
   
    void quickSort(int arr[], int low, int high)
    {
        // code here
        
        if(low<high){//using lomuto partition
            int pivotIdx=partition(arr,low,high);
            quickSort(arr,low,pivotIdx-1);//in horae's partition it is quickSort(arr,low,pivotIdx); rest same;
            quickSort(arr,pivotIdx+1,high);
        }
        return;
        
    }
    
    public://lomuto partition
    int partition (int arr[], int low, int high)
    {
       // Your code here
       int pivot=arr[high],j=low-1;
       for(int i=low;i<=high-1;i++){
           if(arr[i]<=pivot){
               j++;
               swap(arr[j],arr[i]);
           }
       }
       swap(arr[j+1],arr[high]);
       return j+1;
    }
    int hoare(int arr[],int low,int high){
        int pivot=arr[low],i=low,j=high;
        while(1){
             do{i++;}while(arr[i]<pivot);
             do{j--;}while(arr[j]>pivot);
             if(i>=j) return j;
             swap(arr[i],arr[j]);   
         }
    }
//Binary Array Sorting
 public:
    
    // A[]: input array
    // N: input array
     
    //Function to sort the binary array.
    void binSort(int arr[], int n)
    {
       //Your code here
       
       /**************
        * No need to print the array
        * ************/
        int j=n-1;
       for(int i=0;i<n;i++){
           while(i<=j){
           if(arr[i]==1){swap(arr[i],arr[j]);j--;}
           else break;
           }
       }
    }
// count Inversions -o(nlogn) time and o(n) space
public:
    // arr[]: Input Array
    // N : Size of the Array arr[]
    long long int countAndMerge(long long int arr[],long long int low,long long int mid,long long int high){
        long long int n1=mid-low+1,n2=high-mid;
        long long int l[n1],r[n2];
        for(int i=0;i<n1;i++){
            l[i]=arr[low+i];
        }
        for(int i=0;i<n2;i++){
            r[i]=arr[mid+1+i];
        }
        long long int i=0,j=0,k=low;
        long long int res=0;
        while(i<n1&&j<n2){
            if(l[i]<=r[j]){arr[k]=l[i];k++,i++;}
            else{arr[k]=r[j];k++,j++;res+=(n1-i);//count pairs of inversion}
        }
        while(i<n1){arr[k]=l[i];i++,k++;}
        while(j<n2){arr[k]=r[j];j++,k++;}
        return res;
    }
    long long int invCount(long long int arr[],long long int low,long long int high){
        long long int inv_count=0;
        if(low<high){
            long long int mid=low+(high-low)/2;
            inv_count+=invCount(arr,low,mid);
            inv_count+=invCount(arr,mid+1,high);
            inv_count+=countAndMerge(arr,low,mid,high);
        }
        return inv_count;
    }
    // Function to count inversions in the array.
    long long int inversionCount(long long arr[], long long N)
    {        // Your Code Here
        return invCount(arr,0,N-1);        
    }
//

public:
    //arr1,arr2 : the arrays
    // n, m: size of arrays
    //Function to return a list containing the union of the two arrays. 
    vector<int> findUnion(int arr1[], int arr2[], int n, int m)
    {
        //Your code here
        //return vector with correct order of elements
        int i=0,j=0,k=0;
        vector<int> unionArr;
        while(i<n&&j<m){
            if(i>0&&arr1[i]==arr1[i-1]){ i++;continue;}
            if(j>0&&arr2[j]==arr2[j-1]){ j++; continue;}
            if(arr1[i]<arr2[j]){
             unionArr.push_back(arr1[i]);i++;
            }else if(arr1[i]>arr2[j]){
                 unionArr.push_back(arr2[j]);j++; 
            }else{unionArr.push_back(arr1[i]); i++,j++;}
        }
        while(i<n){            
          if(arr1[i]!=arr1[i-1]){ unionArr.push_back(arr1[i]);i++;}
          else i++;         
        }
        while(j<m){             
          if(arr2[j]!=arr2[j-1]){ unionArr.push_back(arr2[j]);j++;}
          else j++;
        }        
        return unionArr;
    }
//Intersection of two unsorted arrays
public:
    // Function to return the count of the number of elements in
    // the intersection of two arrays.
    int NumberofElementsInIntersection(int a[], int b[], int n, int m) {
        // Your code goes here
        unordered_set<int> hash;
        int low=n>m?m:n,max=n<m?m:n;
        int *arr1,*arr2;
        int count=0;
        if(low==n){arr1=a,arr2=b;}
        else{arr1=b,arr2=a;}
        for(int i=0;i<low;i++){
            hash.insert(arr1[i]);
        }
        for(int i=0;i<max;i++){
            if(hash.find(arr2[i])!=hash.end()){count++; hash.erase(arr2[i]);}
            
        }
        return count;
    }
//count the number of possible triangles
 public:
    //Function to count the number of possible triangles.
    int findNumberOfTriangles(int arr[], int n)
    {
        // code here
        int count=0;
        sort(arr,arr+n);
        for(int i=n-1;i>=1;i--){
            int l=0,r=i-1;
            while(l<r){
                if(arr[l]+arr[r]>arr[i]&&arr[l]+arr[i]>arr[i]&&arr[i]+arr[r]>arr[l]){
                count+=r-l;r--;
                }else l++;
            }
        }
        return count;
    }
//find triplets with zero sum -o(n2) time and o(1) space
public:
    //Function to find triplets with zero sum.
    bool findTriplets(int arr[], int n)
    { 
        //Your code here
        int count=0;
        sort(arr,arr+n);
        for(int i=n-1;i>=1;i--){
            int l=0,r=i-1;
            while(l<r){
                if(arr[i]+arr[l]+arr[r]==0){count+=1;l++;r--;return count //as we just need atleast 1 such triplet here otherwise sum all such pairs if asked;}
                else if(arr[i]+arr[l]+arr[r]<0) l++;
                else r--;
            }
        } 
        return count;
    }
//Three way partitioning    //USE DNF concept
public: 
    //Function to partition the array around the range such 
    //that array is divided into three parts.
    void threeWayPartition(vector<int>& arr,int a, int b)
    {
        // code here 
        int h=arr.size()-1,l=0,i=0; 
        while(i<=h){
            if(arr[i]<a&&arr[i]<b){swap(arr[i],arr[l]);l++;i++;}
            else if (arr[i]>b){swap(arr[h],arr[i]);h--;}
            else i++;
        }
    }

//Counting Sort
public:
    //Function to arrange all letters of a string in lexicographical 
    //order using Counting Sort.
    int charArr[26]={0};
    string countSort(string arr){
        // code here
        for(int i=0;i<arr.length();i++){
            charArr[abs('a'-arr[i])]+=1;
        }
        string s="";
        for(int i=0;i<26;i++){
            while(charArr[i]>=1){s.push_back('a'+i);charArr[i]+=-1;}
        }
        return s;
    }
// Sort an array of 0s,1s and 2s - DNF
public:
    void sort012(int arr[], int n)
    {
        // coode here 
        int h=n-1,l=0,i=0; 
        while(i<=h){
            if(arr[i]==0){swap(arr[i],arr[l]);l++;i++;}
            else if (arr[i]==2){swap(arr[h],arr[i]);h--;}
            else i++;//if arr[i]==1
        }
    }
//Sort by Absolute Difference
public:    
    // A[]: input array
    // N: size of array
    static bool mycomparator(pair<int,pair<int,int>> a ,pair<int,pair<int,int>> b){
        if(a.first!=b.first){
            return a.first<b.first;
        }else{
            return a.second.first<b.second.first;
        }
    }
    //Function to sort the array according to difference with given number.
    void sortABS(int arr[],int n, int k)
    {
       //Your code here
      /* //METHOD-1 using maps
       multimap<int,int> m;
       for(int i=0;i<n;i++){
           m.insert(make_pair(abs(arr[i]-k),arr[i]));
       }
       int i=0;
       for(auto it=m.begin();it!=m.end();it++){
           arr[i]=(*it).second;i++;
       }
       */
      //METHOD -2 using sort + vector of pairs 
       vector<pair<int,pair<int,int>>> v;
       for(int i=0;i<n;i++)
         v.push_back(make_pair(abs(arr[i]-k),make_pair(i,arr[i])));
       sort(v.begin(),v.end(),mycomparator);
       int i=0;
       for(auto it=v.begin();it!=v.end();it++){
           arr[i]=(*it).second.second;i++;
       }
    }
//Minimum difference pair  -we need to find mindiff b/w adj element pair  -o(nlogn) time
public:
   	int  minimum_difference(vector<int>nums){
   	    // Code here
   	  sort(nums.begin(),nums.end());
   	  int l=0,minDiff=INT_MAX,currDiff=0;
   	  while(l<nums.size()-1){
   	      currDiff=nums[l+1]-nums[l];
   	      if(currDiff<minDiff) minDiff=currDiff;
   	      l++;
   	  }
   	  return minDiff;
   	}
//Kth smallest element  --using quickselect algo-O(N) on avg and o(n2) in worst case time.
public:
    // arr : given array
    // l : starting index of the array i.e 0
    // r : ending index of the array i.e size-1
    int partition(int arr[],int l,int r){
       int pivot=arr[r],s=l,i;
        for(i=l;i<=r-1;i++){
            if(arr[i]<=pivot){
                swap(arr[i],arr[s]);
                s++;
            }
        }
        swap(arr[r],arr[s]);
        return s;
        
    }
    // k : find kth smallest element and return using this function
    int kthSmallest(int arr[], int l, int r, int k) {
        //code here
       
        while(l<=r){
            int p1=rand()%(r-l+1); //without this RANDOM PIVOT SELECTION TLE happens
            swap(arr[r],arr[l+p1]);
            int pivotIdx=partition(arr,l,r);
            if(pivotIdx==(k-1)) return arr[pivotIdx];
            else if(pivotIdx>(k-1)){ r=pivotIdx-1;}
            else {l=pivotIdx+1;}
        }
        return -1;
        
        /*
        // If k is smaller than number of elements in array
    if (k > 0 && k <= r - l + 1) {
        // Partition the array around last element and get
        // position of pivot element in sorted array
        int pos = partition(arr, l, r);
 
        // If position is same as k
        if (pos == k - 1)
            return arr[pos];
        if (pos > k - 1) // If position is more, recur for left subarray
            return kthSmallest(arr, l, pos - 1, k);
 
        // Else recur for right subarray
        return kthSmallest(arr, pos + 1, r, k - pos + l - 1);
    }
 
    // If k is more than number of elements in array
    return INT_MAX;
    */
    }
//Number of Pairs  -x^y>y^x
public:
    
    // X[], Y[]: input arrau
    // M, N: size of arrays X[] and Y[] respectively
   long long int count(int X[],int M,int Y[],int N,int NoOfY[],int x){
        if(x==0) return 0;
        if(x==1) return NoOfY[0];
        long long int ans=0;
        auto idx=upper_bound(Y,Y+N,x)-Y;
        ans=(N-idx);
        ans+=(NoOfY[0]+NoOfY[1]);
        if(x==2) return ans-=(NoOfY[3]+NoOfY[4]);
        if(x==3) return ans+=(NoOfY[2]);
        return ans;
    }
    //Function to count number of pairs such that x^y is greater than y^x.
    long long countPairs(int X[], int Y[], int M, int N)
    {
       //Your code here
      long long int ans=0;
      int NoOfY[5]={0};
      for(int i=0;i<N;i++){
          if(Y[i]<5){
              NoOfY[Y[i]]++;
          }
      }
      sort(Y,Y+N);
      for(int i=0;i<M;i++){
          ans=ans+count(X,M,Y,N,NoOfY,X[i]);
      }
      return ans;
    }
//Merge without extra space  -gap method.
 //Function to merge the arrays.
        void merge(long long arr1[], long long arr2[], int n, int m) 
        { 
            // code here
            int gap=ceil((float)(n+m)/2);
            int ptr1,ptr2;
            while(gap>0){
                ptr1=0,ptr2=gap;
                while(ptr2<(n+m)){
                    if(ptr1<n&&ptr2<n&&arr1[ptr1]>arr1[ptr2]){ swap(arr1[ptr1],arr1[ptr2]);}
                    else if(ptr1>(n-1)&&ptr1<(n+m)&&ptr2>(n-1)&&ptr2<(n+m)&&arr2[ptr1-n]>arr2[ptr2-n]){swap(arr2[ptr1-n],arr2[ptr2-n]);}
                    else if(ptr1<n&&ptr2>(n-1)&&ptr2<(n+m)&&arr1[ptr1]>arr2[ptr2-n]){swap(arr1[ptr1],arr2[ptr2-n]);}
                    ptr1++,ptr2++;
                }
                if(gap==1) gap=0;
                else gap=ceil((float)gap/2);
            }
        } 
 
//Nearly sorted 
public:
    //Function to return the sorted array.
    vector <int> nearlySorted(int arr[], int n, int k){
        // Your code here
        vector<int> res;
        int size=(n==k)?k:(k+1);
        priority_queue<int,vector<int>,greater<int>> heap(arr,arr+size);
      
     for(int i=size;i<n;i++){
      res.push_back(heap.top());
      heap.pop();  
      heap.push(arr[i]);
      
      }
      while(heap.empty()==false){
      res.push_back(heap.top());
       heap.pop();
       
      }
      return res;
    }

//Minimum platforms
 public:
    //Function to find the minimum number of platforms required at the
    //railway station such that no train waits.
    int findPlatform(int arr[], int dep[], int n)
    {
    	// Your code here
    	/*//method-1 using heap -o(nlogn)time and o(n)space
    	vector<pair<int,int>> v(n);
    	for(int i=0;i<n;i++){
    	    v[i]=make_pair(arr[i],dep[i]);
    	}
    	sort(v.begin(),v.end());
    	int res=1;
    	priority_queue<int,vector<int>,greater<int>> heap;
    	heap.push(v[0].second);
    	for(int i=1;i<n;i++){
    	    if(heap.top()>=v[i].first){
    	        heap.push(v[i].second);
    	        res++;
    	    }else heap.pop();
    	    heap.push(v[i].second);
    	}
    	return res;
    	*/
    	//method-2 o(nlogn)time and o(1) space
    	sort(arr,arr+n);
    	sort(dep,dep+n);
    	int arrival=1,departure=0;
    	int count=1,res=1;
    	while(arrival<n&&departure<n){
    	    if(arr[arrival]<=dep[departure]){count++;res=max(res,count);arrival++;}
    	    else{count--;departure++;}
    	}
    	return res;
    }

MATRIX:
//Addition of two square matrices
 void Addition(vector<vector<int> >& matrixA, vector<vector<int>>&matrixB) {
        // Code here
        for(int i=0;i<matrixA.size();i++){
            for(int j=0;j<matrixA.size();j++){
                matrixA[i][j]=matrixA[i][j]+matrixB[i][j];
            }
        }
    }
//Sum of upper and lower triangle
public:
    //Function to return sum of upper and lower triangles of a matrix.
    vector<int> sumTriangles(const vector<vector<int> >& matrix, int n)
    {
        // code here
        int upper=0,low=0;
        vector<int> v;
        for(int i=0;i<n;i++){
            for(int j=i;j<n;j++){
                upper=upper+matrix[i][j];
            }
        }
        for(int i=0;i<n;i++){
            for(int j=0;j<=i;j++){
                low=low+matrix[i][j];
            }
        }
        v.push_back(upper);
        v.push_back(low);
        return v;
    }
//Multiply matrices
void multiply(int a[][100], int b[][100], int c[][100], int n)
{
      //add code here.
      for(int i=0;i<n;i++){
       for(int j=0;j<n;j++){
            c[i][j]=0;
           for(int k=0;k<n;k++){
               c[i][j]+=a[i][k]*b[k][j];
           }
       }
      }
}
//Print matrix in snake pattern
public:
    //Function to return list of integers visited in snake pattern in matrix.
    vector<int> snakePattern(vector<vector<int> > matrix)
    {   
        // code here
        vector<int> v;
        int j=0;
        for(int i=0;i<matrix.size();i++){
            if(i%2==0){
                for(int j=0;j<matrix.size();j++){
                    v.push_back(matrix[i][j]);
                }
            }else{
              for(int j=matrix.size()-1;j>=0;j--){
                    v.push_back(matrix[i][j]);
                }  
            }
        }
        return v;
    }
//Transpose of matrix
public:  
    //Function to find transpose of a matrix.
    void transpose(vector<vector<int> >& matrix, int n)
    { 
        // code here 
        for(int i=0;i<n;i++){
            for(int j=i;j<n;j++){
                swap(matrix[i][j],matrix[j][i]);
            }
        }
    }
//Rotate by 90 degree
public:
    //Function to rotate matrix anticlockwise by 90 degrees.
    void rotateby90(vector<vector<int> >& matrix, int n) 
    { 
        // code here 
        //transpose
        for(int i=0;i<n;i++){
            for(int j=i;j<n;j++){
                swap(matrix[i][j],matrix[j][i]);
            }
        }
        //swap rows i, n-i
        for(int i=0;i<((n/2));i++){
            for(int j=0;j<n;j++){
                swap(matrix[i][j],matrix[n-i-1][j]);
            }
        }
        
    } 
//Determinant of a matrix
int determinantOfMatrix(vector<vector<int> > matrix, int n)
    {
        int det = 0; // the determinant value will be stored here
        if (matrix.size() == 1)
        {
            return matrix[0][0]; // no calculation needed
        }
        else if (matrix.size() == 2)
        {
            det = (matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0]);
            return det;
        }
        else
        {
            for (int p = 0; p < matrix[0].size(); p++)
            {
                vector<vector<int>> TempMatrix;
                for (int i = 1; i < matrix.size(); i++)
                {
                    vector<int> TempRow;
                    for (int j = 0; j < matrix[i].size(); j++)
                    {
                        if (j != p)
                        {
                            TempRow.push_back(matrix[i][j]);
                        }
                    }
                    if (TempRow.size() > 0)
                    TempMatrix.push_back(TempRow);
                }
                det = det + matrix[0][p] * pow(-1, p) * determinantOfMatrix(TempMatrix,matrix.size());
            }
            return det;
        }
   }
//Boundary traversal of matrix
public:
    //Function to return list of integers that form the boundary 
    //traversal of the matrix in a clockwise manner.
    vector<int> boundaryTraversal(vector<vector<int> > matrix, int n, int m) 
    {
        // code here
        
    vector<int> v;
    for(int i=0;i<1;i++){
     for(int j=0;j<m;j++)
      v.push_back(matrix[i][j]);
     }
     if(n==1)return v;
    for(int i=1;i<n;i++){
     for(int j=m-1;j<m;j++)
      v.push_back(matrix[i][j]);
    }
    if(m==1) return v;
    for(int i=n-1;i<n;i++){
     for(int j=m-2;j>=0;j--)
      v.push_back(matrix[i][j]);  
    }
    if(n==2) return v;
    for(int i=n-2;i>=1;i--){
     for(int j=0;j<1;j++)
      v.push_back(matrix[i][j]);
    }
    return v;
    }
//Spirally traversing a matrix
public: 
    //Function to return a list of integers denoting spiral traversal of matrix.
    vector<int> spirallyTraverse(vector<vector<int> > matrix, int row, int col) 
    {
        // code here 
        vector<int> v;
        int u=0,r=col-1,l=0,d=row-1;
        while((u<=d)&&(l<=r)){
            for(int i=l;i<=r;i++)
              v.push_back(matrix[u][i]);
            if((d-u+1)==1) return v;
            u++;
            for(int i=u;i<=d;i++)
               v.push_back(matrix[i][r]);
            if((r-l+1)==1) return v;
            r--;
            for(int i=r;i>=l;i--)
              v.push_back(matrix[d][i]);
            if((d-u+1)<2) return v;
            d--;
            for(int i=d;i>=u;i--)
              v.push_back(matrix[i][l]);
            l++;
            
        }
      return v;  
    }
//Search in a row-column sorted matrix
 public:
    //Function to search a given number in row-column sorted matrix.
    bool search(vector<vector<int> > matrix, int n, int m, int x) 
    {
        // code here 
        int l=m-1,d=0;
        if((x<matrix[0][0])||(x>matrix[n-1][m-1])) return false;
        while((d<n)&&(l>=0)){
            if(matrix[d][l]<x) d++;
            else if(matrix[d][l]>x) l--;
            else return true;
        }
        return false;
    }
//Boolean Matrix
 public:
    //Function to modify the matrix such that if a matrix cell matrix[i][j]
    //is 1 then all the cells in its ith row and jth column will become 1.
    void booleanMatrix(vector<vector<int> > &matrix)
    {
        // code here 
        /*
        int r=matrix.size(),c=matrix[0].size();
        bool r0=false,c0=false;
        int row[r],col[c];
        memset(row,0,sizeof row);
        memset(col,0,sizeof col);
        for(int i=0;i<r;i++){
            for(int j=0;j<c;j++){
                if(matrix[i][j]==1){row[i]=1;col[j]=1;}
            }
        }
         for(int i=0;i<r;i++){
            for(int j=0;j<c;j++){
                if((row[i]==1)||(col[j]==1)){matrix[i][j]=1;}
            }
        }
        */
        //method 2 use 0th row and 0th col of matrix as row[],col[] arrays
        int r=matrix.size(),c=matrix[0].size();
        bool r0=false,c0=false;
        //for(int i=0;i<r;i++){}
        //for(int i=0;i<c;i++){if(matrix[i][0]==1) c0=true;}
        for(int i=0;i<r;i++){
            for(int j=0;j<c;j++){
                if(i==0&&matrix[i][j]==1) r0=true;
                if(j==0&&matrix[i][j]==1) c0=true;
                if(matrix[i][j]==1){
                    matrix[0][j]=1;//like in col[j] mark 1
                    matrix[i][0]=1;//like in row[i] mark 1
                }
            }
        }
         for(int i=1;i<r;i++){
            for(int j=1;j<c;j++){
                if((matrix[i][0]==1)||(matrix[0][j]==1)){matrix[i][j]=1;}
            }
        }
        if(r0==1){ for(int i=0;i<c;i++) matrix[0][i]=1;}
        if(c0==1){ for(int j=0;j<r;j++) matrix[j][0]=1;}
        
    }
//Make matrix Beautiful  -makes rows sum and col sums same throughout the matrix
class Solution
{
    public:
    //Function to find minimum number of operations that are required 
    //to make the matrix beautiful.
    int findMinOpeartion(vector<vector<int> > matrix, int n)
    {
        // code here 
        vector<int> sumRow(n,0);
        vector<int> sumCol(n,0);
    // Calculate sumRow[] and sumCol[] array
    int maxSum = 0;
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j) {
            sumRow[i] += matrix[i][j];
            sumCol[i] += matrix[j][i];
            maxSum = max(maxSum, sumRow[i]);
        maxSum = max(maxSum, sumCol[i]);
        }
    // Find maximum sum value in either row or in column
    
   /* for (int i = 0; i < n; ++i) {
        maxSum = max(maxSum, sumRow[i]);
        maxSum = max(maxSum, sumCol[i]);
    }*/
    int count = 0;
    for (int i = 0, j = 0; i < n && j < n;) {
        // Find minimum increment required in either row or
        // column
        int diff
            = min(maxSum - sumRow[i], maxSum - sumCol[j]);
        // Add difference in corresponding cell, sumRow[]
        // and sumCol[] array
        matrix[i][j] += diff;
        sumRow[i] += diff;
        sumCol[j] += diff;
        // Update the count variable
        count += diff;
        // If ith row satisfied, increment ith value for
        // next iteration
        if (sumRow[i] == maxSum)
            ++i;
        // If jth column satisfied, increment jth value for
        // next iteration
        if (sumCol[j] == maxSum)
            ++j;
    }
    for(int i=0;i<n;i++){for(int j=0;j<n;j++){ cout<<matrix[i][j]<<" ";}cout<<"\n";}
    return count;
    } 
};
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int n;
        cin>>n;
        vector<vector<int> > matrix (n,vector<int>(n));
        for(int i=0;i<n;i++)
            for(int j=0;j<n;j++)
                cin>>matrix[i][j];
        Solution ob;
        cout << ob.findMinOpeartion(matrix, n) << endl;
    }
    return 0;
}



HASHING:
//Non-Repeating Element
 public:
    int firstNonRepeating(int arr[], int n) 
    { 
        // Complete the function
        unordered_map<int,pair<int,int>> mp;
        int count=0,j=0,res=0;
        for(int i=0;i<n;i++){
            auto id=mp.find(arr[i]);
            if(id!=mp.end()){mp[arr[i]].second+=1;}
            else{j=i;count=1;mp.insert(make_pair(arr[i],make_pair(j,count)));}
            
        }
        j=INT_MAX;
        for(auto i:mp){
            if(i.second.second==1){
                if(i.second.first<j){j=i.second.first,res=i.first;}
            }
        }
        return res;
        
    } 
//First repeating element
 public:
    // Function to return the position of the first repeating element.
    int firstRepeated(int arr[], int n) {
        // code here
        unordered_map<int,pair<int,int>> mp;
        int count=0,j=0,res=0;
        for(int i=0;i<n;i++){
            auto id=mp.find(arr[i]);
            if(id!=mp.end()){mp[arr[i]].second+=1;}
            else {j=i;count=1;mp.insert(make_pair(arr[i],make_pair(j,count)));}
            
        }
        j=INT_MAX;
        for(auto i:mp){
            if(i.second.second>1){
                if(i.second.first<j){j=i.second.first,res=i.first;}
            }
        }
        return (j==INT_MAX)?-1:(j+1);
    }
//Union of two arrays
 public:
  //Function to return the count of number of elements in union of two arrays.
    int doUnion(int a[], int n, int b[], int m)  {
        //code here
        unordered_set<int> hash;
        for(int i=0;i<n;i++){
            hash.insert(a[i]);
        }
        for(int i=0;i<m;i++){
            hash.insert(b[i]);
        }
        return hash.size();
    }
//key pair (two sum)
public:	
	// Function to check if array has 2 elements
	// whose sum is equal to the given value
	bool hasArrayTwoCandidates(int arr[], int n, int x) {
	    // code here
	    unordered_set<int> h;
	    for(int i=0;i<n;i++){
	        if(h.find((x-arr[i]))!=h.end()) return true;
	        h.insert(arr[i]);
	    }
	    return false;
	}
//check if two arrays are equal or not
 public:
    //Function to check if two arrays are equal or not.
    bool check(vector<ll> A, vector<ll> B, int N) {
        //code here
        unordered_map<int,int> h;
        for(int i=0;i<A.size();i++){
            h[A[i]]++;
        }
        for(int i=0;i<B.size();i++){
            if(h[B[i]]<=0) return false;
            h[B[i]]--;
        }
        return true;
    }
//subarray with 0 sum
public:
    //Complete this function
    //Function to check whether there is a subarray present with 0-sum or not.
    bool subArrayExists(int arr[], int n)
    {
        //Your code 
       unordered_set<int> h;
       long long int sum=0;
        for(int i=0;i<n;i++){
            sum+=arr[i];
            if(sum==0) return true;
            else if(h.find(sum)!=h.end()) return true;
            else{ h.insert(sum);}
        }
        return false;
    }
//winner of an election
public:
    //Function to return the name of candidate that received maximum votes.
    vector<string> winner(string arr[],int n)
    {
        // Your code here
        // Return the string containing the name and an integer
        // representing the number of votes the winning candidate got
        vector<string> v;
        unordered_map<string,int> h;
        for(int i=0;i<n;i++){
            h[arr[i]]++;
        }
        int maxi=INT_MIN;
        string key;
        //int val;
        for(auto i:h){
            if(i.second>maxi){ key=i.first;maxi=i.second;}
            else if(i.second==maxi){ key=min(key,i.first);maxi=i.second;}
        }
        string res=to_string(maxi);
        v.push_back(key);
        v.push_back(res);
        return v;
    }
//subarray range with given sum
public:
    //Function to count the number of subarrays which adds to the given sum.
    int subArraySum(int arr[], int n, int sum)
    {
        //Your code here
        unordered_map<int,int> m;
        int presum=0,res=0;
        for(int i=0;i<n;i++){
            presum+=arr[i];
            if(presum==sum)res++;
            if(m.find(presum-sum)!=m.end()){res+=m[presum-sum];}
            m[presum]++;
        }
        return res;
    }
//Positive Negative Pair
 public:
    //Function to return list containing all the pairs having both
    //negative and positive values of a number in the array.
    vector <int> findPairs(int arr[], int n) 
    {
        // code here
        vector<int> v;
        unordered_map<int,int> h;
        for(int i=0;i<n;i++){
            if(h.find(-1*arr[i])!=h.end()){h[-1*arr[i]]--;v.push_back(-1*abs(arr[i]));v.push_back(abs(arr[i]));}
           else h[arr[i]]++;
        }
        return v;
    }
//Zero sum subarrays
 public:
    //Function to count subarrays with sum equal to 0.
    ll findSubarray(vector<ll> arr, int n ) {
        //code here
        unordered_map<long long int,long long int> m;
        long long int presum=0,res=0,sum=0;
        for(int i=0;i<n;i++){
            presum+=arr[i];
            if(presum==sum)res++;
            if(m.find(presum-sum)!=m.end()){res+=m[presum-sum];}
            m[presum]++;
        }
        return res;
    }
//Subarrays with equal 1s and 0s
public:
    //Function to count subarrays with 1s and 0s.
    long long int countSubarrWithEqualZeroAndOne(int arr[], int n)
    {
        //Your code here
        unordered_map<long long int,long long int> m;
        long long int presum=0,res=0,sum=0;
        for(int i=0;i<n;i++){
            if(arr[i]==0)arr[i]=-1;
            presum+=arr[i];
            if(presum==sum)res++;
            if(m.find(presum-sum)!=m.end()){res+=m[presum-sum];}
            m[presum]++;
        }
        return res;        
    }
//sort an array according to the other
public:
    // A1[] : the input array-1
    // N : size of the array A1[]
    // A2[] : the input array-2
    // M : size of the array A2[]    
    //Function to sort an array according to the other array.
    vector<int> sortA1ByA2(vector<int> A1, int N, vector<int> A2, int M) 
    {
        //Your code here
        unordered_map<int,int> h;
        vector<int> v;
        for(int i=0;i<N;i++){
            h[A1[i]]++;
        }
        for(int i=0;i<M;){
            while(h[A2[i]]>0){
                v.push_back(A2[i]);
                h[A2[i]]--;
            }
            i++;
        }
        vector<int> res;
        for(auto it=h.begin();it!=h.end();){
           while((*it).second>0){
                res.push_back((*it).first);
                (*it).second--;
            }
            it++;  
        }
        sort(res.begin(),res.end());
        for(int i=0;i<res.size();i++){
            v.push_back(res[i]);
        }
        return v;
    }
//Sorting Elements of an Array by Frequency
#include<iostream>
#include<vector>
#include<unordered_map>
#include<algorithm>
using namespace std;
bool comp(pair<int,int>a,pair<int,int>b){
    if(a.second>b.second) return true;
    else if(a.second==b.second){if(a.first<b.first) return true;else return false;}
    else return false;
}
int main()
 {
	//code
	int t;
	cin>>t;
	while(t--){
	    int n,t;
	    cin>>n;
	    unordered_map<int,int> h;
	    vector<pair<int,int>> v;
	    for(int i=0;i<n;i++){
	        cin>>t;
	        h[t]++;
	    }
	    for(auto it:h){
	       v.push_back({it.first,it.second});
	    }
	    sort(v.begin(),v.end(),comp);
	    for(auto it:v){
	        int temp=it.second;
	        while(temp--)
	         cout<<it.first<<" ";
	    }
	   cout<<"\n";
	}
	return 0;
}
//Longest consecutive subsequence -o(n)time&space
public:
    // arr[] : the input array
    // N : size of the array arr[]
    //Function to return length of longest subsequence of consecutive integers.
    int findLongestConseqSubseq(int arr[], int N)
    {
      //Your code here
      int count=0,maxi=INT_MIN;
      unordered_set<int> h;
       for(int i=0;i<N;i++){
          h.insert(arr[i]);
      }
      for(int i=0;i<N;i++){
          if(h.find(arr[i]-1)==h.end()){
              int j=arr[i];
              while(h.find(j+1)!=h.end()){count++;j++;}
              count++;
              maxi=max(count,maxi);
          }
          count=0;
      }
      if(maxi==INT_MIN) return 1;
      return maxi;
    }

STRINGS:
//Naive Pattern searching
bool searchPattern(string str, string pat)
{
    // your code here
    int len=0,cnt=0;
    for(int i=0;i<str.length();i++){
        len=i;
        for(int j=0;j<pat.length()&&cnt<pat.length();j++){
            if(str[len]==pat[j]){len++;cnt++;}
            else {cnt=0;break;}
        }
        if(cnt==pat.length()) return true;
    }
    return false;
}
//Binary string (cnt of all substrings that should start and end with 1)
public:
    //Function to count the number of substrings that start and end with 1.
    long binarySubstring(int n, string a){
        
        // Your code here
        //m-1
        /*long cnt=0;
        int j=0;
        for(int i=0;i<a.length();i++){
            if(a[i]=='1'){
                j=i+1;
                while(j<a.length()){
                    if(a[j]=='1')cnt++;
                    j++;
                }
            }
        }
        return cnt;
        */
//m-2 return no of ways to form pair of 1's as count 
      long count=0;
      for(int i=0;i<a.length();i++){
          if(a[i]=='1') count++;
      }
      return count*(count-1)/2;
    }


//Implement strstr
//Function to locate the occurrence of the string x in the string s.
int strstr(string str, string pat)
{
     //Your code here
      int len=0,cnt=0;
    for(int i=0;i<str.length();i++){
        len=i;
        for(int j=0;j<pat.length()&&cnt<pat.length();j++){
            if(str[len]==pat[j]){len++;cnt++;}
            else {cnt=0;break;}
        }
        if(cnt==pat.length()) return i;
    }
    return -1;
}

//Anagram
public:
    //Function is to check whether two strings are anagram of each other or not.
    bool isAnagram(string a, string b){
        
        // Your code here
        unordered_map<int,int> h;
        if(a.length()!=b.length()) return false;
        for(int i=0;i<a.length();i++){
            h[a[i]]++;
        }
        for(int i=0;i<b.length();i++){
            if(h.find(b[i])==h.end()) return false;
            h[b[i]]--;
            if(h[b[i]]<=0) h.erase(b[i]);
        }
        return true;
    }

//Check if string is rotated by two places
 public:
    //Function to check if a string can be obtained by rotating
    //another string by exactly 2 places.
    
    void reverseArr(string &arr,int n, int low,int high){
          n=arr.length();
        while(low<high){
        swap(arr[low],arr[high]); 
        low++,high--;
      }
    }
    //Function to rotate an array by d elements in counter-clockwise direction. 
    string rotateArr(string &arr, int d, int n){
        // code here
         n=arr.length();
        if(d>n){
            d=d-n;
        }
        reverseArr(arr,n,0,d-1);
        reverseArr(arr,n,d,(n-1));
        reverseArr(arr,n,0,n-1);
        return arr;
    }
    bool isRotated(string str1, string str2)
    {
        // Your code here
        string copy=str1;
        if(str2==rotateArr(str1,2,str1.length())) return true; //counterclockwise rotation
        else if(str2==rotateArr(copy,str1.length()-2,str1.length())) return true;//clockwise rotation
        else return false;
    }

//Check if strings are rotations of each other or not
 public:
    /*
    //Function to check if two strings are rotations of each other or not.
     void reverseArr(string &arr,int n, int low,int high){
          n=arr.length();
        while(low<high){
        swap(arr[low],arr[high]); 
        low++,high--;
      }
    }
    //Function to rotate an array by d elements in counter-clockwise direction. 
    string rotateArr(string &arr, int d, int n){
        // code here
         n=arr.length();
        if(d>n){
            d=d-n;
        }
        reverseArr(arr,n,0,d-1);
        reverseArr(arr,n,d,(n-1));
        reverseArr(arr,n,0,n-1);
        return arr;
    }
    bool areRotations(string str1,string str2)
    {
        // Your code here
        string copy1,copy2;
        for(int i=0;i<str1.length();i++){
        copy1=str1;
        copy2=str1;
        if(str2==rotateArr(copy1,i,str1.length())) return true; //counterclockwise rotation
        else if(str2==rotateArr(copy2,str1.length()-i,str1.length())) return true;//clockwise rotation
        }
        return false;
    }
    */
    //method2
    bool areRotations(string str1,string str2){
        if(str1.length()!=str2.length()) return false;
        string r=str1+str1;
        if(r.find(str2)!=-1) return true;
        else return false;
    }

// ISOMORPHIC STRINGS
// This function returns true if str1 and str2 are isomorphic
bool areIsomorphic(string str1, string str2)
{
    int MAX_CHARS=256;
    int m = str1.length(), n = str2.length();

    // Length of both strings must be same for one to one
    // correspondence
    if (m != n)
        return false;

    // To mark visited characters in str2
    bool marked[MAX_CHARS] = { false };

    // To store mapping of every character from str1 to
    // that of str2. Initialize all entries of map as -1.
    int map[MAX_CHARS];
    memset(map, -1, sizeof(map));

    // Process all characters one by on
    for (int i = 0; i < n; i++) {
        // If current character of str1 is seen first
        // time in it.
        if (map[str1[i]] == -1) {
            // If current character of str2 is already
            // seen, one to one mapping not possible
            if (marked[str2[i]] == true)
                return false;

            // Mark current character of str2 as visited
            marked[str2[i]] = true;

            // Store mapping of current characters
            map[str1[i]] = str2[i];
        }

        // If this is not first appearance of current
        // character in str1, then check if previous
        // appearance mapped to same character of str2
        else if (map[str1[i]] != str2[i])
            return false;
    }

    return true;
}

// check if a string is Isogram or not
 public:
    //Function to check if a string is Isogram or not.
    bool isIsogram(string s)
    {
        //Your code here
        unordered_set<int> h;
        for(int i=0;i<s.length();i++){
            if(h.find(s[i])!=h.end()) return false;
            h.insert(s[i]);
        }
        return true;
    }

//Keypad typing
string printNumber(string s, int n) 
{
    //code here
   string one=" ",two="abc",three="def",four="ghi",five="jkl",six="mno",seven="pqrs",eight="tuv",nine="wxyz",star="*";
    string res="";
    for(int i=0;i<s.length();i++){
        if(one.find(s[i])!=-1) res+='1';
        else if(one.find(s[i])!=-1) res+='1';
        else if(two.find(s[i])!=-1) res+='2';
        else if(three.find(s[i])!=-1) res+='3';
        else if(four.find(s[i])!=-1) res+='4';
        else if(five.find(s[i])!=-1) res+='5';
        else if(six.find(s[i])!=-1) res+='6';
        else if(seven.find(s[i])!=-1) res+='7';
        else if(eight.find(s[i])!=-1) res+='8';
        else if(nine.find(s[i])!=-1) res+='9';
     }
    return res;
}

//Repeated Character
public:
    char firstRep (string s)
    {
        //code here.
       unordered_map<char,int> h;
       for(int i=0;i<s.length();i++){
           h[s[i]]++;
       }
       for(int i=0;i<s.length();i++){
           if(h[s[i]]>1) return s[i];
       }
       return '#';
    }
//Non Repeating Character
public:
    //Function to find the first non-repeating character in a string.
    char nonrepeatingCharacter(string s)
    {
       //Your code here
        unordered_map<char,int> h;
       for(int i=0;i<s.length();i++){
           h[s[i]]++;
       }
       for(int i=0;i<s.length();i++){
           if(h[s[i]]==1) return s[i];
       }
       return '$';
       
    }

//Maximum Occuring Character
public:
    //Function to find the maximum occurring character in a string.
    char getMaxOccuringChar(string str)
    {
        // Your code here
        unordered_map<char,int> h;
        char res;
        int maxi=INT_MIN;
        for(int i=0;i<str.length();i++){
            h[str[i]]++;
        }
        for(auto i:h){
            if(i.second>maxi) maxi=i.second,res=i.first;
            else if(i.second==maxi){
                if(i.first<res) res=i.first;
            }
        }
        return res;
    }

//Remove common characters and concatenate
public:
    //Function to remove common characters and concatenate two strings.
    string concatenatedString(string s1, string s2) 
    { 
        // Your code here
        unordered_map<char,int> h1,h2;
        int temp;
        string res="";
        
        for(int i=0;i<s1.length();i++){
            h1[s1[i]]++;
        }
        for(int i=0;i<s2.length();i++){
            h2[s2[i]]++;
        }
       for(int i=0;i<s1.length();i++){
           if(h2.find(s1[i])==h2.end()) res+=s1[i];
       }
       for(int i=0;i<s2.length();i++){
           if(h1.find(s2[i])==h2.end()) res+=s2[i];
       }
       if(res=="") return "-1";
       return res;
    }
//Reverse words in a given string
public:
    //Function to reverse words in a given string.
    string reverseWords(string s) 
    { 
        // code here 
        stack<string> st;
        string temp="",res="";
        for(int i=0;i<s.length();i++){
            if(s[i]=='.'){ st.push(temp);temp="";}
            else temp+=s[i];
        }
        st.push(temp);
        while(st.empty()!=true){
            res+=st.top();
            if(st.size()!=1)
              res+=".";
            st.pop();
        }
        
        return res;
    }
//Sum of numbers in string 
 public:
    int stoi(string temp){
        int len=(temp.length()),res=0,val=0,i=0;
        while(len--){
            val=temp[i]-'0';
            res*=10;
            res+=val;
            i++;
        }
        return res;
    }
    //Function to calculate sum of all numbers present in a string.
    int findSum(string str)
    {    	// Your code here
    	int res=0;
    	string temp="";
    	for(int i=0;i<str.length();i++){
    	    if(str[i]=='0'||str[i]=='1'||str[i]=='2'||str[i]=='3'||str[i]=='4'||str[i]=='5'||str[i]=='6'||str[i]=='7'||str[i]=='8'||str[i]=='9')
    	        temp+=str[i];
    	   else{
    	       if(str[i]=='\0') break;
    	         res+=stoi(temp);
    	         temp="";
    	   }
    	    
    	}
    	res+=stoi(temp);
    	return res;
    }

//Pangram Checking
public:
    //Function to check if a string is Pangram or not.
    bool checkPangram (string &str) {
        // your code here
        int chars[26]={0};
        transform(str.begin(),str.end(),str.begin(),::tolower);
        for(int i=0;i<str.length();i++){
            if(str[i]!='.'||str[i]!=','||str[i]!='?'||str[i]!=' ') chars[str[i]-'a']=1;
        }
        for(int i=0;i<26;i++){
            if(chars[i]!=1) return false;
        }
        return true;
    }

//Minimum indexed character 
public:
    //Function to find the minimum indexed character.
    int minIndexChar(string str, string patt)
    {
        // Your code here
        for(int i=0;i<str.length();i++){
            if(patt.find(str[i])!=string::npos) return i;
        }
        return -1;
    }
//Smallest window in a string containing all the characters of another string
string Minimum_Window(string s, string t)
{
//sliding window -o(s) time and o(1) space.
    int m[256] = { 0 };

    // Answer
    int ans = INT_MAX; // length of ans
    int start = 0; // starting index of ans
    int count = 0;
  
    // creating map
    for (int i = 0; i < t.length(); i++) {
        if (m[t[i]] == 0)
            count++;
        m[t[i]]++;
    }

    // References of Window
    int i = 0;
    int j = 0;

    // Traversing the window
    while (j < s.length()) {
        // Calculations
        m[s[j]]--;
        if (m[s[j]] == 0)
            count--;

        // Condition matching
        if (count == 0) {
            while (count == 0) {
                // Sorting ans
                if (ans > j - i + 1) {
                    ans = min(ans, j - i + 1);
                    start = i;
                }
                // Sliding I
                // Calculation for removing I

                m[s[i]]++;
                if (m[s[i]] > 0)
                    count++;

                i++;
            }
        }
        j++;
    }

    if (ans != INT_MAX)
        return s.substr(start, ans);
    else
        return "-1";
}

//Nth number made of prime digits
public:
    //Function to find nth number made of only prime digits.
    int primeDigits(int n)
    {
        //code here
        int rem=0;
        string res="";
        while(n){
            rem=n%4;
            switch(rem){
                case 1:res.push_back('2'); break;
                case 2: res.push_back('3');break;
                case 3:res.push_back('5'); break;
                case 0: res.push_back('7');break;
            }
            if(n%4==0) n--;
            n=n/4;
        }
        reverse(res.begin(),res.end());
        return stoi(res);
        
    }
//The Modified String
public:
    //Function to find minimum number of characters which Ishaan must insert  
    //such that string doesn't have three consecutive same characters.
    int modified (string a)
    {
        // Your code here
        int chars[26]={0};
        int flag=0,res=0,pos=0,count=1;
        string str2;
        for(int i=1;i<a.length();i++){
            if(a[i-1]==a[i]){
                count++;
                if(count==3){ 
                res++;
                count=1;
                }
            }
            else count=1;
        }
        return res;
    }
//Case-specific Sorting of Strings
public:
    //Function to perform case-specific sorting of strings.
    string caseSort(string str, int n)
    {
        // your code here
        int low[26]={0},up[26]={0};
        int l=0,u=0;
        for(int i=0;i<str.length();i++){
            if(int(str[i])>=65&&int(str[i])<=90) up[str[i]-'A']++;
            else if(int(str[i])>=97&&int(str[i])<=122) low[str[i]-'a']++;
        }
        //string res="";
        for(int i=0;i<str.length();i++){
            if(int(str[i])>=65&&int(str[i])<=90){
                while(up[u]==0){u++;}
                str[i]=char('A'+u);
                up[u]--;
                if(up[u]==0) u++;
            }
            else if(int(str[i])>=97&&int(str[i])<=122){
                while(low[l]==0) l++;
                str[i]=char('a'+l);
                low[l]--;
                if(low[l]==0) l++;
            }
        }
        return str;
    }

//Lexicographic Rank Of A String

// Construct a count array where value at every index
// contains count of smaller characters in whole string
void populateAndIncreaseCount(int* count, string str)
{
	int i,MAX_CHAR=256;

	for (i = 0; str[i]; ++i)
		++count[str[i]];

	for (i = 1; i < MAX_CHAR; ++i)
		count[i] += count[i - 1];
}

// Removes a character ch from count[] array
// constructed by populateAndIncreaseCount()
void updatecount(int* count, char ch)
{
	int i,MAX_CHAR=256;;
	for (i = ch; i < MAX_CHAR; ++i)
		--count[i];
}
// A function to find rank of a string in all permutations
// of characters
int findRank(string str)
{
	int len = strlen(str);
	int mul = fact(len);
	int rank = 1, i,MAX_CHAR=256;;

	// all elements of count[] are initialized with 0
	int count[MAX_CHAR] = { 0 };

	// Populate the count array such that count[i]
	// contains count of characters which are present
	// in str and are smaller than i
	populateAndIncreaseCount(count, str);

	for (i = 0; i < len; ++i) {
		mul /= len - i;

		// count number of chars smaller than str[i]
		// from str[i+1] to str[len-1]
		rank += count[str[i] - 1] * mul;

		// Reduce count of characters greater than str[i]
		updatecount(count, str[i]);
	}

	return rank;
}

//Rabin Karp - Pattern Searching
 public:
        vector <int> search(string pat, string txt)
        {
            //code here.
            vector<int> res;
            int q=INT_MAX,h=1,d=256,p=0,t=0;
            int m=pat.length(),n=txt.length();
            for(int i=0;i<m-1;i++){
                h=(h*d)%q;
            }
            for(int i=0;i<=m-1;i++){
                p=(p*d+pat[i])%q;
                t=(t*d+txt[i])%q;
            }
            for(int i=0;i<=n-m;i++){
               if(p==t){
                 bool flag=true;
                 for(int j=0;j<m;j++){
                     if(txt[i+j]!=pat[j]){flag=false;break;}
                 }
                 if(flag==true) res.push_back(i+1);
               }
               if(i<n-m){
                   t=(d*(t-txt[i]*h)+txt[i+m])%q;
                   if(t<0) t=t+q;
               }
            }
            if(res.size()<1) res.push_back(-1);
            return res;
        }

// Pattern Search KMP
// Prints occurrences of txt[] in pat[]
// Fills lps[] for given patttern pat[0..M-1]
void computeLPSArray(char* pat, int M, int* lps)
{
    // length of the previous longest prefix suffix
    int len = 0;

    lps[0] = 0; // lps[0] is always 0

    // the loop calculates lps[i] for i = 1 to M-1
    int i = 1;
    while (i < M) {
        if (pat[i] == pat[len]) {
            len++;
            lps[i] = len;
            i++;
        }
        else // (pat[i] != pat[len])
        {
            // This is tricky. Consider the example.
            // AAACAAAA and i = 7. The idea is similar
            // to search step.
            if (len != 0) {
                len = lps[len - 1];

                // Also, note that we do not increment
                // i here
            }
            else // if (len == 0)
            {
                lps[i] = 0;
                i++;
            }
        }
    }
}

void KMPSearch(char* pat, char* txt)
{
    int M = strlen(pat);
    int N = strlen(txt);

    // create lps[] that will hold the longest prefix suffix
    // values for pattern
    int lps[M];

    // Preprocess the pattern (calculate lps[] array)
    computeLPSArray(pat, M, lps);

    int i = 0; // index for txt[]
    int j = 0; // index for pat[]
    while (i < N) {
        if (pat[j] == txt[i]) {
            j++;
            i++;
        }

        if (j == M) {
            printf("Found pattern at index %d ", i - j);
            j = lps[j - 1];
        }

        // mismatch after j matches
        else if (i < N && pat[j] != txt[i]) {
            // Do not match lps[0..lps[j-1]] characters,
            // they will match anyway
            if (j != 0)
                j = lps[j - 1];
            else
                i = i + 1;
        }
    }
}
//Check if a String is Subsequence of Other
public:
    bool isSubSequence(string A, string B) 
    {
        // code here
        if(A.length()>B.length()) return false;
        int i=0,j=0;
        while(j<B.length()&&i<A.length()){
            if(A[i]==B[j]){i++,j++;}
            else j++;
        }
        if(i==A.length()) return true;
        else return false;
    }


LINKEDLISTS:
//01.Count nodes of linked list
//public:
    //Function to count nodes of a linked list.
    int getCount(struct Node* head){
    
        //Code here
        if(head==NULL) return 0;
        Node *p=head;
        int count=0;
        while(p!=NULL&&p->next!=NULL){
            count++;
            p=p->next;
        }
    return count+1;
    }

//02.Linked List Insertion
 public:
    //Function to insert a node at the beginning of the linked list.
    Node *insertAtBegining(Node *head, int x) {
       // Your code here
       if(head==NULL){head=new Node(x);return head;}
       Node *n=new Node(x);
       n->next=head;
       return n;
       
    }  
    //Function to insert a node at the end of the linked list.
    Node *insertAtEnd(Node *head, int x)  {
       // Your code here
       if(head==NULL){head=new Node(x);return head;}
       Node *n=new Node(x);
       Node *t=head;
       while(t->next!=NULL) t=t->next;
       t->next=n;
       return head;
    }

//03.Doubly linked list Insertion at given position
void addNode(Node *head, int pos, int x)
{
   // Your code here
   int count=0;
   Node *n=new Node(x);
   Node * t=head;
   while(count!=pos){
       t=t->next;
       count++;
   }
   if(t->next==NULL){t->next=n;n->prev=t; return;}
   n->next=t->next;
   n->prev=t;
   t->next=n;
   n->next->prev=n;
   return;
   
}
//04.Insert in Middle of Linked List
//Function to insert a node in the middle of the linked list.
Node* insertInMiddle(Node* head, int x)
{
	// Code here
	Node * slow=NULL;
	Node * fast=NULL;
	Node * n=new Node(x);
	if(head==NULL){head=n; return head;}
	slow=head;
	fast=head;
	while(fast!=NULL&&fast->next!=NULL&&fast->next->next!=NULL){
	    slow=slow->next;
	    fast=fast->next->next;
	}
	n->next=slow->next;
   	slow->next=n; 
	return head;
}

//05.Identical Linked Lists
//Function to check whether two linked lists are identical or not. 
bool areIdentical(struct Node *head1, struct Node *head2)
{
    // Code here
    Node *h1=head1;
    Node *h2=head2;
    while(h1!=NULL&&h2!=NULL&&h1->data==h2->data){
        h1=h1->next;
        h2=h2->next;
    }
    if(h1==NULL&&h2==NULL) return true;
    else return false;    
}

//06.Delete without head pointer
 public:
    //Function to delete a node without any reference to head pointer.
    void deleteNode(Node *del)
    {
       // Your code here
       del->data=del->next->data;
       Node *t=del->next;
       del->next=del->next->next;
       t->next=NULL;
       delete t;
    }
//07. Remove duplicate element from sorted Linked List
//Function to remove duplicates from sorted linked list.
Node *removeDuplicates(Node *head)
{
 // your code goes here
 Node *t=head;
 Node *q=head;
 while(t!=NULL&&t->next!=NULL){
     if(t->next!=NULL&&t->data!=t->next->data){t=t->next;}
     else if(t->next!=NULL&&t->data==t->next->data){
         q=t->next;
         t->next=t->next->next;
         q->next=NULL;
         delete q;
     }
 }
 return head;
}

//08.Remove duplicates from an unsorted linked list
public:
    //Function to remove duplicates from unsorted linked list.
    Node * removeDuplicates( Node *head) 
    {
     // your code goes here
     unordered_set<int> h;
     Node * curr=head;
     Node * prev=NULL;
     while(curr!=NULL){
         if(h.find(curr->data)!=h.end()){prev->next=curr->next;delete curr;}
         else{ 
             h.insert(curr->data);
             prev=curr;
         }
         curr=prev->next;
     }
     return head;
    }
//09.Merge two sorted linked lists
//Function to merge two sorted linked list.
Node* sortedMerge(Node* head1, Node* head2)  
{  
    // code here
    if(head1==NULL)return head2;
    if(head2==NULL)return head1;
    Node *head=NULL;
    Node *tail=NULL;
    if(head1->data<=head2->data){
        head=tail=head1;
        head1=head1->next;
    }
    else {
        head=tail=head2;
        head2=head2->next;
    }
    while(head1!=NULL&&head2!=NULL){
        if(head1->data<=head2->data){
            tail->next=head1;
            tail=head1;
            head1=head1->next;
        }
        else{
            tail->next=head2;
            tail=head2;
            head2=head2->next;
        }
    }
    if(head1==NULL){
        tail->next=head2;
    }else{
        tail->next=head1;
    }
    return head;    
}  
//10.Nth node from end of linked list
//Function to find the data of nth node from the end of a linked list.
int getNthFromLast(Node *head, int n)
{
       // Your code here
       if(head==NULL||n<=0)return -1;
       Node *first=head;
       Node *second=head;
       for(int i=1;i<=n;i++){
           if(first==NULL) return -1;
           first=first->next;
       }
       while(first!=NULL){
           first=first->next;
           second=second->next;
       }
       return second->data;    
}
//11.Swap Kth nodes from ends
Node *swapkthnode(Node* head, int num, int K)
{
 // Count nodes in linked list
	int n = num,k=K;        
	// Check if k is valid
	if (n < k)
		return head;
	// If x (kth node from start) and y(kth node from end)
	// are same
	if (2 * k - 1 == n)
		return head;
	// Find the kth node from the beginning of the linked
	// list. We also find previous of kth node because we
	// need to update next pointer of the previous.
	Node* x = head;
	Node* x_prev = NULL;
	for (int i = 1; i < k; i++) {
		x_prev = x;
		x = x->next;
	}
	// Similarly, find the kth node from end and its
	// previous. kth node from end is (n-k+1)th node from
	// beginning
	Node* y = head;
	Node* y_prev = NULL;
	for (int i = 1; i < n - k + 1; i++) {
		y_prev = y;
		y = y->next;
	}
	// If x_prev exists, then new next of it will be y.
	// Consider the case when y->next is x, in this case,
	// x_prev and y are same. So the statement "x_prev->next
	// = y" creates a self loop. This self loop will be
	// broken when we change y->next.
	if (x_prev)
		x_prev->next = y;
	// Same thing applies to y_prev
	if (y_prev)
		y_prev->next = x;
	// Swap next pointers of x and y. These statements also
	// break self loop if x->next is y or y->next is x
	Node* temp = x->next;
	x->next = y->next;
	y->next = temp;
	// Change head pointers when k is 1 or n
	if (k == 1)
		head = y;
	if (k == n)
		head = x;
	return head;
}
//12.Reverse a linked list
public:
    //Function to reverse a linked list.
    struct Node* reverseList(struct Node *head)
    {
        // code here
        // return head of reversed list
        if(head==NULL)return head;
        Node *curr=head;
        Node *prev=NULL;
        Node *next=head->next;
        while(curr->next!=NULL){
            curr->next=prev;
            prev=curr;
            curr=next;
            next=next->next;
        }
        curr->next=prev;
        head=curr;
        return head;
    }
//13.Detect Loop in linked list
public:
    //Function to check if the linked list has a loop.
    bool detectLoop(Node* head)
    {
        // your code here
        if(head==NULL)return false;
        Node *next=NULL;
        Node *temp=new Node(10);//dummy node;
        Node *curr=head;
        while(curr!=NULL){
            if(curr->next==NULL)return false;
            next=curr->next;
            if(curr->next==temp)return true;
            else  curr->next=temp;
            curr=next;
        }

    }
//14.Find length of Loop
//Function to find the length of a loop in the linked list.
int countNodesinLoop(struct Node *head)
{
    // Code here
    if(head==NULL)return 0;
    Node *fast=head,*slow=head;
    while(slow!=NULL&&fast!=NULL&&fast->next!=NULL){//floyd cycle detec == slow,fast pointer concept
        fast=fast->next->next;
        slow=slow->next;
        if(slow==fast){//here both pointers doesn't meet at start of loop but meet at any node in loop and then to find length of loop we count until that nodes comes again
            int count=1;
            Node *temp=slow;
            while(temp->next!=slow){
                count++;
                temp=temp->next;
            }
            return count;
        }
    }
    return 0;
}
//15.Remove loop in Linked List
int detectAndRemoveLoop(struct Node* list)
{
    struct Node *slow_p = list, *fast_p = list;

    // Iterate and find if loop exists or not
    while (slow_p && fast_p && fast_p->next) {
        slow_p = slow_p->next;
        fast_p = fast_p->next->next;

        /* If slow_p and fast_p meet at some point then there
           is a loop */
        if (slow_p == fast_p) {
            removeLoop(slow_p, list);

            /* Return 1 to indicate that loop is found */
            return 1;
        }
    }

    /* Return 0 to indicate that there is no loop*/
    return 0;
}

/* Function to remove loop.
 loop_node --> Pointer to one of the loop nodes
 head -->  Pointer to the start node of the linked list */
void removeLoop(struct Node* loop_node, struct Node* head)
{
    struct Node* ptr1 = loop_node;
    struct Node* ptr2 = loop_node;

    // Count the number of nodes in loop
    unsigned int k = 1, i;
    while (ptr1->next != ptr2) {
        ptr1 = ptr1->next;
        k++;
    }

    // Fix one pointer to head
    ptr1 = head;

    // And the other pointer to k nodes after head
    ptr2 = head;
    for (i = 0; i < k; i++)
        ptr2 = ptr2->next;

    /*  Move both pointers at the same pace,
      they will meet at loop starting node */
    while (ptr2 != ptr1) {
        ptr1 = ptr1->next;
        ptr2 = ptr2->next;
    }

    // Get pointer to the last node
    while (ptr2->next != ptr1)
        ptr2 = ptr2->next;

    /* Set the next node of the loop ending node
      to fix the loop */
    ptr2->next = NULL;
}

//16.Rotate a Linked List
public:
    //Function to rotate a linked list.
    Node* rotate(Node* head, int k)
    {
        // Your code here
        Node *t=head,*n=head;
        while(t!=NULL&&k>1){
            t=t->next;
            n=t;
            k--;
        }
        if(t==NULL)return head;
        while(n!=NULL&&n->next!=NULL){
            n=n->next;
        }
        n->next=head;
        head=t->next;
        t->next=NULL;
        return head;
    }
//17.Add two numbers represented by linked lists
 public:
    struct Node* addAtBegin(struct Node * head,int x){
        if(head==NULL){Node *n=new Node(x);head=n;return head;}
        Node *n=new Node(x);
        n->next=head;
        return n;
    }
    struct Node* reverseLL(struct Node* head){
        if(head==NULL)return head;
        Node *curr=head;
        Node *prev=NULL;
        Node *next=head->next;
        while(curr->next!=NULL){
            curr->next=prev;
            prev=curr;
            curr=next;
            next=next->next;
        }
        curr->next=prev;
        head=curr;
        return head;
    }
    //Function to add two numbers represented by linked list.
    struct Node* addTwoLists(struct Node* first, struct Node* second)
    {
        // code here
        Node *ans=NULL;
        first=reverseLL(first);
        second=reverseLL(second);
        int carry=0;
        while(first!=NULL||second!=NULL||carry==1){
            int newVal=carry;
            if(first!=NULL){newVal+=first->data;first=first->next;}
            if(second!=NULL){newVal+=second->data;second=second->next;}
            carry=newVal/10;
            newVal=newVal%10;
            ans=addAtBegin(ans,newVal);
        }
        return ans;
    }

//18.Pairwise swap of nodes in LinkeList
public:
    Node* pairWiseSwap(struct Node* head) 
    {
        // The task is to complete this method
        if(head==NULL||head->next==NULL)return head;
        Node *prev=head,*curr=head->next,*last=NULL;
        head=head->next;
        while(prev!=NULL&&prev->next!=NULL&&curr!=NULL){
            prev->next=curr->next;
            curr->next=prev;
            if(last!=NULL)last->next=curr;
            last=prev;
            prev=prev->next;
            if(prev!=NULL&&prev->next!=NULL) curr=prev->next;            
        }
        return head;
    }

//19.Check if Linked List is Palindrome
public:
    struct Node* reverseLL(struct Node* head){
        if(head==NULL)return head;
        Node *curr=head;
        Node *prev=NULL;
        Node *next=head->next;
        while(curr->next!=NULL){
            curr->next=prev;
            prev=curr;
            curr=next;
            next=next->next;
        }
        curr->next=prev;
        head=curr;
        return head;
    }
    //Function to check whether the list is palindrome.
    bool isPalindrome(Node *head)
    {
        //Your code here
        if(head==NULL) return false;
        Node *slow=head,*fast=head;
        while(fast!=NULL&&fast->next!=NULL&&fast->next->next!=NULL){
            slow=slow->next;
            fast=fast->next->next;
        }
        if(fast->next==NULL){//odd length
            slow->next=reverseLL(slow->next);
            Node * rev=slow->next;
            fast=head;
            while(fast!=slow){
                if(fast->data!=rev->data) return false;
                fast=fast->next;rev=rev->next;
            }
        }
        else {//even length
            slow->next=reverseLL(slow->next);
            Node * rev=slow->next;
            fast=head;
            while(fast!=slow->next){
                if(fast->data!=rev->data) return false;
                fast=fast->next;rev=rev->next;
            }
        }
        return true;
    }
//20.Merge Sort for Linked List
/*
Merge sort is often preferred for sorting a linked list. The slow random-access performance of a linked list makes some other algorithms (such as quicksort) perform poorly, and others (such as heapsort) completely impossible.
*/
public:
    Node* findMid(Node* head){
        if(head==NULL) return head;
        Node *slow=head,*fast=head;
        while(fast!=NULL&&fast->next!=NULL&&fast->next->next!=NULL){
            slow=slow->next;
            fast=fast->next->next;
        }
        return slow;
    }
    Node* merge(Node* l1,Node* l2){
        if(l1==NULL) return l2;
        if(l2==NULL)return l1;
        Node *head=NULL,*tail=NULL;
        if(l1->data<=l2->data){head=tail=l1;l1=l1->next;}
        else {head=tail=l2;l2=l2->next;}
        while(l1!=NULL&&l2!=NULL){
            if(l1->data<=l2->data){tail->next=l1;tail=l1;l1=l1->next;}
            else if(l1->data>l2->data){tail->next=l2;tail=l2;l2=l2->next;}
        }
        if(l1==NULL&&l2!=NULL){tail->next=l2;}
        if(l1!=NULL&&l2==NULL){tail->next=l1;}
        return head;
    }
    //Function to sort the given linked list using Merge Sort.
    Node* mergeSort(Node* head) {
        // your code here
        if(head==NULL) return head;
        if(head->next==NULL) return head;
        Node * mid=findMid(head);
        Node *head2=mid->next;
        mid->next=NULL;
        Node *l1= mergeSort(head);
        Node *l2= mergeSort(head2);
        head=merge(l1,l2);
        return head;
    }
//21.Given a linked list of 0s, 1s and 2s, sort it.
  public:
    //Function to sort a linked list of 0s, 1s and 2s.
    Node* segregate(Node *head) {
        
        // Add code here
        if(head==NULL) return NULL;
        Node *zero=NULL,*one=NULL,*t=head,*two=NULL,*z=NULL,*to=NULL,*o=NULL;
        while(t!=NULL){
            if(t->data==0){if(zero==NULL){z=zero=t;}else{zero->next=t;zero=t;} t=zero->next;zero->next=NULL;}
            else if(t->data==2){if(two==NULL){to=two=t;}else{two->next=t;two=t;} t=two->next;two->next=NULL;}
            else if(t->data==1){if(one==NULL){o=one=t;}else{one->next=t;one=t;} t=one->next;one->next=NULL;}
            
        }
        if(z!=NULL) head=z; else if(o!=NULL) head=o;else if(to!=NULL) head=to;
        if(zero!=NULL){if(o!=NULL)zero->next=o; else if(to!= NULL) zero->next=to; else zero->next=NULL;}
        if(one!=NULL){ if(to!=NULL)one->next=to;else one->next=NULL;}
        if(two!=NULL) two->next=NULL;
        return head;
    }
//22.Merge Sort on Doubly Linked List
Node *findMidDoubly(Node* head){
    if(head==NULL){return head;}
    Node *slow=head,*fast=head;
    while(fast!=NULL&&fast->next!=NULL&&fast->next->next!=NULL){
        slow=slow->next;
        fast=fast->next->next;
    }
    return slow;
    
}
Node *mergeDoubly(Node* l1,Node* l2){
    if(l1==NULL) return l2;
    if(l2==NULL) return l1;
    Node *head=NULL,*tail=NULL;
    if(l1->data<=l2->data){head=tail=l1;l1->prev=NULL;l1=l1->next;}
    else if(l1->data>l2->data){head=tail=l2;l2->prev=NULL;l2=l2->next;}
    while(l1!=NULL&&l2!=NULL){
        if(l1->data<=l2->data){tail->next=l1;l1->prev=tail;tail=l1;l1=l1->next;}
        else if(l1->data>l2->data){tail->next=l2;l2->prev=tail;tail=l2;l2=l2->next;}
    }
    if(l1!=NULL&&l2==NULL){tail->next=l1;l1->prev=tail;}
    if(l1==NULL&&l2!=NULL){tail->next=l2;l2->prev=tail;}
    return head;
}
//Function to sort the given doubly linked list using Merge Sort.
struct Node *sortDoubly(struct Node *head)
{
	// Your code here
	if(head==NULL||head->next==NULL)return head;
	Node *mid=findMidDoubly(head);
	Node *head2=mid->next;
	mid->next=NULL;
	head2->prev=NULL;
	Node *l1=sortDoubly(head);
	Node *l2=sortDoubly(head2);
	head=mergeDoubly(l1,l2);
	return head;
} 
//23.Merge K sorted linked lists
 public:
    Node* merge(Node* l1,Node* l2){
        if(l1==NULL) return l2;
        if(l2==NULL)return l1;
        Node *head=NULL,*tail=NULL;
        if(l1->data<=l2->data){head=tail=l1;l1=l1->next;}
        else {head=tail=l2;l2=l2->next;}
        while(l1!=NULL&&l2!=NULL){
            if(l1->data<=l2->data){tail->next=l1;tail=l1;l1=l1->next;}
            else if(l1->data>l2->data){tail->next=l2;tail=l2;l2=l2->next;}
        }
        if(l1==NULL&&l2!=NULL){tail->next=l2;}
        if(l1!=NULL&&l2==NULL){tail->next=l1;}
        return head;
    }
    //Function to merge K sorted linked list.
    Node * mergeKLists(Node *arr[], int K)
    {
           // Your code here
           int i=0,j;
           if(K>1) j=1;
           else return arr[0];
           while(j<K){
               arr[i]=merge(arr[i],arr[j]);
               j++;
           }
           return arr[0];
    }
//24.Intersection Point in Y Shapped Linked Lists
//Function to find intersection point in Y shaped Linked Lists.
int intersectPoint(Node* head1, Node* head2)
{
    // Your Code Here
    Node *t=head1,*p=NULL;
    int c1=0,c2=0;
    while(t!=NULL){
        t=t->next;
        c1++;
    }
    t=head2;
    while(t!=NULL){
        t=t->next;
        c2++;
    }
    int extra=abs(c1-c2);
    if(c1>=c2){t=head1;p=head2;}
    else{t=head2;p=head1;}
    while(extra>0){
        t=t->next;
        extra--;
    }
    while(t!=NULL&&p!=NULL&&t!=p){
       t=t->next;p=p->next; 
    }
    if(t!=NULL&&p!=NULL) return t->data;
    else return -1;    
}
//25.