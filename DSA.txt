K-th element of two sorted Arrays
MATHEMATICS AND BASICS:
//finding number of digits in a number
int numOfDigits(int n){
return floor(log10(n))+1;
}
//factorial
int fact(int n){
int res=1;
for(int i=n;i>=1;i--)
  res=res*i;
return res;  
}
//palindrome
int palindrome(int n){
int res=n,rev=0;
while(n>0){
 rev=rev*10+n%10;
 n=n/10;
}
return (res==rev);
}
//gcd or hcf
int gcd(int a,int b){
while(a!=b){
if(a>b) a=a-b;
if(b>a) b=b-a;
}
return a;
}
//peak element
  public:
    int findPeak(int arr[],int n,int l,int r){
        int mid=l+(r-l)/2;
        if((mid==n-1||arr[mid]>=arr[mid+1])&&(mid==0||arr[mid-1]<=arr[mid])){
           return mid;
       }else if(mid<n-1&&arr[mid]<arr[mid+1]){
           findPeak(arr,n,mid+1,r);
       }else if(mid>0 && arr[mid-1]>arr[mid]){
           findPeak(arr,n,l,mid-1);
       }
    }
    int peakElement(int arr[], int n)
    {
       // Your code here
       int l=0,r=n-1;
       return findPeak(arr,n,l,r);
       }
return a;
}
//lcm
int lcm(int a,int b){
return (a*b)/(gcd(a,b));
}
//check for prime
bool prime(int n){
if(n==1) return false;
if(n==2||n==3) return true;
if(n%2==0||n%3==0) return false;
for(int i=5;i*i<=n;i=i+6){
 if(n%i==0||n%(i+2)==0) return false;
}
return true;
}
//prime factors
void primeFactors(int n){
while(n%2==0){
n=n/2;
cout<<2<<endl;
}
while(n%3==0){
n=n/3;
cout<<3<<endl;
}
for(int i=5;i*i<=n;i=i+6){
 while(n%i==0){
 n=n/i;
 cout<<i<<endl;
 }
 while(n%(i+2)==0){
 n=n/(i+2);
 cout<<(i+2)<<endl;
 }
}
if(n>3)
 cout<<n<<endl;
}
//Largest prime factor
 bool isPrime(long long int n){
        if(n==1) return false;
        if(n==2||n==3) return true;
        if(n%2==0||n%3==0) return false;
        for(long long int i=5;i*i<=n;i+=6){
            if(n%i==0) return false;
            if(n%(i+2)==0) return false;
        }
        return true;
    }
    long long int largestPrimeFactor(int N){
        // code here
        long long int maxi=0;
        if(isPrime(N)) return N;
        for(long long int i=2;i*i<=N;i++){
            if(N%i==0&&isPrime(i)) maxi=max(maxi,i);
            if(N%i==0&&isPrime(N/i)) maxi=max(maxi,(N/i));
        }
        return maxi;
    }
//All divisors of a number
void allDivisors(int n){
for(int i=1;i*i<=n;i++){
 if(n%i==0) cout<<i<<endl;
}
for(;i>=1;i--){
 if(n%i==0) cout<<n/i<<endl;
}
}
//Sieve of erathosthenes //Prints all prime numbers till n;
void sieve(int n){
vector<bool> sieve(n+1,true);
for(int i=2;i*i<=n;i++){
 if(sieve[i]==true){
  for(int j=i*i;j<=n;j++){
  sieve[i]=false;
  }
 }
}
for(int i=2;i<=n;i++){
 if(sieve[i]==true) cout<<i<<endl;
}
}

STRING:
//Longest Common Prefix in an Array of string
string longestCommonPrefix (string arr[], int N)
    {
        // your code here
       string prefix=arr[0];
       for(int i=1;i<N;i++){
           string ans="";
           string curr=arr[i];
           int l=min(prefix.length(),curr.length());
           for(int j=0;j<l;j++){
               if(prefix[j]!=curr[j]) break;
               ans+=curr[j];
           }
           if(ans=="") return "-1";
           else prefix=ans;
       }
       return prefix;
    }
string FirstNonRepeating(string s){
     // Code here
    queue<char> q;
    unordered_map<char,int> h;
    string res="";
    for(int i=0;i<s.size();i++){
        h[s[i]]++;
        if(h[s[i]]==1) q.push(s[i]);
          while(!q.empty()&&h[q.front()]>1){
	            q.pop();
          }
        if(q.empty()) res+='#';
        else res+=q.front();
     }
     return res;
}
BIT MANIPULATION:
 // Function to check if given number n is a power of two.
    bool isPowerofTwo(long long n){
        
        // Your code here    
        return (n>0)&&((n&(n-1))==0);
        
    }
// getting first set bit
unsigned int getFirstSetBit(int n)
    {
       return log2(n^(n&(n-1)))+1;
    }
//Function to find the first position with different bits.
    int posOfRightMostDiffBit(int m, int n)
    {
        // Your code here
        int i=m^n,res=-1;
        res=(log2(i^(i&(i-1)))+1);
        if(res>-1) return res;
        else return -1;
    }
// Function to check if Kth bit is set or not.
    bool checkKthBit(int n, int k)
    {
        // Your code here
        // It can be a one liner logic!! Think of it!!
        return n&(1<<k);
    }
//count set bit in an integer
 int setBits(int N) {
        // Write Your Code here
        int lookup[256]={0};
        for(int i=1;i<256;i++)
            lookup[i]=(i&1)+lookup[i/2];
        int res=0;
        while(N>0){
            res=res+lookup[N&0xff];
            N=N>>8;
        }
       return res;
    }
//count set bit from 1 to n
//method-1-DP LOOKUP
int lookup[n+1]={0};
for(int i=1;i<n;i++)
    lookup[i]=(i&1)+lookup[i/2];
int res=0;
for(int i=n;i>=1;i--){
    res=res+lookup[n&0xff];
 }
return res;
//method-2-o(logn)
 int countSetBits(int n){
        n++;
        int countsetbits=n/2,pairs=0,setbits=0,remainingsetbits=0;
        int powerof2=2;
        while(powerof2<=n){
        pairs=n/powerof2;
        setbits=(pairs/2)*powerof2;
        remainingsetbits=(pairs&1)?n%powerof2:0;
        countsetbits=countsetbits+setbits+remainingsetbits;
        powerof2=powerof2<<1;
        }
    return countsetbits;
    }
 // Function to find number of bits needed to be flipped to convert A to B
    int countBitsFlip(int a, int b){
        
        // Your logic her
        int n=a^b;
        return __builtin_popcount(n);
        
    }
//Function to check if the number is sparse or not.
    bool isSparse(int n)
    {
        // Your code
        int flag=0;
        while(n>0){ 
            if(flag==2) return 0;
            if(n&1==1) flag+=1;
            else flag=0;  
            n=n>>1;
        }
        if(flag==2) return 0;
        return 1;
    }
//longest consecutive ones
int maxConsecutiveOnes(int N)
    {
        // code here
         int n=N,flag=0,maxlen=0;
        while(n>0){ 
            if(n&1==1){  flag+=1;maxlen=max(maxlen,flag);}
            else flag=0;  
            n=n>>1;
        }
      return maxlen;
    }
//binary to gray code
 string binToGrey(string B) {
        // code here
        string g;
        g.push_back(B[0]);
        for(int i=1;i<B.length();i++){
            char res=(B[i-1]==B[i])?'0':'1';
            g.push_back(res);
            }
        return g;
    }
// gray code to binary    
    string greyToBin(string G) {
        // code here
        string b="";
        b.push_back(G[0]);
        for(int i=1;i<G.length();i++){
         char res=(b[i-1]==G[i])?'0':'1';
          b.push_back(res);
        }
        return b;
    }
 //Function to swap odd and even bits.
    unsigned int swapBits(unsigned int n)
    {
    	// Your code here
    for(int i=0;i<32;i=i+2){//since int is 32 bit and check for i and i+1 th at a time
    int ithbit=(n>>i)&1;//get ith bit
    int iplus1thbit=(n>>(i+1))&1;//get i+1 th bit
    n=n-(ithbit<<i)-(iplus1thbit<<(i+1))+(ithbit<<(i+1))+(iplus1thbit<<i);//remove ith bit and i+1 th bit and addnew swapped values of ith and i+1 th bit
    }
    return n;
    }
//Maximum AND value of any pair in an array.
int checkBits(int * arr,int n,int pattern){
        int count=0;
        for(int i=0;i<n;i++){
            if((arr[i]&pattern)==pattern)//if there is a num in arr which has his bit set then do count++
                count++;// so if two or more such num present then this bit can be included in our pattern or final res.
        }
        return count;
    }
    // Function for finding maximum AND value.
    int maxAND (int arr[], int N)
    {
        // Your code here
        int res=0,setbit,count=0;
        for(int i=31;i>=0;i--){
            setbit=res|(1<<i); //set i th bit and add res or pattern(a number which will have set bits only when two such num in arr are present having this bit set) till now to check if this bit can be included or not
            count=checkBits(arr,N,setbit);// check if this setbit can be included or not
            if(count>=2)//means there are 2 numbers having this bit set thus on doing their AND this bit will be included else not
                res=res|(1<<i);//include this setbit
            
        }
        return res;
    }
//Toggle bits given range
int toggleBits(int N , int L , int R) {
        // code here
        for(int i=L-1;i<=R-1;i++){
            N=N^(1<<i);
        }
        return N;
    }
//Largest Number formed from an Array
 static bool comp(string a,string b){
        return a+b>b+a;
    }
	// The main function that returns the arrangement with the largest value as
	// string.
	// The function accepts a vector of strings
	string printLargest(vector<string> &arr) {
	    // code here
	    sort(arr.begin(),arr.end(),comp);
	    string res="";
	    for(auto &i:arr){
	        res+=i;
	    }
	    return res;
	}
//Generate IP Addresses
 bool isValid(string x){
        int n=x.size();
        if(n==0||n>3||stoi(x)>255||((x[0]=='0')&&(n>1))) return false;
        return true;
    }
    vector<string> genIp(string &s) {
        // Your code here
        int n=s.length();
        string a="",b="",c="",d="";
        vector<string> ans;
        for(int i=0;i<n-3;i++){
            for(int j=i+1;j<n-2;j++){
                for(int k=j+1;k<n-1;k++){
                        a=s.substr(0,i+1);
                        b=s.substr(i+1,j-i);
                        c=s.substr(j+1,k-j);
                        d=s.substr(k+1,n-1-k);
                        if(isValid(a)&&isValid(b)&&isValid(c)&&isValid(d)){
                            string res=a+"."+b+"."+c+"."+d;
                            ans.push_back(res);
                        }
                }
            }
        }
        if(ans.empty()){ans.push_back("-1");}
        return ans;
    }
RECURSION:
//Print 1 to n without using loops
    void printTillN(int N)
    {
        // Write Your Code here
        if(N<=0) return;
        printTillN(N-1);
        cout<<N<<" ";
    }
//Sum of digits
 int sumOfDigits(int N){
        //code here
        int digit=0;
       while(N>0){
           digit+=N%10;
           N=N/10;
       }
       return digit;
    }
//count digits
int evenlyDivides(int N){
        //code here
        int digit=0,count=0,n=N;
        while(N>0){
            digit=N%10;
            if(digit!=0&&n%digit==0) count++;
            N=N/10;
        }
        return count;
    }
//Digital Roots -(get repeated sum until it becomes single digit and check if it is prime or not)
public:
    int DigitalRoot(int N){//get repeated sum until it becomes single digit
        if(N<=9) return N;
        
        return (N%9==0)?9:(N%9);
    }
    int digitisPrime(int n){
        for(int i=2;i*i<=n;i++){
            if(n%i==0) return 0;
        }
        return 1;
    }
    int digitalRoot(int N)
    {
        // Write Your Code here
        int ans=DigitalRoot(N);
        if(ans<=1) return 0;
        return digitisPrime(ans);
    }
//Nth fibonacci number
public:
    long long int nthFibonacci(long long int n){
        // code here
        int fib1=1,fib2=1,fib=0;
        if(n<=0) return 0;
        if(n==1||n==2) return 1;
        for(long long int i=3;i<=n;i++){
            fib=(fib1+fib2)%1000000007;
            fib2=fib1;
            fib1=fib;
        }
        return fib;
    }
//Tower of hanoi
public:
    // You need to complete this function

    // avoid space at the starting of the string in "move disk....."
    //long long int moves=1;
    void moves(int N,int from,int to,int aux){
        if(N<1) return;
        if(N==1) {
            cout<<"move disk "<<N<<" from rod "<<from<<" to rod "<<to<<"\n";
            return;
        }
        toh(N-1,from,aux,to);
        //move 1th from 1 to 3 ;
        cout<<"move disk "<<N<<" from rod "<<from<<" to rod "<<to<<"\n";
        toh(N-1,aux,to,from);
    }
    long long toh(int N, int from, int to, int aux) {
        // Your code here
        moves(N,from,to,aux);
        return pow(2,N)-1;
    }
//josephus problem
class Solution
{
    public:
    int josephus(int n, int k)
    {
       //Your code here
       if(n<=1) return 1;
       
       return (josephus(n-1,k)+k-1)%n+1;//adjustments as k%n +1 is treated as 1st in every call.and here ordering are from 1 to N
    }
};

// lucky numbers
bool myFun(int n, int x)
    {
        if(n%x == 0)
            return false;
        if(x > n)
            return true;
        return myFun(n-(n/x), x+1);    
    }
    bool isLucky(int n) {
        return myFun(n, 2);
    }
//Power of Numbers - given N,R(reverse of N) find N power R  (fast exponentiation)
 public:
    //You need to complete this fucntion
    
    long long power(int N,int R)
    {
       //Your code here
       long long int res=1,base=N;
       while(R>0){
           if(R&1){
           res=(res*base)%1000000007;
           }
           base=(base*base)%1000000007;
           R=R>>1;
       }
       return res;
        
    }
//power set using recursion -print in lexicographically order with duplicates also
	public:
	  vector<string> ans;
	  multimap<string,int> a;
	  void powerSet(string &s,int i,string curr=""){
	       if(i==s.length()){ 
	           //a[curr]++;
	           a.insert(pair<string,int>(curr,1));
	           return;
	       }
	       
	       powerSet(s,i+1,curr+s[i]);
	       powerSet(s,i+1,curr);
	   }
	  
		vector<string> AllPossibleStrings(string s){
		    // Code here
		    int i=0;
		    powerSet(s,i,"");
		    a.erase("");
		    for(auto itr=a.begin();itr!=a.end();itr++)
		       ans.push_back(itr->first);
		    return ans;
		}

//Possible words from phone digits
public:
    vector<string> ans;
    map<int,string> mp;
    map<string,int> res;
    void possible(int a[],int n,string curr,int i){
        if(i==n){
            res[curr]++;
            return;
        }
        int digit=a[i];
        int len=mp[digit].length();
        for(int j=0;j<len;j++){ //for this digit check its alphabet string and iterate over it by including one at a time and recursively calling for next digit's string and repeat till last digit in input array a is reached thus when i==n return.
        string temp=mp[digit];
        possible(a,n,curr+temp[j],i+1);
        
        }
    }
    //Function to find list of all words possible by pressing given numbers.
    vector<string> possibleWords(int a[], int N)
    {
        //Your code here
  //store mapping of digits with alphabets
   mp.insert({0,""});
   mp.insert(make_pair(1,""));
   mp.insert(make_pair(2,"abc"));
   mp.insert(make_pair(3,"def"));
   mp.insert(make_pair(4,"ghi"));
   mp.insert(make_pair(5,"jkl"));
   mp.insert(make_pair(6,"mno"));
   mp.insert(make_pair(7,"pqrs"));
   mp.insert(make_pair(8,"tuv"));
   mp.insert(make_pair(9,"wxyz"));
   
        possible(a,N,"",0);
        for(auto itr=res.begin();itr!=res.end();itr++)
           ans.push_back(itr->first);
        return ans;
    }



ARRAYS:
//Finding majority element(element appearing greater than N/2) 
//using moore's voting algo-O(n)
 int majorityElement(int arr[], int size)
    {        
        // your code here
        int major=arr[0],count=0;
        for(int i=0;i<size;i++){
            if(major==arr[i]){
                count++;
            }else count--;
            if(count==0){
                major=arr[i];
                count=1;
            } 
        }
        count=0;
        for(int i=0;i<size;i++){
            if(arr[i]==major)
             count++;
        }
        if(count>size/2)
         return major;
        else return -1;      
       
    }
//second max in array (but ensure largest should not be equal to second largest)
 int print2largest(int arr[], int arr_size)
    {
    	//code here.
    	int largest=arr[0],secondlargest=-1;
    	for(int i=1;i<arr_size;i++){
    	    if(arr[i]>largest){ secondlargest=largest;largest=arr[i];}
    	    else if(arr[i]>secondlargest &&arr[i]!=largest){secondlargest=arr[i];}
    	}
      return secondlargest;	
    }
//find max value of(a[i]-i)-(a[j]-j) such that i!=j
 int maxVal(int a[], int n) {
        int maxval=INT_MIN,minval=INT_MAX;
        for(int i=0;i<n;i++){
            if((a[i]-i)>maxval) maxval=(a[i]-i);
            if((a[i]-i)<minval) minval=(a[i]-i);
        }
     return maxval-minval;
    }
//reverse array in groups
public:
void reverse(vector<long long>& arr, int n,int i,int k){
    int low=i,high=min(i+k-1,n-1);
    while(low<high){
        swap(arr[low],arr[high]); 
        low++,high--;
    }
}
    //Function to reverse every sub-array group of size k.
    void reverseInGroups(vector<long long>& arr, int n, int k){
        // code here
        for(int i=0;i<n;i+=(k)){
            reverse(arr,n,i,k);
        }
    }
//Rotate array by d
 public:
    void reverseArr(int arr[], int n,int low,int high){
        while(low<high){
        swap(arr[low],arr[high]); 
        low++,high--;
      }
   }
    //Function to rotate an array by d elements in counter-clockwise direction. 
    void rotateArr(int arr[], int d, int n){
        // code here
        if(d>n){
            d=d-n;
        }
        reverseArr(arr,n,0,d-1);
        reverseArr(arr,n,d,(n-1));
        reverseArr(arr,n,0,n-1);
        
    }
//Rotate bits
/*Rotate left and right by d digits
Given an integer N and an integer D, rotate the binary representation of the integer N by D digits to the left as well as right and print the results in decimal values after each of the rotation.
Note: Integer N is stored using 16 bits. i.e. 12 will be stored as 0000.....001100.
*/
vector <int> rotate (int n, int d)
        {
            //code here.
            int l,r;
            d=d%16;
            l=((n<<d)|(n>>(16-d)))&0xFFFF;
            r=((n>>d)|(n<<(16-d)))&0xFFFF;
            return {l,r};
        }
//Maximum occurred integer-(given n ranges find max appearing element in the ranges given)
 public:
    // L and R are input array
    // maxx : maximum in R[]
    // n: size of array
    // arr[] : declared globally with size equal to maximum in L[] and R[]
    //Function to find the maximum occurred integer in all ranges.
    int maxOccured(int L[], int R[], int n, int maxx){
    
        // Your code here
        int arr[1000000];
        memset(arr,0,sizeof arr);
        for(int i=0;i<n;i++){
            arr[L[i]]++;//mark start of ith range as 1
            arr[R[i]+1]--;//mark end of ith range as -1;
        }
        int maxOccurrences=arr[0],maxAppearingNumber=0;
        for(int i=1;i<1000000;i++){//prefix sum to get max occuring value (no of ranges in which it appears)of all numbers from 0 to 100000 
            arr[i]=arr[i]+arr[i-1];
            if(maxOccurrences<arr[i]){
                maxOccurrences=arr[i];
                maxAppearingNumber=i;
            }
        }
        return maxAppearingNumber;
    }
//wave array
public:
    // arr: input array
    // n: size of array
    //Function to sort the array into a wave-like array.
    void convertToWave(vector<int>& arr, int n){
        
        // Your code here
        for(int i=1;i<n;i+=2){
            swap(arr[i],arr[i-1]);
        }
        
    }
//frequencies of limited range array elements (in o(1) aux space)
public:
  //Function to count the frequency of all elements from 1 to N in the array.
  void frequencyCount(vector<int>& arr,int n, int P)
  {
    int expectedPos, pos=0;
    while (pos<n)
    {
        expectedPos = arr[pos]-1;
        if (arr[pos] >0 && arr[pos]<=n && arr[expectedPos]>0)
        {
            arr[pos] = arr[expectedPos];
            arr[expectedPos] = -1;
        }
        else if (arr[pos] >0 && arr[pos]<=n)
        {
            arr[expectedPos]--;
            arr[pos++] = 0;
        }
        else
        {
            pos++;
        }
    }
    for (int i=0;i<n;i++)
    { if(arr[i]>0) arr[i]=0;
        arr[i]=abs(arr[i]);    
    } 
 }
// equilibrium point
 public:
    // Function to find equilibrium point in the array.
    // a: input array
    // n: size of array
    int equilibriumPoint(long long arr[], int n) {
    
        // Your code here
        
        for(int i=1;i<n;i++){
            arr[i]=arr[i]+arr[i-1]; 
       }
       for(int i=0;i<n;i++){
           if(i==0){
               if(arr[n-1]-arr[0]==0) return 1;
           }
           if(arr[i-1]==(arr[n-1]-arr[i-1]-(arr[i]-arr[i-1]))){
               return i+1;
           }
       }
       return -1;
    }
//Leaders in an array
 //Function to find the leaders in the array.
    public:
    vector<int> leaders(int a[], int n){
        // Code here
        int lastGreater=a[n-1];
        vector<int> v;
        v.push_back(a[n-1]);
        for(int i=n-2;i>=0;i--){
           if(a[i]>=lastGreater){ lastGreater=a[i]; v.push_back(a[i]);}
        }
        int l=0,r=v.size()-1;
        while(l<r){
            swap(v[l],v[r]);
            l++,r--;
        }
        return v;
    }
//smallest positive missing number -o(n) time & o(1) space
 public:
    //Function to find the smallest positive number missing from the array.
    int missingNumber(int arr[], int n) 
    { 
        // Your code here
       int find1=0;
       for(int i=0;i<n;i++){
           if(arr[i]==1){
               find1=1;
               break;
           }
       }
       if(find1==0) return 1;//as 1 is first missing no
       for(int i=0;i<n;i++){
           if(arr[i]<=0||arr[i]>n) arr[i]=1;
       }
       for(int i=0;i<n;i++){
           arr[(arr[i]-1)%n]+=n;
       }
       for(int i=0;i<n;i++){
           if(arr[i]<=n) return i+1;
       }
    return n+1;
    }
//Rearrange Array Alternately
public:
    // This function wants you to modify the given input
    // array and no need to return anything
    // arr: input array
    // n: size of array
    //Function to rearrange  the array elements alternately.
    void rearrange(long long *arr, int n) 
    { 
    	
    	// Your code here
    /*//when arr elements differ by 1
    int max_ele=arr[n-1],min_ele=arr[0],i=0;
    	while(i<n){
    	    if(i%2!=0){
    	     arr[i]=min_ele;
    	    i++;
    	    min_ele++;
    	    }
    	    else{
        	 arr[i]=max_ele;
        	 i++;
        	 max_ele--;
    	    }
    	}
    	*/ 
    	int maxindex=n-1,minindex=0,maxelement=arr[n-1]+1;
    	for(int i=0;i<n;i++){
    	    if(i%2==0){
    	    arr[i]=arr[i]+((arr[maxindex]%maxelement)*maxelement);
    	    maxindex--;
    	    }else{
    	        arr[i]=arr[i]+((arr[minindex]%maxelement)*maxelement);
    	        minindex++;
    	    }
    	}
    	for(int i=0;i<n;i++){
    	    arr[i]=arr[i]/maxelement;
    	}
    }
//Rearrange an array with o(1) extra space
public:
    // arr: input array
    // n: size of array
    //Function to rearrange an array so that arr[i] becomes arr[arr[i]]
    //with O(1) extra space.
    void arrange(long long arr[], int n) {
        // Your code here
        for(int i=0;i<n;i++){
            arr[i]+=(arr[arr[i]]%n)*n;
        }
        for(int i=0;i<n;i++){
            arr[i]=arr[i]/n;
        }
    }
//Maximum Index
public:
        
    // A[]: input array
    // N: size of array
    // Function to find the maximum index difference.
    int maxIndexDiff(int arr[], int N) 
    { 
        // Your code here
        int LMin[N],RMax[N];
        LMin[0]=arr[0];
        for(int i=1;i<N;i++){
            LMin[i]=min(arr[i],LMin[i-1]);
        }
        RMax[N-1]=arr[N-1];
        for(int i=N-2;i>=0;i--){
            RMax[i]=max(arr[i],RMax[i+1]);
        }
        int i=0,j=0,maxDiff=-1;
        while(i<N&&j<N){
            if(LMin[i]<=RMax[j]){
                maxDiff=max(maxDiff,j-i);
                j++;
            }else i++;
        }
        return maxDiff;
    }
//// Function to find the trapped water between the blocks.
    public:
    long long trappingWater(int arr[], int n){
        // code here
    int lmax[n],rmax[n];
        long long water=0,maxstorableht=0;
        lmax[0]=arr[0];
        for(int i=1;i<n;i++){
           lmax[i]=max(lmax[i-1],arr[i]);
        }
        rmax[n-1]=arr[n-1];
        for(int i=n-2;i>=0;i--){
            rmax[i]=max(rmax[i+1],arr[i]);
        }
        for(int i=1;i<n-1;i++){
            maxstorableht=min(lmax[i],rmax[i]);
            if(maxstorableht-arr[i]>0)
              water+=maxstorableht-arr[i];
        }
        return water;
    }
//public:
//Function to find the days of buying and selling stock for max profit.
vector<vector<int> > stockBuySell(vector<int> price, int n){
vector<vector<int>> ans;
        vector<int> v;
        int i = 0;
        while (i < n - 1) {
 
        // Find Local Minima
        // Note that the limit is (n-2) as we are
        // comparing present element to the next element
        while ((i < n - 1) && (price[i + 1] <= price[i]))
            i++;
 
        // If we reached the end, break
        // as no further solution possible
        if (i == n - 1)
            break;
 
        // Store the index of minima
        int buy = i++;
 
        // Find Local Maxima
        // Note that the limit is (n-1) as we are
        // comparing to previous element
        while ((i < n) && (price[i] >= price[i - 1]))
            i++;
 
        // Store the index of maxima
        int sell = i - 1;
        v.clear();
        v.push_back(buy);
        v.push_back(sell);
        ans.push_back(v);
        //if(i==n-1)break;
       }
       return ans;
    }
//check if array is sorted or not
public:
    bool arraySortedOrNot(int arr[], int n) {
        // code here
       for(int i=n-1;i>0;i--){
           if(arr[i]-arr[i-1]<0){      
             return false;
           }
        }
        return true;
    }
//check if array is rotated or not
public:	
	int findKRotation(int arr[], int n) {
	    // code here
	    int count=0;
	   for(int i=n-1;i>0;i--){
	       if(arr[i]-arr[i-1]<0) count=i;
	    }
	    return count;
	}
//kadane's algo -maxsubarraysum
public:
    // arr: input array
    // n: size of array
    //Function to find the sum of contiguous subarray with maximum sum.
    long long maxSubarraySum(int arr[], int n){
        
        // Your code here
        int maxsum=INT_MIN,currsum=0;
        for(int i=0;i<n;i++){
            currsum+=arr[i];
            maxsum=max(maxsum,currsum);
            if(currsum<0) currsum=0;
        }
        return maxsum;
        
    }
//longest subarray with atmost k even elements (use sliding window concept)
int main()
 {
	//code
	int t,n,k;
	cin>>t;
	while(t--){
	    cin>>n>>k;
	    int arr[n];
	    for(int i=0;i<n;i++){
	      cin>>arr[i];
	      if(arr[i]%2==0)
	         arr[i]=1;
	      else
	         arr[i]=0;
	    }
	    int sum=0,count=0,maxcount=0;
	    for(int i=0;i<n;i++){
	        if((sum+arr[i])<=k){
	            sum+=arr[i];
	            count++;
	        }else if(sum!=0){
	            sum=sum-arr[i-count]+arr[i];
	        }
	        maxcount=max(count,maxcount);
	    }
	    cout<<maxcount<<'\n';
	    
	}
	return 0;
}
//max circular subarray sum
 public:
    // arr: input array
    // num: size of array
    //function for standard kadane:
    int normalSubarraySum(int arr[],int n){
        int maxSum=INT_MIN,currSum=0;
        for(int i=0;i<n;i++){
            currSum+=arr[i];
            maxSum=max(currSum,maxSum);
            if(currSum<0) currSum=0;
        }
        return maxSum;
    }
//Function to find maximum circular subarray sum.
    int circularSubarraySum(int arr[], int n){
        
        // your code here
        int normal_sum=normalSubarraySum(arr,n);//non-wrap up sum or std sum
        if(normal_sum<0){
            return normal_sum;
        }
        int arr_sum=0;
        for(int i=0;i<n;i++){
            arr_sum+=arr[i];//to get total sum
            arr[i]=-arr[i];//to get minimum sum(middle elements sum) by passing this modified array to std kadane for max minimum sum.
        }
        int circular_sum=arr_sum+normalSubarraySum(arr,n);//wrap up sum(max circular sum)=total arr sum-middle elements sum
        return max(circular_sum,normal_sum);//max of( wrap up sum,non-wrap up sum or std sum)
    }

//Smallest subarray with sum greater than x
int smallestSubWithSum(int arr[], int n, int x)
    {
        // Your code goes here
        long long int prefix=0,start=0,ans=INT_MAX,end=0;
        if(n==1){
            if(x<arr[0]) return 1;
            else return 0;
        }
        while(end<n){//sliding window
            prefix+=arr[end];
            while(prefix>x&&start<=end){//window shrink
                ans=min(ans,end-start+1);
                prefix-=arr[start];
                start++;
            }
            end++;
        }
        return ans;
    }
//First negative integer in every window of size k
vector<long long> printFirstNegativeInteger(long long int arr[],long long int n, long long int k) {
        map<int,int> h;
        long long int i=0,start=0,res=0;
        vector<long long int> ans;
        for(i=0;i<k;i++){
            if(arr[i]<0) h[i]=arr[i];
        }
        auto it=h.begin();
        if(h.size()>0)it=h.begin();
        else it=h.end();
        if(it!=h.end()&&(*it).second<0) res=(*it).second;
        else res=0;
        ans.push_back(res);
        while(i<(n)){
            if(arr[i]<0) h[i]=arr[i];
            if(arr[start]<0) {h.erase(start);}
            i++;
            start++;
            if(h.size()>0)it=h.begin();
            else it=h.end();
            if(it!=h.end()&&((*it).second<0)) res=(*it).second;
            else res=0;
            ans.push_back(res);
        }
        return ans;
 }
//Maximize sum after K negations
public:
    static bool cmp(long long int a,long long int b){
        return a<b;
    }
    long long int maximizeSum(long long int arr[], int n, int k)
    {
        // Your code goes here
        sort(arr,arr+n,cmp);
        int i=0;
        long long int res=0;
        long long int mini=INT_MAX;
        for(i=0;i<n;i++){
            if(arr[i]<0&&k>0) {arr[i]=(-1)*arr[i];k--;}
            res+=arr[i];
            mini=min(mini,arr[i]);
        }
        if(k%2==0) return res;
        else return res-=2*mini;
    }
//Max sum path in two arrays
 int max_path_sum(int A[], int B[], int m, int n)
    {
        //Your code here
       int i=0,j=0,s1=0,s2=0,res=0;
       while(i<m&&j<n){
           if(A[i]<B[j]){
               s1+=A[i];
               i++;
           }else if(A[i]>B[j]){
               s2+=B[j];
               j++;
           }else{
               res+=max(s1,s2)+A[i];
               s1=0;s2=0;
               i++;j++;
           }
       }
       while(i<m) s1+=A[i++];
       while(j<n) s2+=B[j++];
       res+=max(s1,s2);
       return res;
    }
//Minimize the Heights II
int getMinDiff(int arr[], int n, int k)
{
    sort(arr, arr + n);

    // Maximum possible height difference
    int ans = arr[n - 1] - arr[0];

    int tempmin, tempmax;
    tempmin = arr[0];
    tempmax = arr[n - 1];

    for (int i = 1; i < n; i++) {

        // If on subtracting k we got
        // negative then continue
        if (arr[i] - k < 0)
            continue;

        // Minimum element when we
        // add k to whole array
        tempmin = min(arr[0] + k, arr[i] - k);

        // Maximum element when we
        // subtract k from whole array
        tempmax = max(arr[i - 1] + k, arr[n - 1] - k);

        ans = min(ans, tempmax - tempmin);
    }
    return ans;
}

SEARCHING:
//search an element in an array  - linear search
  public:
    // Function to search x in arr
    // arr: input array
    // X: element to be searched for
    int search(int arr[], int N, int X)
    {
       for(int i=0;i<N;i++)
         if(arr[i]==X) return i;
         
       return -1;
    }
//Searching an element in a sorted array
 public:
    // Function to find element in sorted array
    // arr: input array
    // N: size of array
    // K: element to be searche
    int searchInSorted(int arr[], int N, int K) 
    { 
    
       // Your code here
       return (binary_search(arr,arr+N,K)==1)?1:-1;
       
    }
//Find the element that appears once in sorted array
int findOnce(int arr[], int n)
    {
        //code here.
        if(n==1) return arr[0];
        if(n>1&&arr[0]!=arr[1]) return arr[0];
        if(n>1&&arr[n-2]!=arr[n-1]) return arr[n-1];
        int l=0,h=n-1,mid;
        while(l<=h){
            mid=l+((h-l)/2);
            if(((arr[mid]!=arr[mid-1])&&(arr[mid]!=arr[mid+1]))) return arr[mid];
            else if(arr[mid]==arr[mid+1]){
                if(mid%2!=0){//odd no of elements in right half
                    h=mid-1;
                }else l=mid+1; //even
            }else if(arr[mid]==arr[mid-1]){
                 if(mid%2==0){//even no of elements in left
                    h=mid-1;
                }else l=mid+1; //odd
            }
        }
    }
//Search in a Rotated Array
int search(int A[], int l, int h, int key){
        // l: The starting index
        // h: The ending index, you have to search the key in this range
        
        //complete the function here
        while(l<h){
            if(A[l]==key) return l;
            else l++;
            if(A[h]==key) return h;
            else h--;
        }
        return -1;
    }
//Count the zeroes
int countZeroes(int arr[], int n) {
        // code here
    int left = 0;
        int right = n-1;
        
        while(left <= right){
            int mid = left + (right - left)/2;
            
            if(arr[mid] == 0){
                if(mid == 0 || arr[mid-1] != arr[mid] )
                    return n-mid;
                else 
                    right = mid - 1;
            }
            else 
                left = mid + 1;
        }
        return 0;
    }
//Square root of a number
public:
    long long int floorSqrt(long long int x) 
    {
        // Your code goes here 
        long long int last,i=1,mid,low=1,high;
       while(i<x){
                last=i;
                if(last*last==x) return last;
                i=i*2;
            
        }
        high=last;
        while(low<=high){
            mid=low+(high-low)/2;
            if(mid*mid==x) return mid;
            else if(mid*mid>x) high=mid-1;
            else {last=mid;low=mid+1;}
        }
      return last;
    
    }
//left most and right most index - first and last occurrence of x in v
 public:
    pair<long,long> indexes(vector<long long> v, long long x)
    {
        // code here
        bool find=binary_search(v.begin(),v.end(),x);
        if(find==true){
        auto last=upper_bound(v.begin(),v.end(),x);
        auto first=lower_bound(v.begin(),v.end(),x);
        return make_pair(first-v.begin(),last-v.begin()-1);
        }
        return make_pair(-1,-1);
    }
//Floor in a sorted array
 public:
    // Function to find floor of x
    // n: size of vector
    // x: element whose floor is to find
    int findFloor(vector<long long> v, long long n, long long x){
        
        // Your code here
        return upper_bound(v.begin(),v.end(),x)-v.begin()-1;
        
    }
//Minimum Number in a sorted rotated array  (distinct and without duplicates)
public:
    //Function to find the minimum element in sorted and rotated array.
    int minNumber(int arr[], int low, int high)
    {
        // Your code here
        int mid,len=high-low+1;
        while(low<=high){
            mid=low+(high-low)/2;
            if(mid==0) return arr[mid];
            if(arr[mid]>arr[mid+1]) return arr[mid+1];
            if(arr[mid-1]>arr[mid]) return arr[mid];
            else if(arr[mid]>arr[high]) low=mid+1;
            else high=mid-1;
        }
        
        
    }
//K-th element of two sorted Arrays
int kthElement(int arr1[], int arr2[], int n, int m, int k)
    {
        int i=0,j=0,res;
        while(i<n&&j<m&&k>0){
            if(arr1[i]<=arr2[j]) k--,res=arr1[i],i++;
            else if(arr1[i]>arr2[j]) k--,res=arr2[j],j++;
        }
        if(i<n&&k>0){
            res=arr1[i+k-1];
        }
        if(j<m&&k>0){
            res=arr2[j+k-1];
        }
        return res;
    }
// with duplicates
// Function to find minimum element
int findMin(int arr[], int low, int high)
{
    while(low < high)
    {
        int mid = low + (high - low)/2;
        if (arr[mid] == arr[high])
            high--;
        else if(arr[mid] > arr[high])
            low = mid + 1;
        else
            high = mid;
    }
    return arr[high];
}
//Two Repeated Elements
public:
    //Function to find two repeated elements. num are from 1 to N range and total N+2
    vector<int> twoRepeated (int arr[], int n) {
        // Your code here
       vector<int> res;
       for(int i=0;i<n+2;i++){
           if((arr[(arr[i]%(n+1))]/(n+1))<1){
               arr[(arr[i]%(n+1))]+=(n+1);
           }else res.push_back(arr[i]%(n+1));
       }
       return res;
    }
//Roof Top
 public:
    //Function to find maximum number of consecutive steps 
    //to gain an increase in altitude with each step.
    int maxStep(int arr[], int n)
    {
       //Your code here
       int steps=0,msteps=0;
       for(int i=1;i<n;i++){
           if(arr[i]>arr[i-1]){
               steps+=1;
               msteps=max(msteps,steps);
           }else{steps=0;}
       }
       return msteps;
    }
//Maximum Water Between Two Buildings
  public:
    int maxArea(int h[],int n){
        int ht=0,l=0,area=0,i=0,j=n-1,maxarea=0;
        //we move towards height which is greater for max area using 2 pointers
        while(i<j){
                ht=min(h[i],h[j]);
                l=(j-i-1);
                area=ht*l;
                maxarea=max(maxarea,area);
                if(h[i]<h[j]){
                    i++; 
                }else if(h[j]<h[i]){
                    j--;
                }else i++,j--;
            }
      return maxarea;
    }
    int maxCandy(int h[], int n) 
    { 
        // Your code goes here
            return maxArea(h,n);
       
    } 
//count more than n/k occurrences  -o(n) extra space
 //Function to find all elements in array that appear more than n/k times.
    int countOccurence(int arr[], int n, int k) {
        // Your code here
        unordered_map<int,int> mp;
        int count=0;
        for(int i=0;i<n;i++){
            mp[arr[i]]++;
        }
        if(k<1) return mp.size();
        for(auto it=mp.begin();it!=mp.end();it++){
            if(it->second>(n/k)) count++;
        }
        return count;
    }
   
//
public:
    bool isPossible(int arr[],int n,int m,int min_pages){
        int sum=0,noofstud=1;
        for(int i=0;i<n;i++){
            if(arr[i]>min_pages) return false;
            if(sum+arr[i]>min_pages){
                noofstud++;
                sum=arr[i];
                if(noofstud>m) return false;
            }else sum+=arr[i];
        }
        return true;
    }
    //Function to find minimum number of pages.
    int findPages(int arr[], int n, int m) 
    {
        //code here
        long long sum=0;
        if(n<m) return -1;
        int l,r,res=0;
        for(int i=0;i<n;i++){
            sum+=arr[i];
            mxpages=max(mxpages,arr[i]);
        }
        l=mxpages,r=sum;
        while(l<=r){
            int mid=(r+l)/2;
            if(isPossible(arr,n,m,mid)){
                res=mid;
                r=mid-1;
            }else l=mid+1;
        }
        return res;
    } 
//subarray with given sum
public:
    //Function to find a continuous sub-array which adds up to a given number.
    vector<int> subarraySum(int arr[], int n, long long sum)
    {
        // Your code here
        vector<int> ans;
       long long int curr_sum=arr[0],l=0,r=0;
        while(r<n){
            if(curr_sum==sum) {ans.push_back(l+1);ans.push_back(r+1); return ans;} //since positions
            else if(curr_sum>sum) {curr_sum=curr_sum-arr[l];l++;}
            else {r++;curr_sum=curr_sum+arr[r];}
        }
        ans.push_back(-1);
        return ans;
    }
//median of two sorted arrays of different sizes
public:
    double Median(vector<int>& A,vector<int>& B){
        int start=0,end=A.size(),merged_mid=(A.size()+B.size()+1)/2;
        while(start<=end){
            int mid=(start+end)/2;
            int leftAsize=mid,leftBsize=merged_mid-mid;
            int leftA=(leftAsize>0)?A[leftAsize-1]:INT_MIN;
            int leftB=(leftBsize>0)?B[leftBsize-1]:INT_MIN;
            int rightA=(leftAsize<A.size())?A[leftAsize]:INT_MAX;
            int rightB=(leftBsize<B.size())?B[leftBsize]:INT_MAX;
            if(leftA<=rightB&&leftB<=rightA){
                if((A.size()+B.size())%2==0){
                    return (max(leftA,leftB)+min(rightA,rightB))/2.0;
                }
                return max(leftA,leftB);
            }
            else if(leftA>rightB){
                end=mid-1;
            }else start=mid+1;
            
        }
        return 0.0;
        
    }
    double MedianOfArrays(vector<int>& array1, vector<int>& array2)
    {
        // Your code goes here
        int n=array1.size(),m=array2.size();
        if(n>m) return Median(array2,array1);
        else return Median(array1,array2);
    
    }

SORTING:

//Bubble sort
 public:
    //Function to sort the array using bubble sort algorithm.
    
    void bubbleSort(int arr[], int n)
    {
        // Your code here  
        bool flag=false;
        for(int pass=0;pass<n-1;pass++){//n-1 passes reqd
            for(int j=0;j<n-i-1;j++){//i elements are sorted in right part thus check for only n-i-1 left elements.
                if(arr[j+1]<arr[j]){
                 arr[j]=arr[j]+arr[j+1];
                 arr[j+1]=arr[j]-arr[j+1];
                 arr[j]=arr[j]-arr[j+1];
                 flag=true;
                }
            }
            if(flag==false) return;
        }
        return;
    }
//
 public:
    //Function to sort the array using insertion sort algorithm.
    void insertionSort(int arr[], int n)
    {
        //code here
        int j=0,key;
        for(int i=1;i<n;i++){//i is from 1 because we assume 0th is already inserted in empty array.
            j=i-1;//last element in sorted arr.
            key=arr[i];//store ith ele as it will be overwritten while creating space
            while(j>=0&&j<n&&arr[j]>key){//shift and create space if last>key
                arr[j+1]=arr[j];
                  j--;
                
            }
            arr[j+1]=key;//j will be last element in sorted arr and so place this key in space created at j+1 th.
        }
        return;
    }
//Quick sort
 //Function to sort an array using quick sort algorithm.
   
    void quickSort(int arr[], int low, int high)
    {
        // code here
        
        if(low<high){//using lomuto partition
            int pivotIdx=partition(arr,low,high);
            quickSort(arr,low,pivotIdx-1);//in horae's partition it is quickSort(arr,low,pivotIdx); rest same;
            quickSort(arr,pivotIdx+1,high);
        }
        return;
        
    }
    
    public://lomuto partition
    int partition (int arr[], int low, int high)
    {
       // Your code here
       int pivot=arr[high],j=low-1;
       for(int i=low;i<=high-1;i++){
           if(arr[i]<=pivot){
               j++;
               swap(arr[j],arr[i]);
           }
       }
       swap(arr[j+1],arr[high]);
       return j+1;
    }
    int hoare(int arr[],int low,int high){
        int pivot=arr[low],i=low,j=high;
        while(1){
             do{i++;}while(arr[i]<pivot);
             do{j--;}while(arr[j]>pivot);
             if(i>=j) return j;
             swap(arr[i],arr[j]);   
         }
    }
//Binary Array Sorting
 public:
    
    // A[]: input array
    // N: input array
     
    //Function to sort the binary array.
    void binSort(int arr[], int n)
    {
       //Your code here
       
       /**************
        * No need to print the array
        * ************/
        int j=n-1;
       for(int i=0;i<n;i++){
           while(i<=j){
           if(arr[i]==1){swap(arr[i],arr[j]);j--;}
           else break;
           }
       }
    }
// count Inversions -o(nlogn) time and o(n) space
public:
    // arr[]: Input Array
    // N : Size of the Array arr[]
    long long int countAndMerge(long long int arr[],long long int low,long long int mid,long long int high){
        long long int n1=mid-low+1,n2=high-mid;
        long long int l[n1],r[n2];
        for(int i=0;i<n1;i++){
            l[i]=arr[low+i];
        }
        for(int i=0;i<n2;i++){
            r[i]=arr[mid+1+i];
        }
        long long int i=0,j=0,k=low;
        long long int res=0;
        while(i<n1&&j<n2){
            if(l[i]<=r[j]){arr[k]=l[i];k++,i++;}
            else{arr[k]=r[j];k++,j++;res+=(n1-i);//count pairs of inversion}
        }
        while(i<n1){arr[k]=l[i];i++,k++;}
        while(j<n2){arr[k]=r[j];j++,k++;}
        return res;
    }
    long long int invCount(long long int arr[],long long int low,long long int high){
        long long int inv_count=0;
        if(low<high){
            long long int mid=low+(high-low)/2;
            inv_count+=invCount(arr,low,mid);
            inv_count+=invCount(arr,mid+1,high);
            inv_count+=countAndMerge(arr,low,mid,high);
        }
        return inv_count;
    }
    // Function to count inversions in the array.
    long long int inversionCount(long long arr[], long long N)
    {        // Your Code Here
        return invCount(arr,0,N-1);        
    }
//

public:
    //arr1,arr2 : the arrays
    // n, m: size of arrays
    //Function to return a list containing the union of the two arrays. 
    vector<int> findUnion(int arr1[], int arr2[], int n, int m)
    {
        //Your code here
        //return vector with correct order of elements
        int i=0,j=0,k=0;
        vector<int> unionArr;
        while(i<n&&j<m){
            if(i>0&&arr1[i]==arr1[i-1]){ i++;continue;}
            if(j>0&&arr2[j]==arr2[j-1]){ j++; continue;}
            if(arr1[i]<arr2[j]){
             unionArr.push_back(arr1[i]);i++;
            }else if(arr1[i]>arr2[j]){
                 unionArr.push_back(arr2[j]);j++; 
            }else{unionArr.push_back(arr1[i]); i++,j++;}
        }
        while(i<n){            
          if(arr1[i]!=arr1[i-1]){ unionArr.push_back(arr1[i]);i++;}
          else i++;         
        }
        while(j<m){             
          if(arr2[j]!=arr2[j-1]){ unionArr.push_back(arr2[j]);j++;}
          else j++;
        }        
        return unionArr;
    }
//Intersection of two unsorted arrays
public:
    // Function to return the count of the number of elements in
    // the intersection of two arrays.
    int NumberofElementsInIntersection(int a[], int b[], int n, int m) {
        // Your code goes here
        unordered_set<int> hash;
        int low=n>m?m:n,max=n<m?m:n;
        int *arr1,*arr2;
        int count=0;
        if(low==n){arr1=a,arr2=b;}
        else{arr1=b,arr2=a;}
        for(int i=0;i<low;i++){
            hash.insert(arr1[i]);
        }
        for(int i=0;i<max;i++){
            if(hash.find(arr2[i])!=hash.end()){count++; hash.erase(arr2[i]);}
            
        }
        return count;
    }
//count the number of possible triangles
 public:
    //Function to count the number of possible triangles.
    int findNumberOfTriangles(int arr[], int n)
    {
        // code here
        int count=0;
        sort(arr,arr+n);
        for(int i=n-1;i>=1;i--){
            int l=0,r=i-1;
            while(l<r){
                if(arr[l]+arr[r]>arr[i]&&arr[l]+arr[i]>arr[i]&&arr[i]+arr[r]>arr[l]){
                count+=r-l;r--;
                }else l++;
            }
        }
        return count;
    }
//find triplets with zero sum -o(n2) time and o(1) space
public:
    //Function to find triplets with zero sum.
    bool findTriplets(int arr[], int n)
    { 
        //Your code here
        int count=0;
        sort(arr,arr+n);
        for(int i=n-1;i>=1;i--){
            int l=0,r=i-1;
            while(l<r){
                if(arr[i]+arr[l]+arr[r]==0){count+=1;l++;r--;return count //as we just need atleast 1 such triplet here otherwise sum all such pairs if asked;}
                else if(arr[i]+arr[l]+arr[r]<0) l++;
                else r--;
            }
        } 
        return count;
    }
//Three way partitioning    //USE DNF concept
public: 
    //Function to partition the array around the range such 
    //that array is divided into three parts.
    void threeWayPartition(vector<int>& arr,int a, int b)
    {
        // code here 
        int h=arr.size()-1,l=0,i=0; 
        while(i<=h){
            if(arr[i]<a&&arr[i]<b){swap(arr[i],arr[l]);l++;i++;}
            else if (arr[i]>b){swap(arr[h],arr[i]);h--;}
            else i++;
        }
    }

//Counting Sort
public:
    //Function to arrange all letters of a string in lexicographical 
    //order using Counting Sort.
    int charArr[26]={0};
    string countSort(string arr){
        // code here
        for(int i=0;i<arr.length();i++){
            charArr[abs('a'-arr[i])]+=1;
        }
        string s="";
        for(int i=0;i<26;i++){
            while(charArr[i]>=1){s.push_back('a'+i);charArr[i]+=-1;}
        }
        return s;
    }
// Sort an array of 0s,1s and 2s - DNF
public:
    void sort012(int arr[], int n)
    {
        // coode here 
        int h=n-1,l=0,i=0; 
        while(i<=h){
            if(arr[i]==0){swap(arr[i],arr[l]);l++;i++;}
            else if (arr[i]==2){swap(arr[h],arr[i]);h--;}
            else i++;//if arr[i]==1
        }
    }
//Sort by Absolute Difference
public:    
    // A[]: input array
    // N: size of array
    static bool mycomparator(pair<int,pair<int,int>> a ,pair<int,pair<int,int>> b){
        if(a.first!=b.first){
            return a.first<b.first;
        }else{
            return a.second.first<b.second.first;
        }
    }
    //Function to sort the array according to difference with given number.
    void sortABS(int arr[],int n, int k)
    {
       //Your code here
      /* //METHOD-1 using maps
       multimap<int,int> m;
       for(int i=0;i<n;i++){
           m.insert(make_pair(abs(arr[i]-k),arr[i]));
       }
       int i=0;
       for(auto it=m.begin();it!=m.end();it++){
           arr[i]=(*it).second;i++;
       }
       */
      //METHOD -2 using sort + vector of pairs 
       vector<pair<int,pair<int,int>>> v;
       for(int i=0;i<n;i++)
         v.push_back(make_pair(abs(arr[i]-k),make_pair(i,arr[i])));
       sort(v.begin(),v.end(),mycomparator);
       int i=0;
       for(auto it=v.begin();it!=v.end();it++){
           arr[i]=(*it).second.second;i++;
       }
    }
//Minimum difference pair  -we need to find mindiff b/w adj element pair  -o(nlogn) time
public:
   	int  minimum_difference(vector<int>nums){
   	    // Code here
   	  sort(nums.begin(),nums.end());
   	  int l=0,minDiff=INT_MAX,currDiff=0;
   	  while(l<nums.size()-1){
   	      currDiff=nums[l+1]-nums[l];
   	      if(currDiff<minDiff) minDiff=currDiff;
   	      l++;
   	  }
   	  return minDiff;
   	}
//Kth smallest element  --using quickselect algo-O(N) on avg and o(n2) in worst case time.
public:
    // arr : given array
    // l : starting index of the array i.e 0
    // r : ending index of the array i.e size-1
    int partition(int arr[],int l,int r){
       int pivot=arr[r],s=l,i;
        for(i=l;i<=r-1;i++){
            if(arr[i]<=pivot){
                swap(arr[i],arr[s]);
                s++;
            }
        }
        swap(arr[r],arr[s]);
        return s;
        
    }
    // k : find kth smallest element and return using this function
    int kthSmallest(int arr[], int l, int r, int k) {
        //code here
       
        while(l<=r){
            int p1=rand()%(r-l+1); //without this RANDOM PIVOT SELECTION TLE happens
            swap(arr[r],arr[l+p1]);
            int pivotIdx=partition(arr,l,r);
            if(pivotIdx==(k-1)) return arr[pivotIdx];
            else if(pivotIdx>(k-1)){ r=pivotIdx-1;}
            else {l=pivotIdx+1;}
        }
        return -1;
        
        /*
        // If k is smaller than number of elements in array
    if (k > 0 && k <= r - l + 1) {
        // Partition the array around last element and get
        // position of pivot element in sorted array
        int pos = partition(arr, l, r);
 
        // If position is same as k
        if (pos == k - 1)
            return arr[pos];
        if (pos > k - 1) // If position is more, recur for left subarray
            return kthSmallest(arr, l, pos - 1, k);
 
        // Else recur for right subarray
        return kthSmallest(arr, pos + 1, r, k - pos + l - 1);
    }
 
    // If k is more than number of elements in array
    return INT_MAX;
    */
    }
//Number of Pairs  -x^y>y^x
public:
    
    // X[], Y[]: input arrau
    // M, N: size of arrays X[] and Y[] respectively
   long long int count(int X[],int M,int Y[],int N,int NoOfY[],int x){
        if(x==0) return 0;
        if(x==1) return NoOfY[0];
        long long int ans=0;
        auto idx=upper_bound(Y,Y+N,x)-Y;
        ans=(N-idx);
        ans+=(NoOfY[0]+NoOfY[1]);
        if(x==2) return ans-=(NoOfY[3]+NoOfY[4]);
        if(x==3) return ans+=(NoOfY[2]);
        return ans;
    }
    //Function to count number of pairs such that x^y is greater than y^x.
    long long countPairs(int X[], int Y[], int M, int N)
    {
       //Your code here
      long long int ans=0;
      int NoOfY[5]={0};
      for(int i=0;i<N;i++){
          if(Y[i]<5){
              NoOfY[Y[i]]++;
          }
      }
      sort(Y,Y+N);
      for(int i=0;i<M;i++){
          ans=ans+count(X,M,Y,N,NoOfY,X[i]);
      }
      return ans;
    }
//Merge Sort
 void swap(int arr[],int i,int j){
        int t=*(arr+i);
        *(arr+i)=*(arr+j);
        *(arr+j)=t;
    }
    void merge(int arr[], int l, int m, int r)
    {
         // Your code here
         int n1=m-l+1,n2=r-m;
         int a[n1+n2],i=l,j=m+1,k=0;
         while(i<=m&&j<=r&&k<(n1+n2)){
             if(arr[i]<=arr[j]) a[k]=arr[i],i++;
             else a[k]=arr[j],j++;
             k++;
         }
         while(i<=m){
             a[k]=arr[i];
             i++;
             k++;
         }
         while(j<=r){
             a[k]=arr[j];
             j++;
             k++;
         }
         k=0;
         for(int x=l;x<=r;x++){
             arr[x]=a[k++];
         }
    }
    public:
    void mergeSort(int arr[], int l, int r)
    {
        //code here
        if(l<r){
            int mid=l+(r-l)/2;
            mergeSort(arr,l,mid);
            mergeSort(arr,mid+1,r);
            merge(arr,l,mid,r);
        }
    }
//Merge without extra space  -gap method.
 //Function to merge the arrays.
        void merge(long long arr1[], long long arr2[], int n, int m) 
        { 
            // code here
            int gap=ceil((float)(n+m)/2);
            int ptr1,ptr2;
            while(gap>0){
                ptr1=0,ptr2=gap;
                while(ptr2<(n+m)){
                    if(ptr1<n&&ptr2<n&&arr1[ptr1]>arr1[ptr2]){ swap(arr1[ptr1],arr1[ptr2]);}
                    else if(ptr1>(n-1)&&ptr1<(n+m)&&ptr2>(n-1)&&ptr2<(n+m)&&arr2[ptr1-n]>arr2[ptr2-n]){swap(arr2[ptr1-n],arr2[ptr2-n]);}
                    else if(ptr1<n&&ptr2>(n-1)&&ptr2<(n+m)&&arr1[ptr1]>arr2[ptr2-n]){swap(arr1[ptr1],arr2[ptr2-n]);}
                    ptr1++,ptr2++;
                }
                if(gap==1) gap=0;
                else gap=ceil((float)gap/2);
            }
        } 
 
//Nearly sorted 
public:
    //Function to return the sorted array.
    vector <int> nearlySorted(int arr[], int n, int k){
        // Your code here
        vector<int> res;
        int size=(n==k)?k:(k+1);
        priority_queue<int,vector<int>,greater<int>> heap(arr,arr+size);
      
     for(int i=size;i<n;i++){
      res.push_back(heap.top());
      heap.pop();  
      heap.push(arr[i]);
      
      }
      while(heap.empty()==false){
      res.push_back(heap.top());
       heap.pop();
       
      }
      return res;
    }

//Minimum platforms
 public:
    //Function to find the minimum number of platforms required at the
    //railway station such that no train waits.
    int findPlatform(int arr[], int dep[], int n)
    {
    	// Your code here
    	/*//method-1 using heap -o(nlogn)time and o(n)space
    	vector<pair<int,int>> v(n);
    	for(int i=0;i<n;i++){
    	    v[i]=make_pair(arr[i],dep[i]);
    	}
    	sort(v.begin(),v.end());
    	int res=1;
    	priority_queue<int,vector<int>,greater<int>> heap;
    	heap.push(v[0].second);
    	for(int i=1;i<n;i++){
    	    if(heap.top()>=v[i].first){
    	        heap.push(v[i].second);
    	        res++;
    	    }else heap.pop();
    	    heap.push(v[i].second);
    	}
    	return res;
    	*/
    	//method-2 o(nlogn)time and o(1) space
    	sort(arr,arr+n);
    	sort(dep,dep+n);
    	int arrival=1,departure=0;
    	int count=1,res=1;
    	while(arrival<n&&departure<n){
    	    if(arr[arrival]<=dep[departure]){count++;res=max(res,count);arrival++;}
    	    else{count--;departure++;}
    	}
    	return res;
    }
//Overlapping Intervals
static bool comp(vector<int> a,vector<int> b){
        if(a[0]==b[0]){return a[1]<b[1];}
        else if(a[0]>b[0]) return false;
        else if(a[0]<b[0]) return true;
    }
    vector<vector<int>> overlappedInterval(vector<vector<int>>& intervals) {
         // Code here
         vector<vector<int>> ans;
         sort(intervals.begin(),intervals.end());
         int currStart=intervals[0][0],currEnd=intervals[0][1];
         int newStart,newEnd;
         for(int i=1;i<intervals.size();i++){
             newStart=intervals[i][0];
             newEnd=intervals[i][1];
             if(newStart<=currEnd){//overlapped
                 currEnd=max(currEnd,newEnd);
             }else{
                 ans.push_back({currStart,currEnd});
                 currStart=newStart;
                 currEnd=newEnd;
             }
         }
         ans.push_back({currStart,currEnd});
         return ans;
    }

MATRIX:
//Addition of two square matrices
 void Addition(vector<vector<int> >& matrixA, vector<vector<int>>&matrixB) {
        // Code here
        for(int i=0;i<matrixA.size();i++){
            for(int j=0;j<matrixA.size();j++){
                matrixA[i][j]=matrixA[i][j]+matrixB[i][j];
            }
        }
    }
//Sum of upper and lower triangle
public:
    //Function to return sum of upper and lower triangles of a matrix.
    vector<int> sumTriangles(const vector<vector<int> >& matrix, int n)
    {
        // code here
        int upper=0,low=0;
        vector<int> v;
        for(int i=0;i<n;i++){
            for(int j=i;j<n;j++){
                upper=upper+matrix[i][j];
            }
        }
        for(int i=0;i<n;i++){
            for(int j=0;j<=i;j++){
                low=low+matrix[i][j];
            }
        }
        v.push_back(upper);
        v.push_back(low);
        return v;
    }
//Multiply matrices
void multiply(int a[][100], int b[][100], int c[][100], int n)
{
      //add code here.
      for(int i=0;i<n;i++){
       for(int j=0;j<n;j++){
            c[i][j]=0;
           for(int k=0;k<n;k++){
               c[i][j]+=a[i][k]*b[k][j];
           }
       }
      }
}
//Print matrix in snake pattern
public:
    //Function to return list of integers visited in snake pattern in matrix.
    vector<int> snakePattern(vector<vector<int> > matrix)
    {   
        // code here
        vector<int> v;
        int j=0;
        for(int i=0;i<matrix.size();i++){
            if(i%2==0){
                for(int j=0;j<matrix.size();j++){
                    v.push_back(matrix[i][j]);
                }
            }else{
              for(int j=matrix.size()-1;j>=0;j--){
                    v.push_back(matrix[i][j]);
                }  
            }
        }
        return v;
    }
//Transpose of matrix
public:  
    //Function to find transpose of a matrix.
    void transpose(vector<vector<int> >& matrix, int n)
    { 
        // code here 
        for(int i=0;i<n;i++){
            for(int j=i;j<n;j++){
                swap(matrix[i][j],matrix[j][i]);
            }
        }
    }
//Rotate by 90 degree
public:
    //Function to rotate matrix anticlockwise by 90 degrees.
    void rotateby90(vector<vector<int> >& matrix, int n) 
    { 
        // code here 
        //transpose
        for(int i=0;i<n;i++){
            for(int j=i;j<n;j++){
                swap(matrix[i][j],matrix[j][i]);
            }
        }
        //swap rows i, n-i
        for(int i=0;i<((n/2));i++){
            for(int j=0;j<n;j++){
                swap(matrix[i][j],matrix[n-i-1][j]);
            }
        }
        
    } 
//Determinant of a matrix
int determinantOfMatrix(vector<vector<int> > matrix, int n)
    {
        int det = 0; // the determinant value will be stored here
        if (matrix.size() == 1)
        {
            return matrix[0][0]; // no calculation needed
        }
        else if (matrix.size() == 2)
        {
            det = (matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0]);
            return det;
        }
        else
        {
            for (int p = 0; p < matrix[0].size(); p++)
            {
                vector<vector<int>> TempMatrix;
                for (int i = 1; i < matrix.size(); i++)
                {
                    vector<int> TempRow;
                    for (int j = 0; j < matrix[i].size(); j++)
                    {
                        if (j != p)
                        {
                            TempRow.push_back(matrix[i][j]);
                        }
                    }
                    if (TempRow.size() > 0)
                    TempMatrix.push_back(TempRow);
                }
                det = det + matrix[0][p] * pow(-1, p) * determinantOfMatrix(TempMatrix,matrix.size());
            }
            return det;
        }
   }
//Boundary traversal of matrix
public:
    //Function to return list of integers that form the boundary 
    //traversal of the matrix in a clockwise manner.
    vector<int> boundaryTraversal(vector<vector<int> > matrix, int n, int m) 
    {
        // code here
        
    vector<int> v;
    for(int i=0;i<1;i++){
     for(int j=0;j<m;j++)
      v.push_back(matrix[i][j]);
     }
     if(n==1)return v;
    for(int i=1;i<n;i++){
     for(int j=m-1;j<m;j++)
      v.push_back(matrix[i][j]);
    }
    if(m==1) return v;
    for(int i=n-1;i<n;i++){
     for(int j=m-2;j>=0;j--)
      v.push_back(matrix[i][j]);  
    }
    if(n==2) return v;
    for(int i=n-2;i>=1;i--){
     for(int j=0;j<1;j++)
      v.push_back(matrix[i][j]);
    }
    return v;
    }
//Spirally traversing a matrix
public: 
    //Function to return a list of integers denoting spiral traversal of matrix.
    vector<int> spirallyTraverse(vector<vector<int> > matrix, int row, int col) 
    {
        // code here 
        vector<int> v;
        int u=0,r=col-1,l=0,d=row-1;
        while((u<=d)&&(l<=r)){
            for(int i=l;i<=r;i++)
              v.push_back(matrix[u][i]);
            if((d-u+1)==1) return v;
            u++;
            for(int i=u;i<=d;i++)
               v.push_back(matrix[i][r]);
            if((r-l+1)==1) return v;
            r--;
            for(int i=r;i>=l;i--)
              v.push_back(matrix[d][i]);
            if((d-u+1)<2) return v;
            d--;
            for(int i=d;i>=u;i--)
              v.push_back(matrix[i][l]);
            l++;
            
        }
      return v;  
    }
//Rotate matrix elements clockwise
 vector<vector<int>> rotateMatrix(int M, int N, vector<vector<int>> mat) {
        // code here
        int r=0,c=0,maxRow=M-1,maxCol=N-1,prev=0,curr=0;
        while(r<maxRow&&c<maxCol){
            //top row
            prev=mat[r+1][c];
            for(int j=c;j<=maxCol;j++){
                curr=mat[r][j];
                mat[r][j]=prev;
                prev=curr;
            }
            r++;
            //right col
            for(int i=r;i<=maxRow;i++){
                curr=mat[i][maxCol];
                mat[i][maxCol]=prev;
                prev=curr;
            }
            maxCol--;
            //bottom row
            if(r<=maxRow){
                for(int j=maxCol;j>=c;j--){
                    curr=mat[maxRow][j];
                    mat[maxRow][j]=prev;
                    prev=curr;
                }
                maxRow--;
            }
            //left col
            if(c<=maxCol){
                for(int i=maxRow;i>=r;i--){
                    curr=mat[i][c];
                    mat[i][c]=prev;
                    prev=curr;
                }
                c++;
            }
        }
        return mat;
    }
//Search in a row-column sorted matrix
 public:
    //Function to search a given number in row-column sorted matrix.
    bool search(vector<vector<int> > matrix, int n, int m, int x) 
    {
        // code here 
        int l=m-1,d=0;
        if((x<matrix[0][0])||(x>matrix[n-1][m-1])) return false;
        while((d<n)&&(l>=0)){
            if(matrix[d][l]<x) d++;
            else if(matrix[d][l]>x) l--;
            else return true;
        }
        return false;
    }
//Boolean Matrix
 public:
    //Function to modify the matrix such that if a matrix cell matrix[i][j]
    //is 1 then all the cells in its ith row and jth column will become 1.
    void booleanMatrix(vector<vector<int> > &matrix)
    {
        // code here 
        /*
        int r=matrix.size(),c=matrix[0].size();
        bool r0=false,c0=false;
        int row[r],col[c];
        memset(row,0,sizeof row);
        memset(col,0,sizeof col);
        for(int i=0;i<r;i++){
            for(int j=0;j<c;j++){
                if(matrix[i][j]==1){row[i]=1;col[j]=1;}
            }
        }
         for(int i=0;i<r;i++){
            for(int j=0;j<c;j++){
                if((row[i]==1)||(col[j]==1)){matrix[i][j]=1;}
            }
        }
        */
        //method 2 use 0th row and 0th col of matrix as row[],col[] arrays
        int r=matrix.size(),c=matrix[0].size();
        bool r0=false,c0=false;
        //for(int i=0;i<r;i++){}
        //for(int i=0;i<c;i++){if(matrix[i][0]==1) c0=true;}
        for(int i=0;i<r;i++){
            for(int j=0;j<c;j++){
                if(i==0&&matrix[i][j]==1) r0=true;
                if(j==0&&matrix[i][j]==1) c0=true;
                if(matrix[i][j]==1){
                    matrix[0][j]=1;//like in col[j] mark 1
                    matrix[i][0]=1;//like in row[i] mark 1
                }
            }
        }
         for(int i=1;i<r;i++){
            for(int j=1;j<c;j++){
                if((matrix[i][0]==1)||(matrix[0][j]==1)){matrix[i][j]=1;}
            }
        }
        if(r0==1){ for(int i=0;i<c;i++) matrix[0][i]=1;}
        if(c0==1){ for(int j=0;j<r;j++) matrix[j][0]=1;}
        
    }
//Make matrix Beautiful  -makes rows sum and col sums same throughout the matrix
class Solution
{
    public:
    //Function to find minimum number of operations that are required 
    //to make the matrix beautiful.
    int findMinOpeartion(vector<vector<int> > matrix, int n)
    {
        // code here 
        vector<int> sumRow(n,0);
        vector<int> sumCol(n,0);
    // Calculate sumRow[] and sumCol[] array
    int maxSum = 0;
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j) {
            sumRow[i] += matrix[i][j];
            sumCol[i] += matrix[j][i];
            maxSum = max(maxSum, sumRow[i]);
        maxSum = max(maxSum, sumCol[i]);
        }
    // Find maximum sum value in either row or in column
    
   /* for (int i = 0; i < n; ++i) {
        maxSum = max(maxSum, sumRow[i]);
        maxSum = max(maxSum, sumCol[i]);
    }*/
    int count = 0;
    for (int i = 0, j = 0; i < n && j < n;) {
        // Find minimum increment required in either row or
        // column
        int diff
            = min(maxSum - sumRow[i], maxSum - sumCol[j]);
        // Add difference in corresponding cell, sumRow[]
        // and sumCol[] array
        matrix[i][j] += diff;
        sumRow[i] += diff;
        sumCol[j] += diff;
        // Update the count variable
        count += diff;
        // If ith row satisfied, increment ith value for
        // next iteration
        if (sumRow[i] == maxSum)
            ++i;
        // If jth column satisfied, increment jth value for
        // next iteration
        if (sumCol[j] == maxSum)
            ++j;
    }
    for(int i=0;i<n;i++){for(int j=0;j<n;j++){ cout<<matrix[i][j]<<" ";}cout<<"\n";}
    return count;
    } 
};
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int n;
        cin>>n;
        vector<vector<int> > matrix (n,vector<int>(n));
        for(int i=0;i<n;i++)
            for(int j=0;j<n;j++)
                cin>>matrix[i][j];
        Solution ob;
        cout << ob.findMinOpeartion(matrix, n) << endl;
    }
    return 0;
}

//Summed Matrix:
long long sumMatrix(long long n, long long q) {
        // code here
        if(q<2||q>2*n) return 0;
        return n-abs(n+1-q);
    }

HASHING:
//Non-Repeating Element
 public:
    int firstNonRepeating(int arr[], int n) 
    { 
        // Complete the function
        unordered_map<int,pair<int,int>> mp;
        int count=0,j=0,res=0;
        for(int i=0;i<n;i++){
            auto id=mp.find(arr[i]);
            if(id!=mp.end()){mp[arr[i]].second+=1;}
            else{j=i;count=1;mp.insert(make_pair(arr[i],make_pair(j,count)));}
            
        }
        j=INT_MAX;
        for(auto i:mp){
            if(i.second.second==1){
                if(i.second.first<j){j=i.second.first,res=i.first;}
            }
        }
        return res;
        
    } 
//First repeating element
 public:
    // Function to return the position of the first repeating element.
    int firstRepeated(int arr[], int n) {
        // code here
        unordered_map<int,pair<int,int>> mp;
        int count=0,j=0,res=0;
        for(int i=0;i<n;i++){
            auto id=mp.find(arr[i]);
            if(id!=mp.end()){mp[arr[i]].second+=1;}
            else {j=i;count=1;mp.insert(make_pair(arr[i],make_pair(j,count)));}
            
        }
        j=INT_MAX;
        for(auto i:mp){
            if(i.second.second>1){
                if(i.second.first<j){j=i.second.first,res=i.first;}
            }
        }
        return (j==INT_MAX)?-1:(j+1);
    }
//Union of two arrays
 public:
  //Function to return the count of number of elements in union of two arrays.
    int doUnion(int a[], int n, int b[], int m)  {
        //code here
        unordered_set<int> hash;
        for(int i=0;i<n;i++){
            hash.insert(a[i]);
        }
        for(int i=0;i<m;i++){
            hash.insert(b[i]);
        }
        return hash.size();
    }
//key pair (two sum)
public:	
	// Function to check if array has 2 elements
	// whose sum is equal to the given value
	bool hasArrayTwoCandidates(int arr[], int n, int x) {
	    // code here
	    unordered_set<int> h;
	    for(int i=0;i<n;i++){
	        if(h.find((x-arr[i]))!=h.end()) return true;
	        h.insert(arr[i]);
	    }
	    return false;
	}
//Count pairs with given sum
int getPairsCount(int arr[], int n, int k) {
        // code here
        int res=0;
        unordered_map<int,int> h;
        for(int i=0;i<n;i++){
            h[arr[i]]++;
        }
        for(int i=0;i<n;i++){
            if(h.find(k-arr[i])!=h.end()){
                res+=h[k-arr[i]];
                if((k-arr[i])==arr[i]) res--;
                h[arr[i]]--;
            }
        
        }
        return res;
    }
//check if two arrays are equal or not
 public:
    //Function to check if two arrays are equal or not.
    bool check(vector<ll> A, vector<ll> B, int N) {
        //code here
        unordered_map<int,int> h;
        for(int i=0;i<A.size();i++){
            h[A[i]]++;
        }
        for(int i=0;i<B.size();i++){
            if(h[B[i]]<=0) return false;
            h[B[i]]--;
        }
        return true;
    }
//subarray with 0 sum
public:
    //Complete this function
    //Function to check whether there is a subarray present with 0-sum or not.
    bool subArrayExists(int arr[], int n)
    {
        //Your code 
       unordered_set<int> h;
       long long int sum=0;
        for(int i=0;i<n;i++){
            sum+=arr[i];
            if(sum==0) return true;
            else if(h.find(sum)!=h.end()) return true;
            else{ h.insert(sum);}
        }
        return false;
    }
//winner of an election
public:
    //Function to return the name of candidate that received maximum votes.
    vector<string> winner(string arr[],int n)
    {
        // Your code here
        // Return the string containing the name and an integer
        // representing the number of votes the winning candidate got
        vector<string> v;
        unordered_map<string,int> h;
        for(int i=0;i<n;i++){
            h[arr[i]]++;
        }
        int maxi=INT_MIN;
        string key;
        //int val;
        for(auto i:h){
            if(i.second>maxi){ key=i.first;maxi=i.second;}
            else if(i.second==maxi){ key=min(key,i.first);maxi=i.second;}
        }
        string res=to_string(maxi);
        v.push_back(key);
        v.push_back(res);
        return v;
    }
//subarray range with given sum
public:
    //Function to count the number of subarrays which adds to the given sum.
    int subArraySum(int arr[], int n, int sum)
    {
        //Your code here
        unordered_map<int,int> m;
        int presum=0,res=0;
        for(int i=0;i<n;i++){
            presum+=arr[i];
            if(presum==sum)res++;
            if(m.find(presum-sum)!=m.end()){res+=m[presum-sum];}
            m[presum]++;
        }
        return res;
    }
//Positive Negative Pair
 public:
    //Function to return list containing all the pairs having both
    //negative and positive values of a number in the array.
    vector <int> findPairs(int arr[], int n) 
    {
        // code here
        vector<int> v;
        unordered_map<int,int> h;
        for(int i=0;i<n;i++){
            if(h.find(-1*arr[i])!=h.end()){h[-1*arr[i]]--;v.push_back(-1*abs(arr[i]));v.push_back(abs(arr[i]));}
           else h[arr[i]]++;
        }
        return v;
    }
//Zero sum subarrays
 public:
    //Function to count subarrays with sum equal to 0.
    ll findSubarray(vector<ll> arr, int n ) {
        //code here
        unordered_map<long long int,long long int> m;
        long long int presum=0,res=0,sum=0;
        for(int i=0;i<n;i++){
            presum+=arr[i];
            if(presum==sum)res++;
            if(m.find(presum-sum)!=m.end()){res+=m[presum-sum];}
            m[presum]++;
        }
        return res;
    }
//Subarrays with equal 1s and 0s
public:
    //Function to count subarrays with 1s and 0s.
    long long int countSubarrWithEqualZeroAndOne(int arr[], int n)
    {
        //Your code here
        unordered_map<long long int,long long int> m;
        long long int presum=0,res=0,sum=0;
        for(int i=0;i<n;i++){
            if(arr[i]==0)arr[i]=-1;
            presum+=arr[i];
            if(presum==sum)res++;
            if(m.find(presum-sum)!=m.end()){res+=m[presum-sum];}
            m[presum]++;
        }
        return res;        
    }
//sort an array according to the other
public:
    // A1[] : the input array-1
    // N : size of the array A1[]
    // A2[] : the input array-2
    // M : size of the array A2[]    
    //Function to sort an array according to the other array.
    vector<int> sortA1ByA2(vector<int> A1, int N, vector<int> A2, int M) 
    {
        //Your code here
        unordered_map<int,int> h;
        vector<int> v;
        for(int i=0;i<N;i++){
            h[A1[i]]++;
        }
        for(int i=0;i<M;){
            while(h[A2[i]]>0){
                v.push_back(A2[i]);
                h[A2[i]]--;
            }
            i++;
        }
        vector<int> res;
        for(auto it=h.begin();it!=h.end();){
           while((*it).second>0){
                res.push_back((*it).first);
                (*it).second--;
            }
            it++;  
        }
        sort(res.begin(),res.end());
        for(int i=0;i<res.size();i++){
            v.push_back(res[i]);
        }
        return v;
    }
//Sorting Elements of an Array by Frequency
#include<iostream>
#include<vector>
#include<unordered_map>
#include<algorithm>
using namespace std;
bool comp(pair<int,int>a,pair<int,int>b){
    if(a.second>b.second) return true;
    else if(a.second==b.second){if(a.first<b.first) return true;else return false;}
    else return false;
}
int main()
 {
	//code
	int t;
	cin>>t;
	while(t--){
	    int n,t;
	    cin>>n;
	    unordered_map<int,int> h;
	    vector<pair<int,int>> v;
	    for(int i=0;i<n;i++){
	        cin>>t;
	        h[t]++;
	    }
	    for(auto it:h){
	       v.push_back({it.first,it.second});
	    }
	    sort(v.begin(),v.end(),comp);
	    for(auto it:v){
	        int temp=it.second;
	        while(temp--)
	         cout<<it.first<<" ";
	    }
	   cout<<"\n";
	}
	return 0;
}
//Longest consecutive subsequence -o(n)time&space
public:
    // arr[] : the input array
    // N : size of the array arr[]
    //Function to return length of longest subsequence of consecutive integers.
    int findLongestConseqSubseq(int arr[], int N)
    {
      //Your code here
      int count=0,maxi=INT_MIN;
      unordered_set<int> h;
       for(int i=0;i<N;i++){
          h.insert(arr[i]);
      }
      for(int i=0;i<N;i++){
          if(h.find(arr[i]-1)==h.end()){
              int j=arr[i];
              while(h.find(j+1)!=h.end()){count++;j++;}
              count++;
              maxi=max(count,maxi);
          }
          count=0;
      }
      if(maxi==INT_MIN) return 1;
      return maxi;
    }
//Triplet Sum in Array
 bool find3Numbers(int arr[], int n, int X)
    {  
        /*m-1:o(n^2)
        unordered_map<int,int> h;
        for(int i=0;i<n;i++) h[arr[i]]++;
        for(int i=0;i<=(n-3);i++){
            for(int j=i+1;j<n;j++){
                int y=(arr[i]+arr[j]);
                if(y<X){
                    int t=X-y;
                    h[arr[i]]--;
                    h[arr[j]]--;
                    if(h[t]>0) return true;
                    h[arr[i]]++;
                    h[arr[j]]++;
                }
            }
        }
        return false;
        */
        //m-2:o(n^2)
        int l,h;
        sort(arr,arr+n);//o(nlogn)
        for(int i=0;i<n-2;i++){//o(n^2)
            l=i+1;
            h=n-1;
            while(l<h){
              if(arr[i]+arr[l]+arr[h]==X) return true;
              else if(arr[i]+arr[l]+arr[h]<X) l++;
              else h--;
            }
        }
        return false;
    }
//Swapping pairs make sum equal:
	int findSwapValues(int A[], int n, int B[], int m)
	{
        // Your code goes here
      /* //m-1: o(nlogn+mlogn)
      sort(A,A+n);
       sort(B,B+m);
       long long int sumA=0,sumB=0;
       for(int i=0;i<n;i++) sumA+=A[i];
       for(int i=0;i<m;i++) sumB+=B[i];
       if((sumA-sumB)%2!=0) return -1;// because that the target must be an integer as a-b will always be integer.
       long long int target=(sumA-sumB)/2;// Finds value of  a - b = (sumA - sumB) / 2
       int i=0,j=0,diff=0;
       while(i<n&&j<m){
           diff=A[i]-B[j];
           if(diff==target) return 1; // Look for a greater value in A[]
           else if(diff<target) i++; // Look for a greater value in B[]
           else j++;
       }
       return -1;
       */
       //m-2:o(m+n)
       unordered_set<int> h;
       long long int sumA=0,sumB=0;
       for(int i=0;i<n;i++) sumA+=A[i];
       for(int i=0;i<m;i++) sumB+=B[i],h.insert(B[i]);
       if((sumA-sumB)%2!=0) return -1;// because that the target must be an integer as a-b will always be integer.
       long long int target=(sumA-sumB)/2;// Finds value of  a - b = (sumA - sumB) / 2
       for(int i=0;i<n;i++){
           if(h.find(A[i]-target)!=h.end()) return 1;
       }
       return -1;
	}
//Find All Four Sum Numbers
 public:
    // arr[] : int input array of integers
    // k : the quadruple sum required
    vector<vector<int> > fourSum(vector<int> &arr, int k) {
        // Your code goes here
        int n=arr.size();
        vector<vector<int>> ans;
        sort(arr.begin(),arr.end());
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                int a=arr[i],b=arr[j];
                int sum=k-a-b;
                int s=j+1;
                int e=n-1;
                while(s<e){
                    int c=arr[s],d=arr[e];
                    int twoSum=c+d;
                    if(twoSum<sum) s++;
                    else if(twoSum>sum) e--;
                    else{
                        vector<int> v={a,b,c,d};
                        ans.push_back(v);
                        while(s<e&&arr[s]==c) s++;
                        while(s<e&&arr[e]==d) e--;
                    }
                    while(j+1<n&&arr[j]==arr[j+1]) j++;
                }
                while(i+1<n&&arr[i]==arr[i+1]) i++;
            }
        }
        return ans;
    }
STRINGS:
//Naive Pattern searching
bool searchPattern(string str, string pat)
{
    // your code here
    int len=0,cnt=0;
    for(int i=0;i<str.length();i++){
        len=i;
        for(int j=0;j<pat.length()&&cnt<pat.length();j++){
            if(str[len]==pat[j]){len++;cnt++;}
            else {cnt=0;break;}
        }
        if(cnt==pat.length()) return true;
    }
    return false;
}
//Binary string (cnt of all substrings that should start and end with 1)
public:
    //Function to count the number of substrings that start and end with 1.
    long binarySubstring(int n, string a){
        
        // Your code here
        //m-1
        /*long cnt=0;
        int j=0;
        for(int i=0;i<a.length();i++){
            if(a[i]=='1'){
                j=i+1;
                while(j<a.length()){
                    if(a[j]=='1')cnt++;
                    j++;
                }
            }
        }
        return cnt;
        */
//m-2 return no of ways to form pair of 1's as count 
      long count=0;
      for(int i=0;i<a.length();i++){
          if(a[i]=='1') count++;
      }
      return count*(count-1)/2;
    }


//Implement strstr
//Function to locate the occurrence of the string x in the string s.
int strstr(string str, string pat)
{
     //Your code here
      int len=0,cnt=0;
    for(int i=0;i<str.length();i++){
        len=i;
        for(int j=0;j<pat.length()&&cnt<pat.length();j++){
            if(str[len]==pat[j]){len++;cnt++;}
            else {cnt=0;break;}
        }
        if(cnt==pat.length()) return i;
    }
    return -1;
}

//Anagram
public:
    //Function is to check whether two strings are anagram of each other or not.
    bool isAnagram(string a, string b){
        
        // Your code here
        unordered_map<int,int> h;
        if(a.length()!=b.length()) return false;
        for(int i=0;i<a.length();i++){
            h[a[i]]++;
        }
        for(int i=0;i<b.length();i++){
            if(h.find(b[i])==h.end()) return false;
            h[b[i]]--;
            if(h[b[i]]<=0) h.erase(b[i]);
        }
        return true;
    }

//Check if string is rotated by two places
 public:
    //Function to check if a string can be obtained by rotating
    //another string by exactly 2 places.
    
    void reverseArr(string &arr,int n, int low,int high){
          n=arr.length();
        while(low<high){
        swap(arr[low],arr[high]); 
        low++,high--;
      }
    }
    //Function to rotate an array by d elements in counter-clockwise direction. 
    string rotateArr(string &arr, int d, int n){
        // code here
         n=arr.length();
        if(d>n){
            d=d-n;
        }
        reverseArr(arr,n,0,d-1);
        reverseArr(arr,n,d,(n-1));
        reverseArr(arr,n,0,n-1);
        return arr;
    }
    bool isRotated(string str1, string str2)
    {
        // Your code here
        string copy=str1;
        if(str2==rotateArr(str1,2,str1.length())) return true; //counterclockwise rotation
        else if(str2==rotateArr(copy,str1.length()-2,str1.length())) return true;//clockwise rotation
        else return false;
    }

//Check if strings are rotations of each other or not
 public:
    /*
    //Function to check if two strings are rotations of each other or not.
     void reverseArr(string &arr,int n, int low,int high){
          n=arr.length();
        while(low<high){
        swap(arr[low],arr[high]); 
        low++,high--;
      }
    }
    //Function to rotate an array by d elements in counter-clockwise direction. 
    string rotateArr(string &arr, int d, int n){
        // code here
         n=arr.length();
        if(d>n){
            d=d-n;
        }
        reverseArr(arr,n,0,d-1);
        reverseArr(arr,n,d,(n-1));
        reverseArr(arr,n,0,n-1);
        return arr;
    }
    bool areRotations(string str1,string str2)
    {
        // Your code here
        string copy1,copy2;
        for(int i=0;i<str1.length();i++){
        copy1=str1;
        copy2=str1;
        if(str2==rotateArr(copy1,i,str1.length())) return true; //counterclockwise rotation
        else if(str2==rotateArr(copy2,str1.length()-i,str1.length())) return true;//clockwise rotation
        }
        return false;
    }
    */
    //method2
    bool areRotations(string str1,string str2){
        if(str1.length()!=str2.length()) return false;
        string r=str1+str1;
        if(r.find(str2)!=-1) return true;
        else return false;
    }

// ISOMORPHIC STRINGS
// This function returns true if str1 and str2 are isomorphic
bool areIsomorphic(string str1, string str2)
{
    int MAX_CHARS=256;
    int m = str1.length(), n = str2.length();

    // Length of both strings must be same for one to one
    // correspondence
    if (m != n)
        return false;

    // To mark visited characters in str2
    bool marked[MAX_CHARS] = { false };

    // To store mapping of every character from str1 to
    // that of str2. Initialize all entries of map as -1.
    int map[MAX_CHARS];
    memset(map, -1, sizeof(map));

    // Process all characters one by on
    for (int i = 0; i < n; i++) {
        // If current character of str1 is seen first
        // time in it.
        if (map[str1[i]] == -1) {
            // If current character of str2 is already
            // seen, one to one mapping not possible
            if (marked[str2[i]] == true)
                return false;

            // Mark current character of str2 as visited
            marked[str2[i]] = true;

            // Store mapping of current characters
            map[str1[i]] = str2[i];
        }

        // If this is not first appearance of current
        // character in str1, then check if previous
        // appearance mapped to same character of str2
        else if (map[str1[i]] != str2[i])
            return false;
    }

    return true;
}

// check if a string is Isogram or not
 public:
    //Function to check if a string is Isogram or not.
    bool isIsogram(string s)
    {
        //Your code here
        unordered_set<int> h;
        for(int i=0;i<s.length();i++){
            if(h.find(s[i])!=h.end()) return false;
            h.insert(s[i]);
        }
        return true;
    }

//Keypad typing
string printNumber(string s, int n) 
{
    //code here
   string one=" ",two="abc",three="def",four="ghi",five="jkl",six="mno",seven="pqrs",eight="tuv",nine="wxyz",star="*";
    string res="";
    for(int i=0;i<s.length();i++){
        if(one.find(s[i])!=-1) res+='1';
        else if(one.find(s[i])!=-1) res+='1';
        else if(two.find(s[i])!=-1) res+='2';
        else if(three.find(s[i])!=-1) res+='3';
        else if(four.find(s[i])!=-1) res+='4';
        else if(five.find(s[i])!=-1) res+='5';
        else if(six.find(s[i])!=-1) res+='6';
        else if(seven.find(s[i])!=-1) res+='7';
        else if(eight.find(s[i])!=-1) res+='8';
        else if(nine.find(s[i])!=-1) res+='9';
     }
    return res;
}

//Repeated Character
public:
    char firstRep (string s)
    {
        //code here.
       unordered_map<char,int> h;
       for(int i=0;i<s.length();i++){
           h[s[i]]++;
       }
       for(int i=0;i<s.length();i++){
           if(h[s[i]]>1) return s[i];
       }
       return '#';
    }
//Non Repeating Character
public:
    //Function to find the first non-repeating character in a string.
    char nonrepeatingCharacter(string s)
    {
       //Your code here
        unordered_map<char,int> h;
       for(int i=0;i<s.length();i++){
           h[s[i]]++;
       }
       for(int i=0;i<s.length();i++){
           if(h[s[i]]==1) return s[i];
       }
       return '$';
       
    }

//Maximum Occuring Character
public:
    //Function to find the maximum occurring character in a string.
    char getMaxOccuringChar(string str)
    {
        // Your code here
        unordered_map<char,int> h;
        char res;
        int maxi=INT_MIN;
        for(int i=0;i<str.length();i++){
            h[str[i]]++;
        }
        for(auto i:h){
            if(i.second>maxi) maxi=i.second,res=i.first;
            else if(i.second==maxi){
                if(i.first<res) res=i.first;
            }
        }
        return res;
    }

//Remove common characters and concatenate
public:
    //Function to remove common characters and concatenate two strings.
    string concatenatedString(string s1, string s2) 
    { 
        // Your code here
        unordered_map<char,int> h1,h2;
        int temp;
        string res="";
        
        for(int i=0;i<s1.length();i++){
            h1[s1[i]]++;
        }
        for(int i=0;i<s2.length();i++){
            h2[s2[i]]++;
        }
       for(int i=0;i<s1.length();i++){
           if(h2.find(s1[i])==h2.end()) res+=s1[i];
       }
       for(int i=0;i<s2.length();i++){
           if(h1.find(s2[i])==h2.end()) res+=s2[i];
       }
       if(res=="") return "-1";
       return res;
    }
//Reverse words in a given string
public:
    //Function to reverse words in a given string.
    string reverseWords(string s) 
    { 
        // code here 
        stack<string> st;
        string temp="",res="";
        for(int i=0;i<s.length();i++){
            if(s[i]=='.'){ st.push(temp);temp="";}
            else temp+=s[i];
        }
        st.push(temp);
        while(st.empty()!=true){
            res+=st.top();
            if(st.size()!=1)
              res+=".";
            st.pop();
        }
        
        return res;
    }
//Sum of numbers in string 
 public:
    int stoi(string temp){
        int len=(temp.length()),res=0,val=0,i=0;
        while(len--){
            val=temp[i]-'0';
            res*=10;
            res+=val;
            i++;
        }
        return res;
    }
    //Function to calculate sum of all numbers present in a string.
    int findSum(string str)
    {    	// Your code here
    	int res=0;
    	string temp="";
    	for(int i=0;i<str.length();i++){
    	    if(str[i]=='0'||str[i]=='1'||str[i]=='2'||str[i]=='3'||str[i]=='4'||str[i]=='5'||str[i]=='6'||str[i]=='7'||str[i]=='8'||str[i]=='9')
    	        temp+=str[i];
    	   else{
    	       if(str[i]=='\0') break;
    	         res+=stoi(temp);
    	         temp="";
    	   }
    	    
    	}
    	res+=stoi(temp);
    	return res;
    }

//Pangram Checking
public:
    //Function to check if a string is Pangram or not.
    bool checkPangram (string &str) {
        // your code here
        int chars[26]={0};
        transform(str.begin(),str.end(),str.begin(),::tolower);
        for(int i=0;i<str.length();i++){
            if(str[i]!='.'||str[i]!=','||str[i]!='?'||str[i]!=' ') chars[str[i]-'a']=1;
        }
        for(int i=0;i<26;i++){
            if(chars[i]!=1) return false;
        }
        return true;
    }

//Minimum indexed character 
public:
    //Function to find the minimum indexed character.
    int minIndexChar(string str, string patt)
    {
        // Your code here
        for(int i=0;i<str.length();i++){
            if(patt.find(str[i])!=string::npos) return i;
        }
        return -1;
    }
//Smallest window in a string containing all the characters of another string
string Minimum_Window(string s, string t)
{
//sliding window -o(s) time and o(1) space.
    int m[256] = { 0 };

    // Answer
    int ans = INT_MAX; // length of ans
    int start = 0; // starting index of ans
    int count = 0;
  
    // creating map
    for (int i = 0; i < t.length(); i++) {
        if (m[t[i]] == 0)
            count++;
        m[t[i]]++;
    }

    // References of Window
    int i = 0;
    int j = 0;

    // Traversing the window
    while (j < s.length()) {
        // Calculations
        m[s[j]]--;
        if (m[s[j]] == 0)
            count--;

        // Condition matching
        if (count == 0) {
            while (count == 0) {
                // Sorting ans
                if (ans > j - i + 1) {
                    ans = min(ans, j - i + 1);
                    start = i;
                }
                // Sliding I
                // Calculation for removing I

                m[s[i]]++;
                if (m[s[i]] > 0)
                    count++;

                i++;
            }
        }
        j++;
    }

    if (ans != INT_MAX)
        return s.substr(start, ans);
    else
        return "-1";
}

//Nth number made of prime digits
public:
    //Function to find nth number made of only prime digits.
    int primeDigits(int n)
    {
        //code here
        int rem=0;
        string res="";
        while(n){
            rem=n%4;
            switch(rem){
                case 1:res.push_back('2'); break;
                case 2: res.push_back('3');break;
                case 3:res.push_back('5'); break;
                case 0: res.push_back('7');break;
            }
            if(n%4==0) n--;
            n=n/4;
        }
        reverse(res.begin(),res.end());
        return stoi(res);
        
    }
//The Modified String
public:
    //Function to find minimum number of characters which Ishaan must insert  
    //such that string doesn't have three consecutive same characters.
    int modified (string a)
    {
        // Your code here
        int chars[26]={0};
        int flag=0,res=0,pos=0,count=1;
        string str2;
        for(int i=1;i<a.length();i++){
            if(a[i-1]==a[i]){
                count++;
                if(count==3){ 
                res++;
                count=1;
                }
            }
            else count=1;
        }
        return res;
    }
//Case-specific Sorting of Strings
public:
    //Function to perform case-specific sorting of strings.
    string caseSort(string str, int n)
    {
        // your code here
        int low[26]={0},up[26]={0};
        int l=0,u=0;
        for(int i=0;i<str.length();i++){
            if(int(str[i])>=65&&int(str[i])<=90) up[str[i]-'A']++;
            else if(int(str[i])>=97&&int(str[i])<=122) low[str[i]-'a']++;
        }
        //string res="";
        for(int i=0;i<str.length();i++){
            if(int(str[i])>=65&&int(str[i])<=90){
                while(up[u]==0){u++;}
                str[i]=char('A'+u);
                up[u]--;
                if(up[u]==0) u++;
            }
            else if(int(str[i])>=97&&int(str[i])<=122){
                while(low[l]==0) l++;
                str[i]=char('a'+l);
                low[l]--;
                if(low[l]==0) l++;
            }
        }
        return str;
    }

//Lexicographic Rank Of A String

// Construct a count array where value at every index
// contains count of smaller characters in whole string
void populateAndIncreaseCount(int* count, string str)
{
	int i,MAX_CHAR=256;

	for (i = 0; str[i]; ++i)
		++count[str[i]];

	for (i = 1; i < MAX_CHAR; ++i)
		count[i] += count[i - 1];
}

// Removes a character ch from count[] array
// constructed by populateAndIncreaseCount()
void updatecount(int* count, char ch)
{
	int i,MAX_CHAR=256;;
	for (i = ch; i < MAX_CHAR; ++i)
		--count[i];
}
// A function to find rank of a string in all permutations
// of characters
int findRank(string str)
{
	int len = strlen(str);
	int mul = fact(len);
	int rank = 1, i,MAX_CHAR=256;;

	// all elements of count[] are initialized with 0
	int count[MAX_CHAR] = { 0 };

	// Populate the count array such that count[i]
	// contains count of characters which are present
	// in str and are smaller than i
	populateAndIncreaseCount(count, str);

	for (i = 0; i < len; ++i) {
		mul /= len - i;

		// count number of chars smaller than str[i]
		// from str[i+1] to str[len-1]
		rank += count[str[i] - 1] * mul;

		// Reduce count of characters greater than str[i]
		updatecount(count, str[i]);
	}

	return rank;
}

//Rabin Karp - Pattern Searching
 public:
        vector <int> search(string pat, string txt)
        {
            //code here.
            vector<int> res;
            int q=INT_MAX,h=1,d=256,p=0,t=0;
            int m=pat.length(),n=txt.length();
            for(int i=0;i<m-1;i++){
                h=(h*d)%q;
            }
            for(int i=0;i<=m-1;i++){
                p=(p*d+pat[i])%q;
                t=(t*d+txt[i])%q;
            }
            for(int i=0;i<=n-m;i++){
               if(p==t){
                 bool flag=true;
                 for(int j=0;j<m;j++){
                     if(txt[i+j]!=pat[j]){flag=false;break;}
                 }
                 if(flag==true) res.push_back(i+1);
               }
               if(i<n-m){
                   t=(d*(t-txt[i]*h)+txt[i+m])%q;
                   if(t<0) t=t+q;
               }
            }
            if(res.size()<1) res.push_back(-1);
            return res;
        }

// Pattern Search KMP
// Prints occurrences of txt[] in pat[]
// Fills lps[] for given patttern pat[0..M-1]
void computeLPSArray(char* pat, int M, int* lps)
{
    // length of the previous longest prefix suffix
    int len = 0;

    lps[0] = 0; // lps[0] is always 0

    // the loop calculates lps[i] for i = 1 to M-1
    int i = 1;
    while (i < M) {
        if (pat[i] == pat[len]) {
            len++;
            lps[i] = len;
            i++;
        }
        else // (pat[i] != pat[len])
        {
            // This is tricky. Consider the example.
            // AAACAAAA and i = 7. The idea is similar
            // to search step.
            if (len != 0) {
                len = lps[len - 1];

                // Also, note that we do not increment
                // i here
            }
            else // if (len == 0)
            {
                lps[i] = 0;
                i++;
            }
        }
    }
}

void KMPSearch(char* pat, char* txt)
{
    int M = strlen(pat);
    int N = strlen(txt);

    // create lps[] that will hold the longest prefix suffix
    // values for pattern
    int lps[M];

    // Preprocess the pattern (calculate lps[] array)
    computeLPSArray(pat, M, lps);

    int i = 0; // index for txt[]
    int j = 0; // index for pat[]
    while (i < N) {
        if (pat[j] == txt[i]) {
            j++;
            i++;
        }

        if (j == M) {
            printf("Found pattern at index %d ", i - j);
            j = lps[j - 1];
        }

        // mismatch after j matches
        else if (i < N && pat[j] != txt[i]) {
            // Do not match lps[0..lps[j-1]] characters,
            // they will match anyway
            if (j != 0)
                j = lps[j - 1];
            else
                i = i + 1;
        }
    }
}
//Check if a String is Subsequence of Other
public:
    bool isSubSequence(string A, string B) 
    {
        // code here
        if(A.length()>B.length()) return false;
        int i=0,j=0;
        while(j<B.length()&&i<A.length()){
            if(A[i]==B[j]){i++,j++;}
            else j++;
        }
        if(i==A.length()) return true;
        else return false;
    }

//Multiply two strings
string multiplyStrings(string s1, string s2) {
       //Your code here
       int p1=0,p2=0;
       if(s1[0]=='-') p1=1,s1=s1.substr(1);
       if(s2[0]=='-') p2=1,s2=s2.substr(1);
       int i=0,j=0;
       while(i<s1.size()&&s1[i]=='0'){
           i++;
       }
       if(i!=0) s1=s1.substr(i);
       while(j<s2.size()&&s2[j]=='0'){
           j++;
       }
       if(j!=0) s2=s2.substr(j);
       int m=s1.size(),n=s2.size();
       if(n==0||m==0) return "0";
       vector<int> store(n+m,0);
       int mul,l,r,sum;
       for(int i=m-1;i>=0;i--){
           for(int j=n-1;j>=0;j--){
               mul=(s1[i]-'0')*(s2[j]-'0');
               l=i+j;
               r=i+j+1;
               sum=mul+store[r];
               store[r]=sum%10;
               store[l]+=sum/10;
           }
       }
       string ans;
       for(int i=0;i<n+m;i++){
           if(i==0&&store[i]==0) continue;
           ans+=to_string(store[i]);
       }
       if(p1^p2){
           return "-"+ans;
       }else return ans;
    }
//Roman Number to Integer
int romanToDecimal(string &str) {
        // code here
        unordered_map<char,int> h;
        h['I']=1;
        h['V']=5;        
        h['X']=10;
        h['L']=50;
        h['C']=100;
        h['D']=500;
        h['M']=1000;
        int prev=0,ans=0;
        for(auto s:str){
            if(prev>0&&prev<h[s]){//for cases like num:iv
                ans-=prev;
                ans=ans+h[s]-prev;
                prev=0;
            }else{
                ans+=h[s];
                prev=h[s];
            }
        }
        return ans;

    }
LINKEDLISTS:
//01.Count nodes of linked list
//public:
    //Function to count nodes of a linked list.
    int getCount(struct Node* head){
    
        //Code here
        if(head==NULL) return 0;
        Node *p=head;
        int count=0;
        while(p!=NULL&&p->next!=NULL){
            count++;
            p=p->next;
        }
    return count+1;
    }

//02.Linked List Insertion
 public:
    //Function to insert a node at the beginning of the linked list.
    Node *insertAtBegining(Node *head, int x) {
       // Your code here
       if(head==NULL){head=new Node(x);return head;}
       Node *n=new Node(x);
       n->next=head;
       return n;
       
    }  
    //Function to insert a node at the end of the linked list.
    Node *insertAtEnd(Node *head, int x)  {
       // Your code here
       if(head==NULL){head=new Node(x);return head;}
       Node *n=new Node(x);
       Node *t=head;
       while(t->next!=NULL) t=t->next;
       t->next=n;
       return head;
    }

//03.Doubly linked list Insertion at given position
void addNode(Node *head, int pos, int x)
{
   // Your code here
   int count=0;
   Node *n=new Node(x);
   Node * t=head;
   while(count!=pos){
       t=t->next;
       count++;
   }
   if(t->next==NULL){t->next=n;n->prev=t; return;}
   n->next=t->next;
   n->prev=t;
   t->next=n;
   n->next->prev=n;
   return;
   
}
//04.Insert in Middle of Linked List
//Function to insert a node in the middle of the linked list.
Node* insertInMiddle(Node* head, int x)
{
	// Code here
	Node * slow=NULL;
	Node * fast=NULL;
	Node * n=new Node(x);
	if(head==NULL){head=n; return head;}
	slow=head;
	fast=head;
	while(fast!=NULL&&fast->next!=NULL&&fast->next->next!=NULL){
	    slow=slow->next;
	    fast=fast->next->next;
	}
	n->next=slow->next;
   	slow->next=n; 
	return head;
}

//05.Identical Linked Lists
//Function to check whether two linked lists are identical or not. 
bool areIdentical(struct Node *head1, struct Node *head2)
{
    // Code here
    Node *h1=head1;
    Node *h2=head2;
    while(h1!=NULL&&h2!=NULL&&h1->data==h2->data){
        h1=h1->next;
        h2=h2->next;
    }
    if(h1==NULL&&h2==NULL) return true;
    else return false;    
}

//06.Delete without head pointer
 public:
    //Function to delete a node without any reference to head pointer.
    void deleteNode(Node *del)
    {
       // Your code here
       del->data=del->next->data;
       Node *t=del->next;
       del->next=del->next->next;
       t->next=NULL;
       delete t;
    }
//07. Remove duplicate element from sorted Linked List
//Function to remove duplicates from sorted linked list.
Node *removeDuplicates(Node *head)
{
 // your code goes here
 Node *t=head;
 Node *q=head;
 while(t!=NULL&&t->next!=NULL){
     if(t->next!=NULL&&t->data!=t->next->data){t=t->next;}
     else if(t->next!=NULL&&t->data==t->next->data){
         q=t->next;
         t->next=t->next->next;
         q->next=NULL;
         delete q;
     }
 }
 return head;
}

//08.Remove duplicates from an unsorted linked list
public:
    //Function to remove duplicates from unsorted linked list.
    Node * removeDuplicates( Node *head) 
    {
     // your code goes here
     unordered_set<int> h;
     Node * curr=head;
     Node * prev=NULL;
     while(curr!=NULL){
         if(h.find(curr->data)!=h.end()){prev->next=curr->next;delete curr;}
         else{ 
             h.insert(curr->data);
             prev=curr;
         }
         curr=prev->next;
     }
     return head;
    }
//09.Merge two sorted linked lists
//Function to merge two sorted linked list.
Node* sortedMerge(Node* head1, Node* head2)  
{  
    // code here
    if(head1==NULL)return head2;
    if(head2==NULL)return head1;
    Node *head=NULL;
    Node *tail=NULL;
    if(head1->data<=head2->data){
        head=tail=head1;
        head1=head1->next;
    }
    else {
        head=tail=head2;
        head2=head2->next;
    }
    while(head1!=NULL&&head2!=NULL){
        if(head1->data<=head2->data){
            tail->next=head1;
            tail=head1;
            head1=head1->next;
        }
        else{
            tail->next=head2;
            tail=head2;
            head2=head2->next;
        }
    }
    if(head1==NULL){
        tail->next=head2;
    }else{
        tail->next=head1;
    }
    return head;    
}  
//10.Nth node from end of linked list
//Function to find the data of nth node from the end of a linked list.
int getNthFromLast(Node *head, int n)
{
       // Your code here
       if(head==NULL||n<=0)return -1;
       Node *first=head;
       Node *second=head;
       for(int i=1;i<=n;i++){
           if(first==NULL) return -1;
           first=first->next;
       }
       while(first!=NULL){
           first=first->next;
           second=second->next;
       }
       return second->data;    
}
//11.Swap Kth nodes from ends
Node *swapkthnode(Node* head, int num, int K)
{
 // Count nodes in linked list
	int n = num,k=K;        
	// Check if k is valid
	if (n < k)
		return head;
	// If x (kth node from start) and y(kth node from end)
	// are same
	if (2 * k - 1 == n)
		return head;
	// Find the kth node from the beginning of the linked
	// list. We also find previous of kth node because we
	// need to update next pointer of the previous.
	Node* x = head;
	Node* x_prev = NULL;
	for (int i = 1; i < k; i++) {
		x_prev = x;
		x = x->next;
	}
	// Similarly, find the kth node from end and its
	// previous. kth node from end is (n-k+1)th node from
	// beginning
	Node* y = head;
	Node* y_prev = NULL;
	for (int i = 1; i < n - k + 1; i++) {
		y_prev = y;
		y = y->next;
	}
	// If x_prev exists, then new next of it will be y.
	// Consider the case when y->next is x, in this case,
	// x_prev and y are same. So the statement "x_prev->next
	// = y" creates a self loop. This self loop will be
	// broken when we change y->next.
	if (x_prev)
		x_prev->next = y;
	// Same thing applies to y_prev
	if (y_prev)
		y_prev->next = x;
	// Swap next pointers of x and y. These statements also
	// break self loop if x->next is y or y->next is x
	Node* temp = x->next;
	x->next = y->next;
	y->next = temp;
	// Change head pointers when k is 1 or n
	if (k == 1)
		head = y;
	if (k == n)
		head = x;
	return head;
}
//12.Reverse a linked list
public:
    //Function to reverse a linked list.
    struct Node* reverseList(struct Node *head)
    {
        // code here
        // return head of reversed list
        if(head==NULL)return head;
        Node *curr=head;
        Node *prev=NULL;
        Node *next=head->next;
        while(curr->next!=NULL){
            curr->next=prev;
            prev=curr;
            curr=next;
            next=next->next;
        }
        curr->next=prev;
        head=curr;
        return head;
    }
//12.1 Reverse a Linked List in groups of given size.
public:
    struct node *reverse (struct node *head, int k)
    { 
        if(head==NULL||head->next==NULL) return head;
        int c=k;
        node *curr=head,*prev=NULL,*next=NULL;
        while(k--&&curr!=NULL){
            next=curr->next;
            curr->next=prev;
            prev=curr;
            curr=next;
        }
        head->next=reverse(curr,c);
        return prev;
    }
//13.Detect Loop in linked list
public:
    //Function to check if the linked list has a loop.
    bool detectLoop(Node* head)
    {
        // your code here
        if(head==NULL)return false;
        Node *next=NULL;
        Node *temp=new Node(10);//dummy node;
        Node *curr=head;
        while(curr!=NULL){
            if(curr->next==NULL)return false;
            next=curr->next;
            if(curr->next==temp)return true;
            else  curr->next=temp;
            curr=next;
        }

    }
//14.Find length of Loop
//Function to find the length of a loop in the linked list.
int countNodesinLoop(struct Node *head)
{
    // Code here
    if(head==NULL)return 0;
    Node *fast=head,*slow=head;
    while(slow!=NULL&&fast!=NULL&&fast->next!=NULL){//floyd cycle detec == slow,fast pointer concept
        fast=fast->next->next;
        slow=slow->next;
        if(slow==fast){//here both pointers doesn't meet at start of loop but meet at any node in loop and then to find length of loop we count until that nodes comes again
            int count=1;
            Node *temp=slow;
            while(temp->next!=slow){
                count++;
                temp=temp->next;
            }
            return count;
        }
    }
    return 0;
}
//15.Remove loop in Linked List
int detectAndRemoveLoop(struct Node* list)
{
    struct Node *slow_p = list, *fast_p = list;

    // Iterate and find if loop exists or not
    while (slow_p && fast_p && fast_p->next) {
        slow_p = slow_p->next;
        fast_p = fast_p->next->next;

        /* If slow_p and fast_p meet at some point then there
           is a loop */
        if (slow_p == fast_p) {
            removeLoop(slow_p, list);

            /* Return 1 to indicate that loop is found */
            return 1;
        }
    }

    /* Return 0 to indicate that there is no loop*/
    return 0;
}

/* Function to remove loop.
 loop_node --> Pointer to one of the loop nodes
 head -->  Pointer to the start node of the linked list */
void removeLoop(struct Node* loop_node, struct Node* head)
{
    struct Node* ptr1 = loop_node;
    struct Node* ptr2 = loop_node;

    // Count the number of nodes in loop
    unsigned int k = 1, i;
    while (ptr1->next != ptr2) {
        ptr1 = ptr1->next;
        k++;
    }

    // Fix one pointer to head
    ptr1 = head;

    // And the other pointer to k nodes after head
    ptr2 = head;
    for (i = 0; i < k; i++)
        ptr2 = ptr2->next;

    /*  Move both pointers at the same pace,
      they will meet at loop starting node */
    while (ptr2 != ptr1) {
        ptr1 = ptr1->next;
        ptr2 = ptr2->next;
    }

    // Get pointer to the last node
    while (ptr2->next != ptr1)
        ptr2 = ptr2->next;

    /* Set the next node of the loop ending node
      to fix the loop */
    ptr2->next = NULL;
}

//16.Rotate a Linked List
public:
    //Function to rotate a linked list.
    Node* rotate(Node* head, int k)
    {
        // Your code here
        Node *t=head,*n=head;
        while(t!=NULL&&k>1){
            t=t->next;
            n=t;
            k--;
        }
        if(t==NULL)return head;
        while(n!=NULL&&n->next!=NULL){
            n=n->next;
        }
        n->next=head;
        head=t->next;
        t->next=NULL;
        return head;
    }
//17.Add two numbers represented by linked lists
 public:
    struct Node* addAtBegin(struct Node * head,int x){
        if(head==NULL){Node *n=new Node(x);head=n;return head;}
        Node *n=new Node(x);
        n->next=head;
        return n;
    }
    struct Node* reverseLL(struct Node* head){
        if(head==NULL)return head;
        Node *curr=head;
        Node *prev=NULL;
        Node *next=head->next;
        while(curr->next!=NULL){
            curr->next=prev;
            prev=curr;
            curr=next;
            next=next->next;
        }
        curr->next=prev;
        head=curr;
        return head;
    }
    //Function to add two numbers represented by linked list.
    struct Node* addTwoLists(struct Node* first, struct Node* second)
    {
        // code here
        Node *ans=NULL;
        first=reverseLL(first);
        second=reverseLL(second);
        int carry=0;
        while(first!=NULL||second!=NULL||carry==1){
            int newVal=carry;
            if(first!=NULL){newVal+=first->data;first=first->next;}
            if(second!=NULL){newVal+=second->data;second=second->next;}
            carry=newVal/10;
            newVal=newVal%10;
            ans=addAtBegin(ans,newVal);
        }
        return ans;
    }

//18.Pairwise swap of nodes in LinkeList
public:
    Node* pairWiseSwap(struct Node* head) 
    {
        // The task is to complete this method
        if(head==NULL||head->next==NULL)return head;
        Node *prev=head,*curr=head->next,*last=NULL;
        head=head->next;
        while(prev!=NULL&&prev->next!=NULL&&curr!=NULL){
            prev->next=curr->next;
            curr->next=prev;
            if(last!=NULL)last->next=curr;
            last=prev;
            prev=prev->next;
            if(prev!=NULL&&prev->next!=NULL) curr=prev->next;            
        }
        return head;
    }

//19.Check if Linked List is Palindrome
public:
    struct Node* reverseLL(struct Node* head){
        if(head==NULL)return head;
        Node *curr=head;
        Node *prev=NULL;
        Node *next=head->next;
        while(curr->next!=NULL){
            curr->next=prev;
            prev=curr;
            curr=next;
            next=next->next;
        }
        curr->next=prev;
        head=curr;
        return head;
    }
    //Function to check whether the list is palindrome.
    bool isPalindrome(Node *head)
    {
        //Your code here
        if(head==NULL) return false;
        Node *slow=head,*fast=head;
        while(fast!=NULL&&fast->next!=NULL&&fast->next->next!=NULL){
            slow=slow->next;
            fast=fast->next->next;
        }
        if(fast->next==NULL){//odd length
            slow->next=reverseLL(slow->next);
            Node * rev=slow->next;
            fast=head;
            while(fast!=slow){
                if(fast->data!=rev->data) return false;
                fast=fast->next;rev=rev->next;
            }
        }
        else {//even length
            slow->next=reverseLL(slow->next);
            Node * rev=slow->next;
            fast=head;
            while(fast!=slow->next){
                if(fast->data!=rev->data) return false;
                fast=fast->next;rev=rev->next;
            }
        }
        return true;
    }
//20.Merge Sort for Linked List
/*
Merge sort is often preferred for sorting a linked list. The slow random-access performance of a linked list makes some other algorithms (such as quicksort) perform poorly, and others (such as heapsort) completely impossible.
*/
public:
    Node* findMid(Node* head){
        if(head==NULL) return head;
        Node *slow=head,*fast=head;
        while(fast!=NULL&&fast->next!=NULL&&fast->next->next!=NULL){
            slow=slow->next;
            fast=fast->next->next;
        }
        return slow;
    }
    Node* merge(Node* l1,Node* l2){
        if(l1==NULL) return l2;
        if(l2==NULL)return l1;
        Node *head=NULL,*tail=NULL;
        if(l1->data<=l2->data){head=tail=l1;l1=l1->next;}
        else {head=tail=l2;l2=l2->next;}
        while(l1!=NULL&&l2!=NULL){
            if(l1->data<=l2->data){tail->next=l1;tail=l1;l1=l1->next;}
            else if(l1->data>l2->data){tail->next=l2;tail=l2;l2=l2->next;}
        }
        if(l1==NULL&&l2!=NULL){tail->next=l2;}
        if(l1!=NULL&&l2==NULL){tail->next=l1;}
        return head;
    }
    //Function to sort the given linked list using Merge Sort.
    Node* mergeSort(Node* head) {
        // your code here
        if(head==NULL) return head;
        if(head->next==NULL) return head;
        Node * mid=findMid(head);
        Node *head2=mid->next;
        mid->next=NULL;
        Node *l1= mergeSort(head);
        Node *l2= mergeSort(head2);
        head=merge(l1,l2);
        return head;
    }
//21.Given a linked list of 0s, 1s and 2s, sort it.
  public:
    //Function to sort a linked list of 0s, 1s and 2s.
    Node* segregate(Node *head) {
        
        // Add code here
        if(head==NULL) return NULL;
        Node *zero=NULL,*one=NULL,*t=head,*two=NULL,*z=NULL,*to=NULL,*o=NULL;
        while(t!=NULL){
            if(t->data==0){if(zero==NULL){z=zero=t;}else{zero->next=t;zero=t;} t=zero->next;zero->next=NULL;}
            else if(t->data==2){if(two==NULL){to=two=t;}else{two->next=t;two=t;} t=two->next;two->next=NULL;}
            else if(t->data==1){if(one==NULL){o=one=t;}else{one->next=t;one=t;} t=one->next;one->next=NULL;}
            
        }
        if(z!=NULL) head=z; else if(o!=NULL) head=o;else if(to!=NULL) head=to;
        if(zero!=NULL){if(o!=NULL)zero->next=o; else if(to!= NULL) zero->next=to; else zero->next=NULL;}
        if(one!=NULL){ if(to!=NULL)one->next=to;else one->next=NULL;}
        if(two!=NULL) two->next=NULL;
        return head;
    }
//22.Merge Sort on Doubly Linked List
Node *findMidDoubly(Node* head){
    if(head==NULL){return head;}
    Node *slow=head,*fast=head;
    while(fast!=NULL&&fast->next!=NULL&&fast->next->next!=NULL){
        slow=slow->next;
        fast=fast->next->next;
    }
    return slow;
    
}
Node *mergeDoubly(Node* l1,Node* l2){
    if(l1==NULL) return l2;
    if(l2==NULL) return l1;
    Node *head=NULL,*tail=NULL;
    if(l1->data<=l2->data){head=tail=l1;l1->prev=NULL;l1=l1->next;}
    else if(l1->data>l2->data){head=tail=l2;l2->prev=NULL;l2=l2->next;}
    while(l1!=NULL&&l2!=NULL){
        if(l1->data<=l2->data){tail->next=l1;l1->prev=tail;tail=l1;l1=l1->next;}
        else if(l1->data>l2->data){tail->next=l2;l2->prev=tail;tail=l2;l2=l2->next;}
    }
    if(l1!=NULL&&l2==NULL){tail->next=l1;l1->prev=tail;}
    if(l1==NULL&&l2!=NULL){tail->next=l2;l2->prev=tail;}
    return head;
}
//Function to sort the given doubly linked list using Merge Sort.
struct Node *sortDoubly(struct Node *head)
{
	// Your code here
	if(head==NULL||head->next==NULL)return head;
	Node *mid=findMidDoubly(head);
	Node *head2=mid->next;
	mid->next=NULL;
	head2->prev=NULL;
	Node *l1=sortDoubly(head);
	Node *l2=sortDoubly(head2);
	head=mergeDoubly(l1,l2);
	return head;
} 
//23.Merge K sorted linked lists
 public:
    Node* merge(Node* l1,Node* l2){
        if(l1==NULL) return l2;
        if(l2==NULL)return l1;
        Node *head=NULL,*tail=NULL;
        if(l1->data<=l2->data){head=tail=l1;l1=l1->next;}
        else {head=tail=l2;l2=l2->next;}
        while(l1!=NULL&&l2!=NULL){
            if(l1->data<=l2->data){tail->next=l1;tail=l1;l1=l1->next;}
            else if(l1->data>l2->data){tail->next=l2;tail=l2;l2=l2->next;}
        }
        if(l1==NULL&&l2!=NULL){tail->next=l2;}
        if(l1!=NULL&&l2==NULL){tail->next=l1;}
        return head;
    }
    //Function to merge K sorted linked list.
    Node * mergeKLists(Node *arr[], int K)
    {
           // Your code here
           int i=0,j;
           if(K>1) j=1;
           else return arr[0];
           while(j<K){
               arr[i]=merge(arr[i],arr[j]);
               j++;
           }
           return arr[0];
    }
//24.Intersection Point in Y Shapped Linked Lists
//Function to find intersection point in Y shaped Linked Lists.
int intersectPoint(Node* head1, Node* head2)
{
    // Your Code Here
    Node *t=head1,*p=NULL;
    int c1=0,c2=0;
    while(t!=NULL){
        t=t->next;
        c1++;
    }
    t=head2;
    while(t!=NULL){
        t=t->next;
        c2++;
    }
    int extra=abs(c1-c2);
    if(c1>=c2){t=head1;p=head2;}
    else{t=head2;p=head1;}
    while(extra>0){
        t=t->next;
        extra--;
    }
    while(t!=NULL&&p!=NULL&&t!=p){
       t=t->next;p=p->next; 
    }
    if(t!=NULL&&p!=NULL) return t->data;
    else return -1;    
}
//25.Clone a linked list with next and random pointer
public:
    Node *copyList(Node *head)
    {
        //Write your code here
        Node *h=NULL,*p=head,*n=NULL;
        while(p!=NULL){//add duplicate nodes to every original node
            n=new Node(p->data);
            n->next=p->next;
            p->next=n;
            p=p->next->next;
        }
        p=head;
        while(p!=NULL&&p->next!=NULL){//position arb of duplicates
          p->next->arb=(p->arb!=NULL)?(p->arb->next):NULL;
          p=p->next->next;
        }
        p=head;
        h=p->next;
        n=p->next;
        while(p!=NULL&&n!=NULL){//seperate duplicate list & original list
            p->next=(p->next!=NULL)?p->next->next:NULL;
            n->next=(n->next!=NULL)?n->next->next:NULL;
            p=p->next;
            n=n->next;
        }
        return h;
    }
//26.LRU Cache
//--later--\\
//-EXTRA QN:
//27.Delete a Node in Single Linked List
Node* deleteNode(Node *head,int x)
{
    //Your code here
   Node *curr=head,*prev=NULL;
   if(x==0) return head;
   if(x==1){
       curr=curr->next;
       delete(head);
       return curr;
   }
   x--;
   while(curr&&x>0){
       prev=curr;
       curr=curr->next;
       x--;
   }
   if(curr&&curr->next){
       prev->next=curr->next;
       delete(curr);
   }else if(curr&&curr->next==NULL){
       prev->next=NULL;
       delete(curr);
   }
   return head;
}

STACK:
//01.Implement stack using array
//Function to push an integer into the stack.
void MyStack :: push(int x)
{
    // Your Code
    if(top>=999)return;
    else top++;
    arr[top]=x;
    return;
    
}

//Function to remove an item from top of the stack.
int MyStack :: pop()
{
    // Your Code
    if(top<0)return -1;
    int res=arr[top];
    top--;
    return res;
}
//02.Implement Stack using Linked List
//Function to push an integer into the stack.
//trick is linked list grows like stack and not like normal way (one after another node)
void MyStack ::push(int x) 
{
    // Your code
    StackNode *n=new StackNode(x);
    if(top==NULL){top=n;n=NULL;delete n;}
    else{n->next=top;top=n;}
    return;
    
}

//Function to remove an item from top of the stack.
int MyStack ::pop() 
{
    // Your Code
    if(top==NULL)return -1;
    StackNode *t=top;
    int res=t->data;
    top=top->next;
    delete t;
    return res;
}
//03.Operations on Stack
//IT IS JAVA BASED QUESTION
// Function to insert element to stack
    public static void insert(Stack<Integer> st, int x)
    {
        // Your code here
        st.push(x);        
    }
    
    // Function to pop element from stack
    public static void remove(Stack<Integer> st)
    {
        int x =st.pop(); // Your code here        
    }
    
    // Function to return top of stack
    public static void headOf_Stack(Stack<Integer> st)
    {
        int x =st.peek(); // Your code here
        System.out.println(x + " ");
    }
    
    // Function to find the element in stack
    public static void find(Stack<Integer> st, int val)
    {    
        if(/*Your code here*/st.contains(val)){
            System.out.println("Yes");
        }
        else{
            System.out.println("No");
        }        
    }
//06.Parenthesis Checker
public:
    //Function to check if brackets are balanced or not.
    bool ispar(string x)
    {
        // Your code here
        if(x.length()%2!=0) return false;
        stack<char> st;
        for(int i=0;i<x.length();i++){
            if(x[i]=='{'||x[i]=='['||x[i]=='('){st.push(x[i]);}
            else if(st.empty()==true&&(x[i]=='}'||x[i]==']'||x[i]==')')){return false;}
            else if(x[i]=='}'){if(st.top()!='{') return false; else st.pop();}
            else if(x[i]==']'){if(st.top()!='[') return false; else st.pop();}
            else if(x[i]==')'){if(st.top()!='(') return false; else st.pop();}
        }
        if(st.empty()==true) return true;
        else return false;
    }
//07.Implement two stacks in an array
//Function to push an integer into the stack1.
void twoStacks :: push1(int x)
{
 if(top1+1==top2)return;
 top1++;
 arr[top1]=x;
}
   
//Function to push an integer into the stack2.
void twoStacks ::push2(int x)
{
 if(top1+1==top2) return;
 top2--;
 arr[top2]=x;
}
   
//Function to remove an element from top of the stack1.
int twoStacks ::pop1()
{
  if(top1==-1)return -1;
  int res=arr[top1];
  top1--;
  return res;
}

//Function to remove an element from top of the stack2.
int twoStacks :: pop2()
{
  if(top2==size) return -1;
  int res=arr[top2];
  top2++;
  return res;
}
//08.Get min at pop
//Function to push all the elements into the stack.
stack<int> _push(int arr[],int n)
{  //put all min in stack
   // your code here
   stack<int> res;
   int mini=INT_MAX;
   for(int i=0;i<n;i++){
       mini=min(mini,arr[i]);
       res.push(mini);
   }
   return res;
}

//Function to print minimum value in stack each time while popping.
void _getMinAtPop(stack<int>s)
{   //pop items in stack,stack contains all min
    // your code here
    while(s.size()>0){
        cout<<s.top()<<" ";
        s.pop();
    }  
}
//09.Delete middle element of a stack
public:
    //Function to delete middle element of a stack.
    void deleteFun(stack<int>&st,int sizeOfStack,int count){
        if(count<=0){st.pop(); return;}
        int temp=st.top();
        st.pop();
        count--;
        deleteFun(st, sizeOfStack-1,count);
        st.push(temp);
        return;
    }
    void deleteMid(stack<int>&st, int sizeOfStack)
    {
        // code here..
        if(sizeOfStack<=0) return;
        int count=(sizeOfStack%2!=0)?(sizeOfStack-(ceil(sizeOfStack+1)/2)):(sizeOfStack-(ceil(sizeOfStack)/2));
        deleteFun(st,sizeOfStack,count);
        return;
    }
//10.Infix to Postfix
 int prec(char c){
       if(c=='^'){return 3;}
       else if(c=='/'||c=='*'){return 2;}
       else if(c=='+'||c=='-'){return 1;}
       else{return -1;}
   }
   string infixToPostfix(string s) {
       // Your code here
       stack<char> st;
       string ans;
       for(int i=0;i<s.length();i++){
           if(s[i]>='a' && s[i]<='z' || s[i]>='A' && s[i]<='Z'){
               ans+=s[i]; //add the character by concatenation
           }
           else if(s[i]=='('){
               st.push(s[i]);
           }
           else if(s[i]==')'){
               while(st.top()!='('){
                   ans+=st.top();
                   st.pop();
               }
               st.pop();
           }
           else{
               while(!st.empty() && prec(s[i])<=prec(st.top())){
                   ans+=st.top();
                   st.pop();
               }
               st.push(s[i]);
           }
       }
       while(!st.empty()){
           ans+=st.top();
           st.pop();
       }
       return ans;
   }
//11.Evaluation of Postfix Expression
 public:
    int calc(int a,int b,char c){
        if(c=='/') return a/b;
        else if(c=='*') return a*b;
        else if(c=='+') return a+b;
        else if(c=='-') return a-b;
        else if(c=='^') return pow(a,b);
    }
    //Function to evaluate a postfix expression.
    int evaluatePostfix(string S)
    {
        // Your code here
        stack<int > st;
        int res=0;
        for(int i=0;i<S.length();i++){
            res=0;
            char c=S[i];
            if(c=='/'||c=='*'||c=='+'||c=='-'||c=='^'){
                int op1=st.top();st.pop();int op2=st.top();st.pop();
                res=calc(op2,op1,c);
                st.push(res);
            }
            else {st.push(int(c-48));}
        }
        res=st.top();
        st.pop();
        return res;
    }
//12.Stock span problem
void calculateSpan(int price[], int n, int S[])
{
    // Create a stack and push index of first
    // element to it
    stack<int> st;
    st.push(0);

    // Span value of first element is always 1
    S[0] = 1;

    // Calculate span values for rest of the elements
    for (int i = 1; i < n; i++) {
        // Pop elements from stack while stack is not
        // empty and top of stack is smaller than
      // price[i]
        while (!st.empty() && price[st.top()] <= price[i])
            st.pop();

        // If stack becomes empty, then price[i] is
        // greater than all elements on left of it,
        // i.e., price[0], price[1], ..price[i-1].  Else
        // price[i] is greater than elements after
        // top of stack
        S[i] = (st.empty()) ? (i + 1) : (i - st.top());

        // Push this element to stack
        st.push(i);
    }
}
//13.Next Greater Element
public:
    void reverse(vector<long long> &res){
        int i=0,j=res.size()-1;
        while(i<j){
            swap(res[i],res[j]);
            i++;j--;
        }
    }
    //Function to find the next greater element for each element of the array.
    vector<long long> nextLargerElement(vector<long long> arr, int n){
        // Your code here
        vector<long long> res;
        res.push_back(-1);
        stack<int> st;
        st.push(n-1);
        long long int nextgreater;
        for(int i=n-2;i>=0;i--){
            while(st.empty()!=true&&arr[i]>=arr[st.top()]){
                st.pop();
            }
            nextgreater=(st.empty()==true)?(-1):arr[st.top()];
            res.push_back(nextgreater);
            st.push(i);
        }
        reverse(res);
        return res;
    }
//14.Maximum Rectangular Area in a Histogram
public:
    vector<int> nextSmaller(long long int arr[],int n){
        stack<int> st;
        st.push(-1);
        vector<int > res(n);
        for(int i=n-1;i>=0;i--){
            int curr=arr[i];
            while(st.top()!=-1&&curr<=arr[st.top()]){st.pop();}
            res[i]=st.top();
            st.push(i);
        }
        return res;
    }
     vector<int> prevSmaller(long long int arr[],int n){
        stack<int> st;
        st.push(-1);
        vector<int > res(n);
        for(int i=0;i<n;i++){
            int curr=arr[i];
            while(st.top()!=-1&&curr<=arr[st.top()]){st.pop();}
            res[i]=st.top();
            st.push(i);
        }
        return res;
    }
    //Function to find largest rectangular area possible in a given histogram.
    long long getMaxArea(long long arr[], int n)
    {
        // Your code here
        vector<int> next,prev;
        next=nextSmaller(arr,n);
        prev=prevSmaller(arr,n);
        long long int length,area,height,res=INT_MIN,right;
        for(int i=0;i<n;i++){
            if(next[i]==-1){right=n;}
            else right=next[i];
            length=right-prev[i]-1;//when prev[i] is -1 then it is handled implicitly eg 6,2 prev =-1,-1 next=1,-1 so for element 2 right=2 as it is -1 so len=2-(-1)-1==2 ,hei=2,area=4;
            height=arr[i];
            area=length*height;
            res=max(res,area);
        }
        return res;
    }
//15.The Celebrity Problem
public:
    //Function to find if there is a celebrity in the party or not.
    int celebrity(vector<vector<int> >& M, int n) 
    {
        // code here 
        stack<int> st;
        for(int i=0;i<n;i++){//push all indexes (id)
            st.push(i);            
        }
        while(st.size()>1){//pick top 2 ele and check if a knows b--> b is possible candidate and a is not a celebrity else vice versa
            int a=st.top();st.pop();
            int b=st.top();st.pop();
            if(M[a][b]==1) st.push(b);
            else st.push(a);
        }
        int rem=st.top();//possible candidate
        for(int i=0;i<n;i++){//check rem's column
            if(M[rem][i]==1) return -1;
        }
        for(int i=0;i<n;i++){//check other's acquaintance with rem
            if(M[i][rem]!=1&&i!=rem)return -1;
        }
        return rem;
    }
//16.Maximum of minimum for every window size
void printMaxOfMin(int arr[], int n)
{
// Used to find previous and next smaller
    stack<int> s; 

    // Arrays to store previous and next smaller
    int left[n+1];  
    int right[n+1]; 

    // Initialize elements of left[] and right[]
    for (int i=0; i<n; i++)
    {
        left[i] = -1;
        right[i] = n;
    }

    // Fill elements of left[] using logic discussed on
    // https://www.cdn.geeksforgeeks.org/next-greater-element/
    for (int i=0; i<n; i++)
    {
        while (!s.empty() && arr[s.top()] >= arr[i])
            s.pop();

        if (!s.empty())
            left[i] = s.top();

        s.push(i);
    }

    // Empty the stack as stack is 
// going to be used for right[]
    while (!s.empty())
        s.pop();
// Fill elements of right[] using same logic
    for (int i = n-1 ; i>=0 ; i-- )
    {
        while (!s.empty() && arr[s.top()] >= arr[i])
            s.pop();

        if(!s.empty())
            right[i] = s.top();

        s.push(i);
    }

    // Create and initialize answer array
    int ans[n+1];
    for (int i=0; i<=n; i++)
        ans[i] = 0;

    // Fill answer array by comparing minimums of all
    // lengths computed using left[] and right[]
    for (int i=0; i<n; i++)
    {
        // length of the interval
        int len = right[i] - left[i] - 1;

        // arr[i] is a possible answer for this length 
        // 'len' interval, check if arr[i] is more than
        // max for 'len'
        ans[len] = max(ans[len], arr[i]);
    }

    // Some entries in ans[] may not be filled yet. Fill 
    // them by taking values from right side of ans[]
    for (int i=n-1; i>=1; i--)
        ans[i] = max(ans[i], ans[i+1]);

    // Print the result
    for (int i=1; i<=n; i++)
        cout << ans[i] << " ";
}

QUEUE:
//01.Implement Queue using array
/* 

The structure of the class is
class MyQueue {
private:
    int arr[100005];
    int front;
    int rear;

public :
    MyQueue(){front=0;rear=0;}
    void push(int);
    int pop();
};
 */

//Function to push an element x in a queue.
void MyQueue :: push(int x)
{
        // Your Code
        if(rear>=100005)return;
        arr[rear]=x;
        rear++;
        return;
}

//Function to pop an element from queue and return that element.
int MyQueue :: pop()
{
        // Your Code
        if(front==rear)return -1;
        int res=arr[front];
        front++;
        return res;
        
}
//02.Operations on Queue
public:
    // Function to insert element into the queue
    void insert(queue<int> &q, int k){
        // Your code here
        q.push(k);
    }
    
    // Function to find frequency of an element
    // return the frequency of k
    int findFrequency(queue<int> &q, int k){
        // Your code here
        int res=0,n=q.size();
        for(int i=0;i<n;i++){
            if(q.front()==k)res++;
            q.push(q.front());
            q.pop();
        }
        return res;
    }
//03.Implement Queue using Linked List
/* Structure of a node in Queue
struct QueueNode
{
    int data;
    QueueNode *next;
    QueueNode(int a)
    {
        data = a;
        next = NULL;
    }
};

And structure of MyQueue
struct MyQueue {
    QueueNode *front;
    QueueNode *rear;
    void push(int);
    int pop();
    MyQueue() {front = rear = NULL;}
}; */

//Function to push an element into the queue.
void MyQueue:: push(int x)
{
        // Your Code
        QueueNode *node=new QueueNode(x);
        if(front==NULL){front=node;rear=node; return;}
        if(rear!=NULL){rear->next=node;rear=rear->next;}
}

//Function to pop front element from the queue.
int MyQueue :: pop()
{
        // Your Code 
        QueueNode *n=front;
        if(front==NULL)return -1;
        int res=n->data;
        front=n->next;
        delete n;
        return res;
}
//04.Queue Reversal
//Function to reverse the queue.v
void fun(queue<int> &q){
    if(q.empty()==true)return;
    int temp=q.front();
    q.pop();
    fun(q);
    q.push(temp);
}
queue<int> rev(queue<int> q)
{
    // add code here
    fun(q);
    return q;
    
}
//05.Queue using two Stacks
/* The structure of the class is
class StackQueue{
private:   
    // These are STL stacks ( http://goo.gl/LxlRZQ )
    stack<int> s1;
    stack<int> s2;
public:
    void push(int);
    int pop();
}; */

//Function to push an element in queue by using 2 stacks.
void StackQueue :: push(int x)
{
    // Your Code
        while(s2.empty()!=true){s1.push(s2.top());s2.pop();}
        s2.push(x);
        while(s1.empty()!=true){s2.push(s1.top());s1.pop();}
    
}

//Function to pop an element from queue by using 2 stacks.
int StackQueue :: pop()
{
        // Your Code  
        if(s2.empty()==true)return -1;
        int res=s2.top();
        s2.pop();
        return res;
}
//06. Stack using two queues
/* The structure of the class is
class QueueStack{
private:
    queue<int> q1;
    queue<int> q2;
public:
    void push(int);
    int pop();
};
 */

//Function to push an element into stack using two queues.
void QueueStack :: push(int x)
{
        // Your Code
        while(q2.empty()!=true){q1.push(q2.front());q2.pop();}
        q2.push(x);
        while(q1.empty()!=true){q2.push(q1.front());q1.pop();}
}

//Function to pop an element from stack using two queues. 
int QueueStack :: pop()
{
        // Your Code 
        if(q2.empty()==true)return -1;
        int res=q2.front();
        q2.pop();
        return res;
}
//07.Generate Binary Numbers
//Function to generate binary numbers from 1 to N using a queue.
vector<string> generate(int N)
{
	// Your code here
	/*
	//m-1 o(nlogn)
	vector<string> ans;
	string res="";
	while(N>0){
	    int curr=N;
	    res="";
	    while(curr>0){
	      res=res+to_string(curr&1); 
	      curr=curr>>1;
	    }
	    reverse(res.begin(),res.end());
	    ans.push_back(res);
	    N--;
	}
	reverse(ans.begin(),ans.end());
	return ans;
	*/
	//m-2 -o(n)
	vector<string> ans;
	queue<string> q;
	q.push("1");
	while(N--){
	    string temp=q.front();
	    ans.push_back(temp);
	    q.pop();
	    q.push(temp+"0");
	    q.push(temp+"1");
	}
	return ans;	
}
//08.Reverse First K elements of Queue
void funRev(queue<int> &q,int k){
    if(k<=0)return;
    int temp=q.front();
    q.pop();
    k--;
    funRev(q,k);
    q.push(temp);
    return;
}
// User function Template for C++
// Function to reverse first k elements of a queue.
queue<int> modifyQueue(queue<int> q, int k) {
    // add code here.
    funRev(q,k);
    int rem=q.size()-k;
    while(rem--){
        q.push(q.front());
        q.pop();
    }
    return q;
}
//09.Circular tour
public:
  
    //Function to find starting point where the truck can start to get through
    //the complete circle without exhausting its petrol in between.
    int tour(petrolPump p[],int n)
    {
       //Your code here
       int start=0,curr_petrol=0,prev_petrol=0;
       for(int i=0;i<n;i++){
           curr_petrol+=p[i].petrol-p[i].distance;
           if(curr_petrol<0){
               start=i+1; // if pi fails then no one form p0 to pi can be start so check from i+1 and add all petrol till now as prev and do curr=o for new start and lastly check if prev+curr petrol>=0 then possible else -1
               prev_petrol+=curr_petrol;
               curr_petrol=0;               
           }
       }
       return ((curr_petrol+prev_petrol)>=0)?start:-1;
    }

DEQUE:
//01.Deque Implementations
// dq : deque in which element is to be pushed
// x : element to be pushed

// Function to push element x to the back of the deque.
void push_back_pb(deque<int> &dq, int x) {
    // Your code here
    dq.push_back(x);
}

// Function to pop element from back of the deque.
void pop_back_ppb(deque<int> &dq) {
    if (!dq.empty())/*Your code here*/dq.pop_back();
        else return;
}

// Function to return element from front of the deque.
int front_dq(deque<int> &dq) {
    if (!dq.empty())/*Your code here*/return dq.front();
        else return -1;
}

// Function to push element x to the front of the deque.
void push_front_pf(deque<int> &dq, int x) {
    // Your code here
    dq.push_front(x);
}
//02.Maximum of all subarrays of size k
public:
    //Function to find maximum of each subarray of size k.
    vector <int> max_of_subarrays(int *arr, int n, int k)
    {
        // your code here
        vector<int> ans;
        deque<int> dq;//will store index of  max of window in front
        for(int i=0;i<k;i++){//first window
            while(!dq.empty()&&arr[i]>=arr[dq.back()]){
                dq.pop_back();
            }
            dq.push_back(i);
        }
        for(int i=k;i<n;i++){//remaining windows
            ans.push_back(arr[dq.front()]);//ans of previous window
            while(!dq.empty()&&dq.front()<=i-k){dq.pop_front();}
            while(!dq.empty()&&arr[i]>=arr[dq.back()]){
                dq.pop_back();
            }
            dq.push_back(i);
        }
        ans.push_back(arr[dq.front()]);//ans of last window
        return ans;
    }


TREES:
//01.Preorder Traversal
//Function to return a list containing the preorder traversal of the tree.
void funPreOrder(Node* root,vector<int> &ans){
   if(root==NULL)return;
   ans.push_back(root->data);
   funPreOrder(root->left,ans);
   funPreOrder(root->right,ans);
}
vector <int> preorder(Node* root)
{
  // Your code here
  vector<int> ans;
  funPreOrder(root,ans);
  return ans;
}
//02.Inorder Traversal
public:
    // Function to return a list containing the inorder traversal of the tree.
    void funInOrder(Node* root,vector<int> &ans){
       if(root==NULL)return;
       funInOrder(root->left,ans);
       ans.push_back(root->data);
       funInOrder(root->right,ans);
    }
    vector <int> inOrder(Node* root)
    {
      // Your code here
      vector<int> ans;
      funInOrder(root,ans);
      return ans;
    }
//03.Postorder Traversal
//Function to return a list containing the postorder traversal of the tree.
 void funPostOrder(Node* root,vector<int> &ans){
       if(root==NULL)return;
       funPostOrder(root->left,ans);
       funPostOrder(root->right,ans);
       ans.push_back(root->data);
    }
    vector <int> postOrder(Node* root)
    {
      // Your code here
      vector<int> ans;
      funPostOrder(root,ans);
      return ans;
    }
//04.Height of Binary Tree
public:
    //Function to find the height of a binary tree.
    int height(struct Node* node){
        // code here 
      if(node==NULL)return 0;
      else return(max(height(node->left),height(node->right)))+1;
    }
//05.Determine if Two Trees are Identical
public:
    //Function to check if two trees are identical.
    bool isIdentical(Node *r1, Node *r2)
    {
        //Your Code here
        if(r1==NULL&&r2==NULL){return true;}
        else if(r1!=NULL&&r2!=NULL){
                if(r1->data==r2->data){
                    if(isIdentical(r1->left,r2->left)){
                     return isIdentical(r1->right,r2->right);   
                    }else return false;
                }else return false;
        }
        else return false;
    }
//06.Children Sum Parent
 public:
    //Function to check whether all nodes of a tree have the value 
    //equal to the sum of their child nodes.
    int isSumProperty(Node *root)
    {
     // Add your code here
     if(root==NULL) return 1;//true
     if(root!=NULL&&root->left==NULL&&root->right==NULL) return 1;//true
     int sum=0;
     if(root->left!=NULL){sum+=root->left->data;}
     if(root->right!=NULL){sum+=root->right->data;}
     return (root->data==sum&&isSumProperty(root->left)&&isSumProperty(root->right));//check data==sum and left and right subtrees also hold this then only true overall.
    }
//07.Level order traversal
 public:
    //Function to return the level order traversal of a tree.
    vector<int> levelOrder(Node* node)
    {
      //Your code here
      vector<int> ans;
      if(node==NULL)return ans;
      queue<Node*> q;
      q.push(node);
      while(!q.empty()){
          Node *temp=q.front();
          q.pop();
          ans.push_back(temp->data);
          if(temp->left!=NULL)q.push(temp->left);
          if(temp->right!=NULL)q.push(temp->right);
      }
      return ans;
    }
//08.Level order traversal Line by Line
//Function to return the level order traversal line by line of a tree.
vector<vector<int>> levelOrder(Node* node)
{
  //Your code here
  vector<vector<int>> res;
   vector<int> ans;
  if(node==NULL)return res;
  queue<Node*> q;
  q.push(node);
  int levelnodes;
  while(!q.empty()){
      levelnodes=q.size();//means this time it has to process this much(q.size()) number of items which are in this level.valid for every next level elements 
      ans.erase(ans.begin(),ans.end());
      while(!q.empty()&&levelnodes>0){
          Node *temp=q.front();
          q.pop();
          ans.push_back(temp->data);
          if(temp->left!=NULL)q.push(temp->left);
          if(temp->right!=NULL)q.push(temp->right);
          levelnodes--;
      }
      res.push_back(ans);
  }
  return res;
}
//09.Level order traversal in spiral form
//Function to return a list containing the level order traversal in spiral form.
vector<int> findSpiral(Node *node)
{
    //Your code here
   vector<int> ans;
   vector<int> res;
  if(node==NULL)return ans;
  queue<Node*> q;
  q.push(node);
  int levelnodes;
  int flag=1;//1 means tedha  0 means sidha
  while(!q.empty()){
      levelnodes=q.size();//means this time it has to process this much(q.size()) number of items which are in this level.valid for every next level elements 
      if(flag==1){
          ans.erase(ans.begin(),ans.end());
          while(!q.empty()&&levelnodes>0){
              Node *temp=q.front();
              q.pop();
              ans.push_back(temp->data);
              if(temp->left!=NULL)q.push(temp->left);
              if(temp->right!=NULL)q.push(temp->right);
              levelnodes--;
          }
          for(int i=ans.size()-1;i>=0;i--){
              res.push_back(ans[i]);
          }
      }
      else{
          while(!q.empty()&&levelnodes>0){
              Node *temp=q.front();
              q.pop();
              res.push_back(temp->data);
              if(temp->left!=NULL)q.push(temp->left);
              if(temp->right!=NULL)q.push(temp->right);
              levelnodes--;
          }
      }
      flag=(flag==0)?1:0;
  }
  return res;    
}

//10.Maximum Width of Tree
// public:
    // Function to get the maximum width of a binary tree.
    int getMaxWidth(Node* node) {
        // Your code here
      if(node==NULL)return 0;
      queue<Node*> q;
      q.push(node);
      int levelnodes,res=INT_MIN;
      while(!q.empty()){
          levelnodes=q.size();//means this time it has to process this much(q.size()) number of items which are in this level.valid for every next level elements 
          res=max(res,levelnodes);
          while(!q.empty()&&levelnodes>0){
              Node *temp=q.front();
              q.pop();
              if(temp->left!=NULL)q.push(temp->left);
              if(temp->right!=NULL)q.push(temp->right);
              levelnodes--;
          }
          
      }
      return res;
    }
//11.Check for Balanced Tree
public:
    //Function to check whether a binary tree is balanced or not.
    int funIsBalanced(Node *root){
        if(root==NULL)return 0;
        int left=funIsBalanced(root->left);
        if(left==-1)return -1;
        int right=funIsBalanced(root->right);
        if(right==-1)return -1;
        if(abs(left-right)>1)return -1;
        else return max(left,right)+1;//return height which is max for this subtree
    }
    bool isBalanced(Node *root)
    {
        //  Your Code here
        return (funIsBalanced(root)==-1)?0:1;        
    }
//12.Left View of Binary Tree
vector<int> leftView(Node *root)
{
   // Your code here
  //doing just l.o.t
   vector<int> ans;
   if(root==NULL)return ans;
   queue<Node*>q;
   q.push(root);
   int count,i;
   while(q.empty()!=true){
       count=q.size();
       i=count;
       while(!q.empty()&&count>0){
           Node *temp=q.front();
           if(count==i)ans.push_back(temp->data);
           q.pop();
           if(temp->left!=NULL)q.push(temp->left);
           if(temp->right!=NULL)q.push(temp->right);
           count--;
       }
   }
   return ans;
}
//13.Right View of Binary Tree
//Function to return list containing elements of right view of binary tree.
    vector<int> rightView(Node *root)
    {
       // Your Code here
       vector<int> t;
       vector<int> ans;
       if(root==NULL)return ans;
       queue<Node*>q;
       q.push(root);
       int count,i;
       while(q.empty()!=true){
           count=q.size();
           t.clear();
           while(!q.empty()&&count>0){
               Node *temp=q.front();
               t.push_back(temp->data);
               q.pop();
               if(temp->left!=NULL)q.push(temp->left);
               if(temp->right!=NULL)q.push(temp->right);
               count--;
           }
           if(t.size()>0){
               int n=t.size()-1;
               ans.push_back(t[n]);
           }
       }
       return ans;
    }
//14.Lowest Common Ancestor in a Binary Tree
//Function to return the lowest common ancestor in a Binary Tree.
    Node* lca(Node* root ,int n1 ,int n2 )
    {
       //Your code here 
       if(root==NULL)return NULL;
       if(root->data==n1||root->data==n2) return root;//if found return this node
       Node* left=lca(root->left,n1,n2);
       Node* right=lca(root->right,n1,n2);
       //4 cases where n1 and n2 can be there
       if(left!=NULL&&right!=NULL)return root; //both are in different halfs or subtrees :one in left and other in right
       else if(left!=NULL)return left;//both in left subtree
       else if(right!=NULL)return right;//both in right subtree
       else return NULL;//both in none
    }
//15.Diameter of Binary Tree
 // Function to return the diameter of a Binary Tree.
    int res=INT_MIN;//will store diameter
    int height(Node* root){//modify height fun
        if(root==NULL)return 0;
        int lh=height(root->left);
        int rh=height(root->right);
        res=max(res,lh+rh+1);//stores diameter(max no of nodes on this path) through this node root
        return max(lh,rh)+1;
    }
    int diameter(Node* root) {
        // Your code here
        height(root);
        return res;
    }
//16.Vertical Width of a Binary Tree
//Function to find the vertical width of a Binary Tree.
int verticalWidth(Node* root)
{
    // Code here
    //doing just l.o.t by maintaining line number
    if(root==NULL)return 0;
    queue<pair<Node*,int>> q;
    unordered_set<int> s;
    q.push({root,0});
    while(q.empty()!=true){
        Node* temp=q.front().first;
        int line=q.front().second;
        q.pop();
        s.insert(line);
        if(temp->left!=NULL){q.push({temp->left,line-1});}
        if(temp->right!=NULL){q.push({temp->right,line+1});}
    }
    return s.size();
}
//17.Mirror Tree
 public:
    // Function to convert a binary tree into its mirror tree.
    void mirror(Node* node) {
        // code here
        if(node==NULL||node->left==NULL&&node->right==NULL)return;
        mirror(node->left);
        Node* left=node->left;
        mirror(node->right);
        Node* right=node->right;
        node->left=right;
        node->right=left;
        return;
    }
//18.Check if subtree
 //Function to check if S is a subtree of tree T.
    bool compare(Node* a,Node* b){
        if(a==NULL&&b==NULL)return true;
        if(a==NULL&&b!=NULL||a!=NULL&&b==NULL)return false;
        if(a->data!=b->data)return false;
        return compare(a->left,b->left)&&compare(a->right,b->right);
    }
    bool isSubTree(Node* T, Node* S) 
    {
        // Your code here
        if(T==NULL&&S==NULL)return true;
        if(T==NULL&&S!=NULL||T!=NULL&&S==NULL)return false;
        queue<Node*> q;
        q.push(T);
        Node *curr=NULL;
        while(!q.empty()){
           curr=q.front(); 
           if(curr->data==S->data){bool flag=compare(curr,S);if(flag==true)return true;}
           q.pop();
           if(curr->left)q.push(curr->left);
           if(curr->right)q.push(curr->right);
        }
        return false;
    }
//19.Make Binary Tree From Linked List
//Function to make binary tree from linked list.
void convert(Node *head, TreeNode *&root) {
    // Your code here
    if(head==NULL)return;
    queue<TreeNode*>q;
    root=new TreeNode(head->data);
    q.push(root);
    head=head->next;
    while(!q.empty()&&head!=NULL){
        TreeNode* parent=q.front();
        q.pop();
        if(head!=NULL){
            TreeNode* leftchild=new TreeNode(head->data);
            parent->left=leftchild;
            q.push(leftchild);
            head=head->next;
        }        
        if(head!=NULL){
            TreeNode* rightchild=new TreeNode(head->data);
            parent->right=rightchild;
            q.push(rightchild);
            head=head->next;
        }        
    }    
    return;
}
//20.Binary Tree to DLL
 public: 
    //Function to convert binary tree to doubly linked list and return it.
    Node *prev,*head;
    void funbToDLL(Node* root){//just do inorder traversal and store prev
      if(root==NULL){return;} 
      funbToDLL(root->left);
      if(prev){prev->right=root;root->left=prev;prev=root;}
      else {head=root,prev=root;}
      funbToDLL(root->right);
      return;
    }
    Node * bToDLL(Node *root)
    {
        // your code here
        if(root==NULL)return root;
        prev=NULL;
        funbToDLL(root);
        prev=NULL;
        return head;
    }
//21.Binary Tree to CDLL
//Function to convert binary tree into circular doubly linked list.
    Node *prev,*h,*tail;
    void funbTreeToCList(Node *root){
        if(root==NULL)return;
        funbTreeToCList(root->left);
        if(prev){
            prev->right=root;root->left=prev;prev=root;tail=root;
        }else{prev=root;tail=root;h=root;}
        funbTreeToCList(root->right);
        return;
    }
    Node *bTreeToCList(Node *root)
    {
    //add code here.
    if(root==NULL)return root;
    prev=NULL;h=tail=NULL;
    funbTreeToCList(root);
    if(h&&tail){h->left=tail;tail->right=h;}
    return h;
    }
//22.Connect Nodes at Same Level
//Function to connect nodes at same level.
    void connect(Node *root)
    {
       // Your Code Here
       if(root==NULL)return;
       queue<Node*> q;
       q.push(root);
       while(!q.empty()){
           int count=q.size();
           while(count>0){
           Node *curr=q.front();
           q.pop();
           if(count>1){curr->nextRight=q.front();}
           else if(count==1){curr->nextRight=NULL;}
           if(curr->left){q.push(curr->left);}
           if(curr->right){q.push(curr->right);}
           count--;
           }
       }
       return;
    }
//23.Construct Binary Tree from Parent Array
//Function to construct binary tree from parent array.
    void createNode(Node *created[],int i,int parentarr[],Node** root){
        if(created[i]!=NULL)return;
        Node* n=new Node(i);
        created[i]=n;
        if(parentarr[i]==-1){*root=n;return;}
        if(created[parentarr[i]]==NULL){
            createNode(created,parentarr[i],parentarr,root);
        }
        Node* daddy=created[parentarr[i]];
        if(daddy->left==NULL){daddy->left=n;}
        else if(daddy->right==NULL){daddy->right=n;}
        return;
    }
    Node *createTree(int parentarr[], int n)
    {
        // Your code here
        Node *root=NULL;
        Node *created[n];
        for(int i=0;i<n;i++){
            created[i]=NULL;
        }
        for(int i=0;i<n;i++){
            createNode(created,i,parentarr,&root);
        }
        return root;
    }
//24.Tree from Postorder and Inorder
/* Recursive function to construct binary of size n
from Inorder traversal in[] and Postorder traversal
post[]. Initial values of inStrt and inEnd should
be 0 and n -1. The function doesn't do any error
checking for cases where inorder and postorder
do not form a tree */
Node* buildUtil(int in[], int post[], int inStrt,
	int inEnd, int* pIndex, unordered_map<int, int>& mp)
{
	// Base case
	if (inStrt > inEnd)
		return NULL;

	/* Pick current node from Postorder traversal
	using postIndex and decrement postIndex */
	int curr = post[*pIndex];
	Node* node = newNode(curr);
	(*pIndex)--;

	/* If this node has no children then return */
	if (inStrt == inEnd)
		return node;

	/* Else find the index of this node in Inorder
	traversal */
	int iIndex = mp[curr];

	/* Using index in Inorder traversal, construct
	left and right subtress */
        //we call right first since we are building right subtree since postindex is decrementing and going from right to left
	node->right = buildUtil(in, post, iIndex + 1,
							inEnd, pIndex, mp);
	node->left = buildUtil(in, post, inStrt,
						iIndex - 1, pIndex, mp);

	return node;
}

// This function mainly creates an unordered_map, then
// calls buildTreeUtil()
struct Node* buildTree(int in[], int post[], int len)
{
	// Store indexes of all items so that we
	// we can quickly find later
	unordered_map<int, int> mp;
	for (int i = 0; i < len; i++)
		mp[in[i]] = i;

	int index = len - 1; // Index in postorder
	return buildUtil(in, post, 0, len - 1,
					&index, mp);
}

//25.Foldable Binary Tree
//here we just change right subtree of root to its mirror image and compare left and right subtree.if same structrue then foldable else not.
//Function to check whether a binary tree is foldable or not.
void mirror(Node* root){ 
    if(root==NULL)return;
    if(root->left==NULL&&root->right==NULL)return;
    mirror(root->left);
    mirror(root->right);
    Node* left=root->left;
    Node* right=root->right;
    root->left=right;
    root->right=left;
    return;
}
bool isStructureSame(Node* a,Node* b){
    if(a==NULL&&b==NULL)return true;
    if(a==NULL&&b!=NULL||a!=NULL&&b==NULL)return false;
    return isStructureSame(a->left,b->left)&&isStructureSame(a->right,b->right);
}
bool IsFoldable(Node* root)
{
    // Your code goes here
    if(root==NULL)return true;
    mirror(root->right);
    bool res=isStructureSame(root->left,root->right);
    return res;
}
//26.Maximum path sum from any node
/*For each node there can be four ways that the max path goes through the node: 
1. Node only 
2. Max path through Left Child + Node 
3. Max path through Right Child + Node 
4. Max path through Left Child + Node + Max path through Right Child
The idea is to keep trace of four paths and pick up the max one in the end. An important thing to note is, root of every subtree need to return maximum path sum such that at most one child of root is involved. This is needed for parent function call. In below code, this sum is stored in max_single and returned by the recursive function
*/
// This function returns overall maximum path sum in 'res'
// And returns max path sum going through root.
int findMaxUtil(Node* root, int &res)
{
	//Base Case
	if (root == NULL)
		return 0;

	// l and r store maximum path sum going through left and
	// right child of root respectively
	int l = findMaxUtil(root->left,res);
	int r = findMaxUtil(root->right,res);

	// Max path for parent call of root. This path must
	// include at-most one child of root
	int max_single = max(max(l, r) + root->data, root->data);//max of 1 2 3 cases

	// Max Top represents the sum when the Node under
	// consideration is the root of the maxsum path and no
	// ancestors of root are there in max sum path
	int max_top = max(max_single, l + r + root->data);//max of 1 2 3 and 4

	res = max(res, max_top); // Store the Maximum Result.

	return max_single;//max of 1 2 3 since we need to return to the called node : the path to be followed in this subtree.(either node or node-anychild)
}

// Returns maximum path sum in tree with given root
int findMaxSum(Node *root)
{
	// Initialize result
	int res = INT_MIN;

	// Compute and return result
	findMaxUtil(root, res);
	return res;
}
//27.Maximum difference between node and its ancestor
Node* funmaxDiff(Node* root,int* res){
    if(root==NULL)return NULL;
    if(root->left==NULL&&root->right==NULL)return root;
    Node* left=funmaxDiff(root->left,res);
    Node* right=funmaxDiff(root->right,res);
    if(left==NULL){
        int currmaxDiff=(root->data)-(right->data);
        Node* returnvalue=((root->data)<(right->data))?root:right;
        *res=max(*res,currmaxDiff);
        return returnvalue;
    }
    if(right==NULL){
        int currmaxDiff=(root->data)-(left->data);
        Node* returnvalue=((root->data)<(left->data))?root:left;
        *res=max(*res,currmaxDiff);
        return returnvalue;
    }
    int currmaxDiff=max((root->data)-(left->data),(root->data)-(right->data));
    Node* mini=((left->data)<(right->data))?left:right;
    Node* returnvalue=((root->data)<(mini->data))?root:mini;
    *res=max(*res,currmaxDiff);
    return returnvalue;
}

int maxDiff(Node* root)
{
    // Your code here
    if(root==NULL)return 0;
    int res=INT_MIN;
    funmaxDiff(root,&res);
    return res;
}
//28.Count Number of SubTrees having given Sum
//Function to count number of subtrees having sum equal to given sum.
int funcountSubtreesWithSumX(Node* root,int* count,int x){
    if(root==NULL)return 0;
    if(root->left==NULL&&root->right==NULL){if(root->data==x) (*count)++;return root->data;}
    int left=funcountSubtreesWithSumX(root->left,count,x);
    int right=funcountSubtreesWithSumX(root->right,count,x);
    int sum=0;
    if(root->data==x&&root->left==NULL&&root->right==NULL) (*count)++;
    sum=sum+(root->data)+left+right;
    if(sum==x)(*count)++;
    return sum;
}
int countSubtreesWithSumX(Node* root, int X)
{
	// Code here
	if(root==NULL)return 0;
	int count=0;
	funcountSubtreesWithSumX(root,&count,X);
	return count;
}
//29.Serialize and Deserialize a Binary Tree
public:
    //Function to serialize a tree and return a list containing nodes of tree.
    vector<int> serialize(Node *root) 
    {
        //Your code here
        vector<int> ans;
        if(root==NULL)return ans;
        queue<Node*> q;
        q.push(root);
        ans.push_back(root->data);
        while(!q.empty()){
           int count=q.size();
           while(count>0){
               Node* curr=q.front();
               q.pop();
               if(curr->left){ ans.push_back(curr->left->data);q.push(curr->left);}
               else ans.push_back(-100);
               if(curr->right){ ans.push_back(curr->right->data);q.push(curr->right);}
               else ans.push_back(-100);
               count--;
           }
        }
        return ans;
    }
    
    //Function to deserialize a list and construct the tree.
    Node * deSerialize(vector<int> &A)
    {
       //Your code here
       if(A.size()==0)return NULL;
       int i=0;
       Node* root=new Node(A[i]);
       queue<Node*>q;
       q.push(root);
       i++;
       while(!q.empty()){
           int count=q.size();
           while(count>0){
               Node* curr=q.front();
               q.pop();
               if(A[i]!=-100){Node* n=new Node(A[i]);curr->left=n;q.push(n);}
               //else curr->left=NULL;
               i++;
               if(A[i]!=-100){curr->right=new Node(A[i]);q.push(curr->right);}
               //else curr->right=NULL;
               i++;
               count--;
           }
       }
       return root;
    }
//30.Node at distance
void getKDistance(Node* root,int k,int level,map<int,pair<Node*,bool>> &mp,int &count){
    if(root == NULL){
        return;
    }
    
    mp[level].first = root;
    mp[level].second = false;
    
    if(root->left == NULL && root->right == NULL){
        if(level-k >= 0 && mp[level-k].second != true){
            mp[level-k].second = true;
            count++;
        }
    }
    
    getKDistance(root->left,k,level+1,mp,count);
    getKDistance(root->right,k,level+1,mp,count);
}

//Function to return count of nodes at a given distance from leaf nodes.
int printKDistantfromLeaf(Node* root, int k)
{
    int count = 0;
    map<int,pair<Node*,bool>> mp;//map[pathlen,{node(for value),visited(yes or no)}]
    getKDistance(root,k,0,mp,count);
    return count;
}
//31.ZigZag Tree Traversal
 //Function to store the zig zag order traversal of tree in a list.
    vector <int> zigZagTraversal(Node* node)
    {
    	// Code here
    	 vector<int> ans;
   vector<int> res;
  if(node==NULL)return ans;
  queue<Node*> q;
  q.push(node);
  int levelnodes;
  int flag=0;//1 means tedha  0 means sidha
  while(!q.empty()){
      levelnodes=q.size();//means this time it has to process this much(q.size()) number of items which are in this level.valid for every next level elements 
      if(flag==1){
          ans.erase(ans.begin(),ans.end());
          while(!q.empty()&&levelnodes>0){
              Node *temp=q.front();
              q.pop();
              ans.push_back(temp->data);
              if(temp->left!=NULL)q.push(temp->left);
              if(temp->right!=NULL)q.push(temp->right);
              levelnodes--;
          }
          for(int i=ans.size()-1;i>=0;i--){
              res.push_back(ans[i]);
          }
      }
      else{
          while(!q.empty()&&levelnodes>0){
              Node *temp=q.front();
              q.pop();
              res.push_back(temp->data);
              if(temp->left!=NULL)q.push(temp->left);
              if(temp->right!=NULL)q.push(temp->right);
              levelnodes--;
          }
      }
      flag=(flag==0)?1:0;
  }
  return res;  
    }
//32.Maximum sum of Non-adjacent nodes
/*
For every node, we find the following:

1.Maximum sum of non-adjacent nodes including the node.
2.Maximum sum of non-adjacent nodes excluding the node.
Now, we return both the values in the recursive call. The parent node of the previously calculated node gets the maximum sum (including & excluding) the child node. Accordingly, the parent now calculates the maximum sum(including & excluding) and returns. This process continues till root node. Finally, we return the max(sum including root, sum excluding root).
*/
pair<int, int> max_sum(Node* root)
{

    if (!root)

        return { 0, 0 };
 

    auto left = max_sum(root->left);

    auto right = max_sum(root->right);
 

    int no_root_l = left.first, root_l = left.second;
 

    int no_root_r = right.first, root_r = right.second;
 

    int root_sum_max

        = max(max(root->data, root->data + no_root_l),

              max(root->data + no_root_r,

                  root->data + no_root_r + no_root_l));

    int no_root_sum_max = max(

        max(root_l, root_r),

        max(max(root_l + root_r, no_root_l + no_root_r),

            max(root_l + no_root_r, root_r + no_root_l)));
 

    return { no_root_sum_max, root_sum_max };
}
 

int getMaxSum(Node* root)
{

    pair<int, int> ans = max_sum(root);

    return max(ans.first, ans.second);
}
//Extra problems:
//Symmetric Tree
public:
    bool inOrder(struct Node* r1,struct Node* r2){
        if(r1==NULL||r2==NULL) return r1==r2;
        return (r1->data==r2->data)&&inOrder(r1->left,r2->right)&&inOrder(r1->right,r2->left);
    }
    // return true/false denoting whether the tree is Symmetric or not
    bool isSymmetric(struct Node* root)
    {
	    // Code here
	    if(root==NULL) return true;
	    return inOrder(root->left,root->right);
    }
//Print all nodes that don't have sibling
vector<int> noSibling(Node* node)
{
    // code here
    if(node==NULL) return {};
    vector<int> ans;
    queue<Node*> q;
    q.push(node);
    while(!q.empty()){
        int n=q.size();
        while(n>0){
            Node *f=q.front();
            q.pop();
            if(f->left) q.push(f->left);
            if(f->right) q.push(f->right);
            if(f->left&&!f->right){ans.push_back(f->left->data);}
            else if(!f->left&&f->right){ans.push_back(f->right->data);}
            n--;
        }
    }
    if(ans.size()==0) return {-1};
    sort(ans.begin(),ans.end());
    return ans;
}
BINARY SEARCH TREE:
//03.Insert a node in a BST
// Function to insert a node in a BST.
Node* fun(Node* root,int &key){
    if(root==NULL){return NULL;}
    if(root->data==key){return root;}
    if(root->data>key){
        Node* left=fun(root->left,key);
        if(left==NULL){root->left=new Node(key);}
        return root;
    }
    else{
        Node* right=fun(root->right,key);
        if(right==NULL){root->right=new Node(key);}
        return root;
    }
}
Node* insert(Node* root, int key) {
    // Your code here
    if(root==NULL){Node *n=new Node(key);
        root=n;
        return root;
    }
    fun(root,key);
    return root;
}
//04.Search a node in BST
// Function to search a node in BST.
bool search(Node* root, int x) {
    // Your code here
    if(root==NULL)return false;
    if(root->data==x)return true;
    if(root->data<x){return search(root->right,x);}
    else return search(root->left,x);
}
//05.Minimum element in BST
// Function to find the minimum element in the given BST.
void fun(Node* root,int &mini){
    if(root==NULL)return;
    mini=root->data;
    fun(root->left,mini);
    return;
}
int minValue(Node* root) {
    // Code 
    if(root==NULL)return -1;
    int mini;
    fun(root,mini);
    return mini;
}
//06.Find Common Nodes in two BSTs
 //Function to find the nodes that are common in both BST.
    void inorder(Node *root,auto &h){
      if(root==NULL)return;
      inorder(root->left,h);
      h.insert(root->data);
      inorder(root->right,h);
    }
    void fun(Node* root,auto &h,auto &ans){
        if(root==NULL)return;
        fun(root->left,h,ans);
        if(h.find(root->data)!=h.end()) ans.push_back(root->data);
        fun(root->right,h,ans);
    }
    vector <int> findCommon(Node *root1, Node *root2)
    {
     //Your code here
     vector<int> ans;
     if(root1==NULL&&root2==NULL)return ans;
     unordered_set<int> h;
     inorder(root1,h);
     fun(root2,h,ans);
     return ans;
    }
//07.Delete a node from BST
// Function to delete a node from BST.
Node *deleteNode(Node *root, int x) {
    // your code goes here
    if(root==NULL)return root;
    //reach to reqd node using binary search feature.
    if(root->data>x){
        root->left=deleteNode(root->left,x);
        return root;
    }
    else if(root->data<x){
        root->right=deleteNode(root->right,x);
        return root;
    }
    //reqd node reached
    if(root->left==NULL){
        Node* temp=root->right;
        delete root;
        return temp;
    }
    else if(root->right==NULL){
        Node* temp=root->left;
        delete root;
        return temp;
    }
    else{
        //both childs are there
        //plan is to delete succ node ,so reach to it and copy its data to root and delete succ. 
        Node *succparent=root;
        Node *succ=root->right;
        while(succ->left!=NULL){
            succparent=succ;
            succ=succ->left;
        }
        if(succparent==root){
            succparent->right=succ->right;
        }
        else{
            succparent->left=succ->right;
        }
        root->data=succ->data;
        delete succ;
        return root;
    }
}
//08.Lowest Common Ancestor in a BST
//Function to find the lowest common ancestor in a BST. 
Node* LCA(Node *root, int n1, int n2)
{
   //Your code here
   if(root==NULL)return NULL;
   if(root->data==n1||root->data==n2){
       return root;
   }
   Node *left=LCA(root->left,n1,n2);
   Node *right=LCA(root->right,n1,n2);
   if(left!=NULL&&right!=NULL){
       return root;
   }
   else if(left!=NULL){
       return left;
   }
   else if(right!=NULL){
       return right;
   }
}
//09.Print BST elements in given range
public:
  void helper(Node *root,int low,int high,vector<int>& ans){
      if(root==NULL)return;
      if(root->data>=low&&root->data<=high){
          ans.push_back(root->data);
          helper(root->left,low,high,ans);
          helper(root->right,low,high,ans);
      }
      else if(root->data>high){
          helper(root->left,low,high,ans);
      }
      else if(root->data<low){
          helper(root->right,low,high,ans);
      }
      
  }
    vector<int> printNearNodes(Node *root, int low, int high) {
        //code here   
        vector<int> ans;
        helper(root,low,high,ans);
        sort(ans.begin(),ans.end());
        return ans;
        
    }
//10.Pair Sum in BST
void inorder(Node *root,vector<int> & ans){
        if(root==NULL)return;
        inorder(root->left,ans);
        ans.push_back(root->data);
        inorder(root->right,ans);
    }
    // root : the root Node of the given BST
    // target : the target sum
    int isPairPresent(struct Node *root, int target)
    {
    //add code here.
        if(root==NULL) return 0;
        vector<int> ans;
        inorder(root,ans);
        unordered_set<int> h;
        for(auto i: ans){
            if(h.find(target-i)!=h.end()){return 1;}
            h.insert(i);
        }
        return 0;
    }
//11.Smaller on Right
later
//12.Floor in BST
int floor(Node* root, int key)
{
    if (!root)
        return INT_MAX;
 
    /* If root->data is equal to key */
    if (root->data == key)
        return root->data;
 
    /* If root->data is greater than the key */
    if (root->data > key)
        return floor(root->left, key);
 
    /* Else, the floor may lie in right subtree
      or may be equal to the root*/
    int floorValue = floor(root->right, key);
    return (floorValue <= key) ? floorValue : root->data;
}
//13.Ceil in BST
// User function Template for C++
int helper(Node *root,int &key,int& ans){
    if(root==NULL)return -1;
    if(root->data==key){
        ans=key;
        return key;
    }
    else if(root->data>key){
        int l=helper(root->left,key,ans);
        ans=(key<=l)?l:root->data;
        return ans;
    }
    else if(root->data<key){
        return helper(root->right,key,ans);
    }
}
// Function to return the ceil of given number in BST.
int findCeil(Node* root, int input) {
    if (root == NULL) return -1;

    // Your code here
    int ans=INT_MIN;
    ans=helper(root,input,ans);
    if(ans==-1)return -1;
    return ans;
}
//14.Vertical Traversal of Binary Tree
void lot(Node *root,auto & h){
        queue<pair<Node*,int>> q;
        q.push({root,0});
        h[0].push_back(root->data);
        while(q.empty()!=true){
            int size=q.size();
            while(size>0){
                pair<Node*,int> front=q.front();
                q.pop();
                if(front.first->left){
                    q.push({front.first->left,front.second-1});
                    h[front.second-1].push_back(front.first->left->data);
                }
                if(front.first->right){
                    q.push({front.first->right,front.second+1});
                    h[front.second+1].push_back(front.first->right->data);
                }
                size--;
            }
        }
    }
    //Function to find the vertical order traversal of Binary Tree.
    vector<int> verticalOrder(Node *root)
    {
        //Your code here
        if(root==NULL)return {-1};
        map<int,list<int>> h;
        lot(root,h);
        vector<int> ans;
        for(auto i:h){
            for(auto j:i.second)
              ans.push_back(j);
        }
        return ans;
    }
//15.Top View of Binary Tree
public:
    void lot(Node *root,auto & h){ //same like vertical traversal just store top node value(which will be first node seen for that index position from top) instead of list of values.
        queue<pair<Node*,int>> q;
        q.push({root,0});
        h[0]=root->data;
        while(q.empty()!=true){
            int size=q.size();
            while(size>0){
                pair<Node*,int> front=q.front();
                q.pop();
                if(front.first->left){
                    q.push({front.first->left,front.second-1});
                    if(h.find(front.second-1)==h.end()){
                       h[front.second-1]=front.first->left->data;
                    }
                }
                if(front.first->right){
                    q.push({front.first->right,front.second+1});
                    if(h.find(front.second+1)==h.end()){
                       h[front.second+1]=front.first->right->data;
                    }
                }
                size--;
            }
        }
    }
   
    //Function to return a list of nodes visible from the top view 
    //from left to right in Binary Tree.
    vector<int> topView(Node *root)
    {
        //Your code here
        if(root==NULL)return {-1};
        vector<int> ans;
        map<int,int> h;
        lot(root,h);
        for(auto i:h){
            ans.push_back(i.second);
        }
        return ans;
    }
//16.Bottom View of Binary Tree
void lot(Node *root,auto & h){ //same like vertical traversal just store latest or bottom most node value(which will be bottom most node seen for that index position from bottom) instead of list of values.
        queue<pair<Node*,int>> q;
        q.push({root,0});
        h[0]=root->data;
        while(q.empty()!=true){
            int size=q.size();
            while(size>0){
                pair<Node*,int> front=q.front();
                q.pop();
                if(front.first->left){
                    q.push({front.first->left,front.second-1});
                    h[front.second-1]=front.first->left->data;
                }
                if(front.first->right){
                    q.push({front.first->right,front.second+1});
                    h[front.second+1]=front.first->right->data;
                }
                size--;
            }
        }
    }
    vector <int> bottomView(Node *root) {
         //Your code here
        if(root==NULL)return {-1};
        vector<int> ans;
        map<int,int> h;
        lot(root,h);
        for(auto i:h){
            ans.push_back(i.second);
        }
        return ans;
    }
//17.Check for BST
//Function to check whether a Binary Tree is BST or not.
    bool checkSorted(vector<int> &ans){
        for(int i=1;i<ans.size();i++){
            if((ans[i]-ans[i-1])<0) return false;
        }
        return true;
    }
    void inorder(Node *root,vector<int> &ans){
        if(root==NULL) return;
        inorder(root->left,ans);
        ans.push_back(root->data);
        inorder(root->right,ans);
    }
    bool isBST(Node* root) 
    {
        // Your code here
        vector<int> ans;
        inorder(root,ans);
        return checkSorted(ans);
    }
//18.Find the Closest Element in BST
void helper(Node *root,int k,int &ans){
        if(root==NULL){
            return;
        }
        if(root->data>k){
            int diff=abs(root->data-k);
            ans=min(ans,diff);
            helper(root->left,k,ans);
        }
        else if(root->data<k){
            int diff=abs(root->data-k);
            ans=min(ans,diff);
            helper(root->right,k,ans);
        }
        else if(root->data==k){
            ans=min(ans,0);
        }
    }
    //Function to find the least absolute difference between any node
	//value of the BST and the given integer.
    int minDiff(Node *root, int K)
    {
        //Your code here
        if(root==NULL)return 0;
        int ans=INT_MAX;
        helper(root,K,ans);
        return ans;
    }
//19.Convert Level Order Traversal to BST
//User function Template for C++
struct NodeDetails{
    Node * ptr;
    int min;
    int max;
    NodeDetails(Node* p){
        this->ptr=p;
        min=INT_MIN;
        max=INT_MAX;
    }
};

//Function to construct the BST from its given level order traversal.
Node* constructBst(int arr[], int n)
{
    // Code here
    if(n==0) return NULL;
    int i=0;
    Node *root=new Node(arr[i]);
    i++;
    NodeDetails *rt=new NodeDetails(root);
    queue<NodeDetails*> q;
    q.push(rt);
    while(i<n){
        NodeDetails *front=q.front();
        q.pop();
        if(i<n&&((arr[i]<front->ptr->data)&&(arr[i]>front->min))){
            Node *left=new Node(arr[i]);
            i++;
            NodeDetails *l=new NodeDetails(left);
            l->min=front->min;
            l->max=front->ptr->data;
            q.push(l);
            front->ptr->left=left;
        }
        if(i<n&&((arr[i]>front->ptr->data)&&(arr[i]<front->max))){
            Node *right=new Node(arr[i]);
            i++;
            NodeDetails *r=new NodeDetails(right);
            r->max=front->max;
            r->min=front->ptr->data;
            q.push(r);
            front->ptr->right=right;
        }
    }
    return root;
}
//20.Count BST nodes that lie in a given range
void helper(Node *root,int &l,int &h,int &ans){
        if(root==NULL)return;
        if(root->data>=l&&root->data<=h){
            ans++;
            helper(root->left,l,h,ans);
            //v
            helper(root->right,l,h,ans);
        }else if(root->data<l){
            helper(root->right,l,h,ans);
        }else if(root->data>h){
            helper(root->left,l,h,ans);
        }
    }
    int getCount(Node *root, int l, int h)
    {
      // your code goes here  
      if(root==NULL)return -1;
      int ans=0;
      helper(root,l,h,ans);
      return ans;
    }
//21.Preorder to Postorder
public:
    int preIndex=0;
    Node* helper(int in[],int pre[],int is,int ie){
        if(is>ie)return NULL;
        int inIndex;
        Node *root=new Node(pre[preIndex]);
        preIndex++;
        for(int i=is;i<=ie;i++){
            if(in[i]==root->data){
                inIndex=i;
                break;
            }
        }
        root->left=helper(in,pre,is,inIndex-1);
        root->right=helper(in,pre,inIndex+1,ie);
        return root;
    }
    Node* buildTree(int in[],int pre[], int n)
    {
        // Code here
       
       return helper(in,pre,0,n-1);
    }
//22.Merge two BST 's
void inorder(Node* root,vector<int>& ans){
        if(root==NULL)return;
        inorder(root->left,ans);
        ans.push_back(root->data);
        inorder(root->right,ans);
    }
    void mergefun(vector<int>& a,vector<int>& b,vector<int> &ans){
        int i=0,j=0,k=0,s1=a.size(),s2=b.size();
        while(i<s1&&j<s2){
            if(a[i]<b[j]){ans.push_back(a[i]);i++;}
            else if(a[i]>b[j]){ans.push_back(b[j]);j++;}
            else if(a[i]=b[j]){ans.push_back(a[i]);ans.push_back(b[j]);i++;j++;}
        }
        while(i<s1){
            ans.push_back(a[i]);i++;
        }
        while(j<s2){
            ans.push_back(b[j]);j++;
        }
    }
    //Function to return a list of integers denoting the node 
    //values of both the BST in a sorted order.
    vector<int> merge(Node *root1, Node *root2)
    {
       //Your code here
       vector<int> a,b,ans;
       inorder(root1,a);
       inorder(root2,b);
       mergefun(a,b,ans);
       return ans;
    }
//23.Fixing Two nodes of a BST
 public:
   /*first store inorder and then two cases:
   1. The swapped nodes are not adjacent in the in-order traversal of the BST.
     For example, Nodes 5 and 25 are swapped in {3 5 7 8 10 15 20 25}. 
     The inorder traversal of the given tree is 3 25 7 8 10 15 20 5
    Observe carefully, during inorder traversal, 
    find node 7 is smaller than the previously visited node 25.
    Here save the context of node 25 (previous node).
    Again, find that node 5 is smaller than the previous node 20.
    This time, save the context of node 5 (the current node ).
    Finally, swap the two nodes values.
    2. The swapped nodes are adjacent in the inorder traversal of BST.
      For example, Nodes 7 and 8 are swapped in {3 5 7 8 10 15 20 25}. 
      The inorder traversal of the given tree is 3 5 8 7 10 15 20 25 
      Here only one point exists where a node value is smaller than the previous node value.
      e.g. node 7 is smaller than node 8. 
    */

    void inorder(Node* root,vector<Node*>& ans){
        if(root==NULL)return;
        inorder(root->left,ans);
        ans.push_back(root);
        inorder(root->right,ans);
    }
    void correctBST( struct Node* root )
    {
        // add code here.
        vector<Node*> ans;
        inorder(root,ans);
        int count=0;
        Node *temp1,*temp2,*prev,*last;
        for(auto i=ans.begin()+1;i!=ans.end();i++){
            if(((*i)->data)<((*(i-1))->data)){
                if(count==0){prev=(*(i-1));temp1=(*i);count++;}
                else if(count==1){temp2=(*i);count++;}
            }
        }
        if(count==1){
            prev->data=prev->data+temp1->data;
            temp1->data=prev->data-temp1->data;
            prev->data=prev->data-temp1->data;
        }
        else if(count==2){
            prev->data=prev->data+temp2->data;
            temp2->data=prev->data-temp2->data;
            prev->data=prev->data-temp2->data;
        }
        
    }
//EXTRA:
//Kth largest element in BST
public:
    int ans=0;
    void postOrder(Node *root,int k,int &curr){
        if(root==NULL)return;
        postOrder(root->right,k,curr);
        curr++;
        if(curr==k){ans=root->data;return;}
        postOrder(root->left,k,curr);
    }
    int kthLargest(Node *root, int K)
    {
        //Your code here
        if(root==NULL) return -1;
        int curr=0;
        postOrder(root,K,curr);
        return ans;
    }

HEAP:
//01.Binary Heap Operations
/*The structure of the class is
struct MinHeap
{
    int *harr;
    int capacity, heap_size;
    MinHeap(int cap) {heap_size = 0; capacity = cap; harr = new int[cap];}
    int extractMin();
    void deleteKey(int i);
    void insertKey(int k);
    int parent(int i);
    int left(int i);
    int right(int i);
};*/
//Function to extract minimum value in heap and then to store 
//next minimum value at first index.
int MinHeap::extractMin() 
{
    // Your code here
    if(heap_size<=0)return -1;
    int temp=harr[0];
    harr[0]=harr[heap_size-1];
    harr[heap_size-1]=temp;
    heap_size--;
    MinHeapify(0);
    return harr[heap_size];
}

//Function to delete a key at ith index.
void MinHeap::deleteKey(int i)
{
    // Your code here
    if((heap_size<=0)||(i>=heap_size))return;
    decreaseKey(i,INT_MIN);
    extractMin();;
}

//Function to insert a value in Heap.
void MinHeap::insertKey(int k) 
{
    // Your code here
    if(heap_size<capacity){
        harr[heap_size++]=k;
        for(int i=heap_size-1;i>0&&harr[i]<harr[parent(i)];){
            int temp=harr[parent(i)];
            harr[parent(i)]=harr[i];
            harr[i]=temp;
            i=parent(i);
        }
    }
    
}

//Function to change value at ith index and store that value at first index.
void MinHeap::decreaseKey(int i, int new_val) 
{
    harr[i] = new_val;
    while (i != 0 && harr[parent(i)] > harr[i]) {
        swap(harr[i], harr[parent(i)]);
        i = parent(i);
    }
}

/* You may call below MinHeapify function in
   above codes. Please do not delete this code
   if you are not writing your own MinHeapify */
void MinHeap::MinHeapify(int i) 
{
    int l = left(i);
    int r = right(i);
    int smallest = i;
    if (l < heap_size && harr[l] < harr[i]) smallest = l;
    if (r < heap_size && harr[r] < harr[smallest]) smallest = r;
    if (smallest != i) {
        swap(harr[i], harr[smallest]);
        MinHeapify(smallest);
    }
}
//02.Heap Sort
public:
    int left(int i){return (2*i)+1;}
    int right(int i){return (2*i)+2;}
    int parent(int i){return floor((i-1)/2);}
    //Heapify function to maintain heap property.
    void Maxheapify(int arr[], int n, int i)  
    {
      // Your Code Here
      int largest=i;
      int l=left(i);
      int r=right(i);
      if(l<n&&arr[l]>arr[largest]){
          largest=l;
      }
      if(r<n&&arr[r]>arr[largest]){
          largest=r;
      }
      if(largest!=i){
          swap(arr[largest],arr[i]);
          Maxheapify(arr,n,largest);
      }
    }
    //Function to build a Heap from array.
    void buildHeap(int arr[], int n)  
    { 
    // Your Code Here
        for(int i=n/2-1;i>=0;i--){
            Maxheapify(arr,n,i);
        }
    }
    
    //Function to sort an array using Heap Sort.
    void heapSort(int arr[], int n)
    {
        //code here
        buildHeap(arr,n);
        int t=n;
        for(int i=n-1;i>=0;i--){
            swap(arr[0],arr[i]);
            Maxheapify(arr,i,0);
        }
    }
//03.K largest elements
//Function to return k largest elements from an array.
    vector<int> kLargest(int arr[], int n, int k)
    {
        // code here
        if(n<0) return {-1};
        if(k>n) return{-1};
        priority_queue<int> pq(arr,arr+n);
        vector<int> ans;
        for(int i=0;i<k;i++){
            ans.push_back(pq.top());
            pq.pop();
        }
        return ans;
    }

//05.Kth smallest element
 public:
    // arr : given array
    // l : starting index of the array i.e 0
    // r : ending index of the array i.e size-1
    // k : find kth smallest element and return using this function
    int kthSmallest(int arr[], int l, int r, int k) {
        //code here
        priority_queue<int> pq(arr,arr+r+1);
        int reqd=(r+1)-k+1;
        while(reqd>1){
            pq.pop();
            reqd--;
        }
        return pq.top();
    }
//06. Kth largest element in a stream
vector<int> kthLargest(int k, int arr[], int n) {
        // code here
        priority_queue<int,vector<int>,greater<int>> pq;
        vector<int> ans;
        for(int i=0; i<n; i++)
        {
            pq.push(arr[i]);
            if(pq.size() < k)
            ans.push_back(-1);
            else if(pq.size() == k)
            ans.push_back(pq.top());
            else
            {
                pq.pop();
                ans.push_back(pq.top());
            }
        }
        return ans;
    }
//07.K Most occurring elements
 static bool comp(pair<int,int> a,pair<int,int> b){
        if(a.second>b.second){
            return true;
        }else if(a.second==b.second){
            return a.first>b.first;
        }else return false;
    }
    vector<int> topK(vector<int>& nums, int k) {
        // Code here
        unordered_map<int,int> h;
        vector<pair<int,int>> v;
        vector<int> ans;
        for(auto i: nums){
            h[i]++;
        }
        for(auto i:h){
            v.push_back({i.first,i.second});
        }
        sort(v.begin(),v.end(),comp);
        for(auto i:v){
            if(k>0){
            ans.push_back(i.first);
            k--;
            }else break;
        }
        return ans;
    }
//08.Minimum Cost of ropes
//Function to return the minimum cost of connecting the ropes.
    long long minCost(long long arr[], long long n) {
        // Your code here
        priority_queue<long long int,vector<long long int>,greater<long long int>> pq(arr,arr+n);
        long long cost=0,currcost=0;
        if(pq.size()<=1) return 0;
        while(pq.size()>1){
            currcost=0;
            currcost+=pq.top();
            pq.pop();
            currcost+=pq.top();
            pq.pop();
            cost+=currcost;
            pq.push(currcost);
        }
        return cost;
    }
//09.Nearly sorted
 //Function to return the sorted array.
    vector <int> nearlySorted(int arr[], int num, int K){
        // Your code here
        priority_queue<int,vector<int>,greater<int>> pq;
        vector<int> ans;
        for(int i=0;i<num;i++){
            pq.push(arr[i]);
            if(pq.size()>K){
                ans.push_back(pq.top());
                pq.pop();
            }
        }
        while(pq.empty()!=true){
            ans.push_back(pq.top());
            pq.pop();
        }
        return ans;
    }
//10.Merge k Sorted Arrays
struct Triplet{
    int val;
    int arraypos;
    int valuepos;
    Triplet(int v,int ap,int vp){
        this->val=v;
        this->arraypos=ap;
        this->valuepos=vp;
    }
};
struct mycomp{
    bool operator()(Triplet &a,Triplet &b){
        return a.val>b.val;
    }
};
class Solution
{
    public:
    //Function to merge k sorted arrays.
   /*
   //m-1 -o(nlogn)  time-0.4 sec
    vector<int> mergeKArrays(vector<vector<int>> arr, int K)
    {
        //code here
        vector<int> ans;
        priority_queue<int,vector<int>,greater<int>> pq;
        for(int i=0;i<arr.size();i++){
            for(int j=0;j<arr[i].size();j++){
                pq.push(arr[i][j]);
            }
        }
        while(pq.empty()!=true){
            ans.push_back(pq.top());
            pq.pop();
        }
        return ans;
        
    }
    */
    // m-2 -o(nklogk)  time-0.33 sec
    vector<int> mergeKArrays(vector<vector<int>> arr, int K){
        priority_queue<Triplet,vector<Triplet>,mycomp> pq;
        vector<int> ans;
        int row=arr.size();
        for(int i=0;i<row;i++){
            Triplet t(arr[i][0],i,0);
            pq.push(t);
        }
        while(pq.empty()!=true){
            Triplet mini=pq.top();
            pq.pop();
            int val=mini.val;
            ans.push_back(val);
            int ap=mini.arraypos;
            int vp=mini.valuepos;
            if((vp+1)<arr[ap].size()){
                Triplet next(arr[ap][vp+1],ap,(vp+1));
                pq.push(next);
            }
        }
        return ans;
    }
    
};
//11.Rearrange characters
string rearrangeString(string str)
    {
        //code here
        int n=str.length();
        if(n==0)return "-1";
        int chars[26]={0};
        char maxchar;
        int maxcount=0;
        for(auto i:str){
            chars[i-'a']+=1;
            if(chars[i-'a']>((n+1)/2)) return "-1";
            if(chars[i-'a']>maxcount){maxcount=chars[i-'a'];maxchar=i;}
        }
        int ind=0;
        string res(n,' ');
        while(maxcount>0){
            res[ind]=maxchar;
            ind+=2;
            maxcount--;
            chars[maxchar-'a']--;
        }
        for(int i=0;i<26;i++){
                while(chars[i]>0){
                    ind=(ind>=n)?1:ind;
                    res[ind]=i+'a';
                    ind+=2;
                    chars[i]--;
                }
        }
        return res;
    }
//12.Find median in a stream
public:
    //time:o(nlogn) space :o(n)
    priority_queue<int> maxheap;//for left  to store all elements=<expected median)
    priority_queue<int,vector<int>,greater<int>> minheap;//for right to store all elements>expected median
    //Function to insert heap.
    void insertHeap(int &x)
    {
     if(maxheap.size()==0||maxheap.top()>x){
         maxheap.push(x);
     }else minheap.push(x);
     balanceHeaps();
    }
    
    //Function to balance heaps.
    void balanceHeaps()
    {
        if(maxheap.size()>minheap.size()+1){
            int temp=maxheap.top();
            maxheap.pop();
            minheap.push(temp);
        }else if(minheap.size()>maxheap.size()){
            int temp=minheap.top();
            minheap.pop();
            maxheap.push(temp);
        }
    }
    
    //Function to return Median.
    double getMedian()
    {
        if(maxheap.size()==minheap.size()){
            return double(maxheap.top()+minheap.top())/2;
        }else return maxheap.top();
    }

GRAPH:
//01.Print adjacency list
   // Function to return the adjacency list for each vertex.
    vector<vector<int>> printGraph(int V, vector<int> adj[]) {
        // Code here
        vector<vector<int>> adjlist(V,{0});
        for(int i=0;i<V;i++){
            adjlist[i][0]=i;
            for(auto j:adj[i]){
                adjlist[i].push_back(j);
            }
        }
        return adjlist;
    }
//02.BFS of graph
 // Function to return Breadth First Traversal of given graph.
    vector<int> bfsOfGraph(int V, vector<int> adj[]) {
        // Code here
        unordered_map<int,int> h;
        vector<int> ans;
        queue<int> q;
        q.push(0);
        h[0]++;
        ans.push_back(0);
        while(q.empty()!=true){
            int front=q.front();
            q.pop();
            for(auto it:adj[front]){
                if(h[it]<=0){
                    h[it]++;
                    ans.push_back(it);
                    q.push(it);
                }
            }
        }
        return ans;
    }
//03.DFS of Graph
 // Function to return a list containing the DFS traversal of the graph.
    vector<int> dfsOfGraph(int V, vector<int> adj[]) {
        // Code here
        stack<int> st;
        vector<int> ans;
        st.push(0);
        unordered_map<int,int> h;//visited array
        while(st.empty()!=true){
            int t=st.top();
            st.pop();
            if(h[t]<=0){
                h[t]=1;
                ans.push_back(t);
                for(int it=adj[t].size()-1;it>=0;it--){//we add connected elements in reverse order
                    if(h[adj[t][it]]<=0){
                        st.push(adj[t][it]);
                    }
                }
            }
        }
        return ans;
    }
//04.Find the number of islands
void checkneighbours(vector<vector<char>> &grid,int &m,int &n,int i,int j){
       if(i>=m||i<0||j>=n||j<0) return;
       if(grid[i][j]=='0') return;//if we are using visted array then ,also check if visited[i][j]==true
       grid[i][j]='0';//alternative of visited array is to mark it '0' which will mean it will be caught in base condn and will be treated as visited.
       checkneighbours(grid,m,n,i-1,j-1);
       checkneighbours(grid,m,n,i-1,j);
       checkneighbours(grid,m,n,i-1,j+1);
       checkneighbours(grid,m,n,i,j-1);
       checkneighbours(grid,m,n,i,j+1);
       checkneighbours(grid,m,n,i+1,j-1);
       checkneighbours(grid,m,n,i+1,j);
       checkneighbours(grid,m,n,i+1,j+1);
   }
    // Function to find the number of islands.
    int numIslands(vector<vector<char>>& grid) {
        // Code here
        int m=grid.size(),n=grid[0].size(),count=0;
        //vector<vector<bool>> visited(m,{false});
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){// if we are using visted array then ,also check &&visited[i][j]==false
                    count++;
                    checkneighbours(grid,m,n,i,j);
                }
            }
        }
        return count;
    }
//05.Detect cycle in an undirected graph
//mark curr node visited and for each of its child check if they are visited but their parent is not curr node. for such case it means there is an cycle in graph.if it was parent node then means the edge is normal undirected edge which leads 2 calls i.e form child to parent and parent to child thus doesn't means a cycle.
void dfs(int curr,int parent,vector<int> adj[],vector<bool> &visited,int &flag){
       visited[curr]=true;
       for(auto i:adj[curr]){
           if(visited[i]==false){
               dfs(i,curr,adj,visited,flag);
           }else if(visited[i]==true&&i!=parent){
               flag=1;
               return;
           }
       }
   }
    // Function to detect cycle in an undirected graph.
    bool isCycle(int V, vector<int> adj[]) {
        // Code here
        int flag=0;
        vector<bool> visited(V,false);
        for(int i=0;i<V;i++){
            if(visited[i]==false){
                dfs(i,-1,adj,visited,flag);
            }
        }
        return bool(flag);
    }
//06.Detect cycle in a directed graph
 //Kahn's algo like topological sort we do extraction & if extraction not possible means dependency and thus means cycle. 
    // Function to detect cycle in a directed graph.
    bool isCyclic(int V, vector<int> adj[]) {
        // code here
        vector<int> indegree(V,0);
        queue<int> q;
        int count=0;
        for(int i=0;i<V;i++){
            for(auto j:adj[i]){
                indegree[j]+=1;
            }
        }
        for(int i=0;i<V;i++){
            if(indegree[i]==0){
                q.push(i);
            }
        }
        while(q.empty()!=true){
            int front=q.front();
            q.pop();
            count++;
            for(auto child:adj[front]){
                indegree[child]--;
                if(indegree[child]==0){
                    q.push(child);
                }
            }
        }
        if(count==V) return false;
        else return true;
    }
//07.Find whether path exist
 bool dfs(vector<vector<int>>& grid,int i,int j){
        if(i<0||i>=grid.size()||j<0||j>=grid[0].size())return false;
        if(grid[i][j]==0) return false;
        if(grid[i][j]==2) return true;
        grid[i][j]=0;//to mark curr box as  visited hence next time it will be trapped in base case and won't apply dfs on it.
        return dfs(grid,i-1,j)||dfs(grid,i,j-1)||dfs(grid,i,j+1)||dfs(grid,i+1,j);
    }
    //Function to find whether a path exists from the source to destination.
    bool is_Possible(vector<vector<int>>& grid) 
    {
        //code here
        for(int i=0;i<grid.size();i++){
            for(int j=0;j<grid[i].size();j++){
                if(grid[i][j]==1){
                   return dfs(grid,i,j);
                }
            }
        }
        
    }
//08.Topological sort
//Function to return list containing vertices in Topological order. 
	vector<int> topoSort(int V, vector<int> adj[]) 
	{
	    // code here
	    vector<int> indegree(V,0),ans;
	    queue<int> q;
	    for(int i=0;i<V;i++){
	        for(auto j:adj[i]){
	            indegree[j]++;
	        }
	    }
	    for(int i=0;i<V;i++){
	        if(indegree[i]==0){
	            q.push(i);
	            ans.push_back(i);
	        }
	    }
	    while(q.empty()!=true){
	        int front=q.front();
	        q.pop();
	        for(auto child:adj[front]){
	            indegree[child]--;
	            if(indegree[child]==0){
	                q.push(child);
	                ans.push_back(child);
	            }
	        }
	    }
	    return ans;
	}
//09.Level of Nodes
/* //level of nodes in a binary tree
int lot(Node *root,int &target){
        if(root->data==target)return 1;
        queue<Node*> q;
        q.push(root);
        int level=1;
        while(q.empty()!=true){
            int size=q.size();
            level++;
            while(size>0){
                Node* front=q.front();
                q.pop();
                if(front->left){if(front->left->data==target)return level; q.push(front->left);}
                if(front->right){if(front->right->data==target)return level; q.push(front->right);}
                size--;
            }
        }
        return 0;
    }
    // function should return level of the target node
    int getLevel(struct Node *node, int target)
    {
    	//code here
    	if(node==NULL)return -1;
    	return lot(node,target);
    }
*/
//level of node in graph
int lot(int v,vector<int> adj[],int target){
	    if(target==0) return 0;
        queue<int> q;
        q.push(0);
        unordered_map<int,bool> visited;
        int level=0;
        while(q.empty()!=true){
            int size=q.size();
            level++;
            while(size>0){
                int front=q.front();
                q.pop();
                for(auto child:adj[front]){
                if(visited[child]==false){if(child==target)return level; q.push(child); visited[child]=true;}
                if(visited[child]==false){if(child==target)return level; q.push(child);visited[child]=true;}
                }
                size--;
            }
        }
        return -1;
    }
	//Function to find the level of node X.
	int nodeLevel(int V, vector<int> adj[], int X) 
	{
	    // code here
	    if(V==0) return -1;
	    return lot(V,adj,X);
	}
//10.Possible paths between 2 vertices
void dfs(int v,vector<int> adj[],int currentsource,int &destination,int & ans){
        if(currentsource==destination){
            ans++;
            return;
        }
        for(auto child:adj[currentsource]){
            dfs(v,adj,child,destination,ans);
        }
    }
    // Function to count paths between two vertices in a directed graph.
    int countPaths(int V, vector<int> adj[], int source, int destination) {
        // Code here
        int ans=0;
        dfs(V,adj,source,destination,ans);
        return ans;
    }
//11.X Total Shapes
void dfs(vector<vector<char>>& grid,int row,int col){
        if(row<0||row>=grid.size()||col<0||col>=grid[0].size()){
            return;
        }
        if(grid[row][col]!='X'){
            return;
        }
        grid[row][col]='Y';
        dfs(grid,row-1,col);
        dfs(grid,row,col-1);
        dfs(grid,row,col+1);
        dfs(grid,row+1,col);

    }
    //Function to find the number of 'X' total shapes.
    int xShape(vector<vector<char>>& grid) 
    {
        // Code here
        int ans=0;
        for(int i=0;i<grid.size();i++){
            for(int j=0;j<grid[0].size();j++){
                if(grid[i][j]=='X'){
                  dfs(grid,i,j);
                  ans++;
                }
            }
        }
        return ans;
    }
//12. Distance of nearest cell having 1
  public:
    /* TLE SOLN
    void dfs(vector<vector<int>> grid,int i,int j,int &i2,int &j2,int &soln){
        if(i<0||i>=grid.size()||j<0||j>=grid[0].size()){
            return;
        }
        if(grid[i][j]==-1){
            return;
        }
        if(grid[i][j]==1){
            int temp=abs(i-i2)+abs(j-j2);
            soln=min(soln,temp);
            return;
        }
        grid[i][j]=-1;
        dfs(grid,i-1,j-1,i2,j2,soln);
        dfs(grid,i-1,j,i2,j2,soln);
        dfs(grid,i-1,j+1,i2,j2,soln);
        dfs(grid,i,j-1,i2,j2,soln);
        dfs(grid,i,j+1,i2,j2,soln);
        dfs(grid,i+1,j-1,i2,j2,soln);
        dfs(grid,i+1,j,i2,j2,soln);
        dfs(grid,i+1,j+1,i2,j2,soln);
        
    }
    //Function to find distance of nearest 1 in the grid for each cell.
	vector<vector<int>>nearest(vector<vector<int>>grid)
	{
	    // Code here
	   
	    vector<vector<int>> ans(grid.size(),vector<int> (grid[0].size(),0));
	    int soln;
	    for(int i=0;i<grid.size();i++){
	        for(int j=0;j<grid[0].size();j++){
	          if(grid[i][j]==1){ans[i][j]=0;}
	          else{ 
	               soln=INT_MAX;
    	           dfs(grid,i,j,i,j,soln);
    	           ans[i][j]=soln;
	          }
	        }
	    }
	    return ans;
	}
	*/
   //correct soln:
	void bfs(vector<vector<int>> &grid,vector<vector<int>> &visited,vector<vector<int>> &distance,queue<pair<pair<int,int>,int>> &q){
	    int delx[4]={0,0,1,-1};
	    int dely[4]={1,-1,0,0};
	    while(q.empty()!=true){
	        pair<pair<int,int>,int> front=q.front();
	        q.pop();
	        int r=front.first.first;
	        int c=front.first.second;
	        int dist=front.second;
	        distance[r][c]=dist;
	        for(int i=0;i<4;i++){
	            int nr=r+delx[i];
	            int nc=c+dely[i];
	            if(nr>=0&&nr<grid.size()&&nc>=0&&nc<grid[0].size()&&grid[nr][nc]==0&&visited[nr][nc]!=1){
	                q.push({{nr,nc},dist+1});
	                visited[nr][nc]=1;
	            }
	        }
	    }
	}
	 //Function to find distance of nearest 1 in the grid for each cell.
	vector<vector<int>>nearest(vector<vector<int>>grid)
	{
	    // Code here
	   
	    vector<vector<int>> visited(grid.size(),vector<int> (grid[0].size(),0));
	    vector<vector<int>> distance(grid.size(),vector<int> (grid[0].size(),0));
	    queue<pair<pair<int,int>,int>> q;
	    for(int i=0;i<grid.size();i++){
	        for(int j=0;j<grid[0].size();j++){
	          if(grid[i][j]==1){
	              visited[i][j]=1;
	              q.push({{i,j},0});
	          }
	         // else visited[i][j]=0;
	        }
	    }
	    bfs(grid,visited,distance,q);
	    return distance;
	}
//13.Mother Vertex
void dfs(int &v,vector<int> adj[],int currnode,vector<int> &visited,int &count){
        if(visited[currnode]==1){
            return;
        }
        visited[currnode]=1;
        count++;
        for(auto child:adj[currnode]){
            dfs(v,adj,child,visited,count);
        }
    }
    //Function to find a Mother Vertex in the Graph.
	int findMotherVertex(int V, vector<int>adj[])
	{
	    // Code here
	    int ans,count=0;
	    for(int i=0;i<V;i++){
	        count=0;
	        vector<int> visited(V,0);
	        dfs(V,adj,i,visited,count);
	        if(count==V) return i;
	    }
	    return -1;
	}
//14.Unit Area of largest region of 1's
void dfs(vector<vector<int>> &grid,int r,int c,int &count){
        if(r<0||r>=grid.size()||c<0||c>=grid[0].size()||grid[r][c]!=1){
            return;
        }
        grid[r][c]=2;
        count++;
        dfs(grid,r-1,c-1,count);
        dfs(grid,r-1,c,count);
        dfs(grid,r-1,c+1,count);
        dfs(grid,r,c-1,count);
        dfs(grid,r,c+1,count);
        dfs(grid,r+1,c-1,count);
        dfs(grid,r+1,c,count);
        dfs(grid,r+1,c+1,count);
    }
    //Function to find unit area of the largest region of 1s.
    int findMaxArea(vector<vector<int>>& grid) {
        // Code here
        int count=0,maxi=INT_MIN;
        for(int i=0;i<grid.size();i++){
            for(int j=0;j<grid[0].size();j++){
                if(grid[i][j]==1){
                    count=0;
                    dfs(grid,i,j,count);
                    maxi=max(count,maxi);
                }
            }
        }
        if(maxi==INT_MIN) return 0;
        return maxi;
    }
//15.Rotten Oranges
int orangesRotting(vector<vector<int>>& grid) {
        // Code here
        //similar to nearest 1 distance problem.
        int n = grid.size();
        int m = grid[0].size();
        queue<pair<pair<int,int>,int>>q;
        int vis[n][m];
        int count=0;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                //if cell contains rotten oranges
                if(grid[i][j]==2){
                    q.push({{i,j},0});
                    vis[i][j]=2;
                }
                //if not rotten
                else{
                    vis[i][j]=0;
                }
                //count fresh oranges
                if(grid[i][j]==1)
                    count++;
            }
        }
       //now doing bfs on queue
        int time=0;
        int drow[]={-1,0,+1,0};
        int dcol[]={0,+1,0,-1};
        int cnt=0;
        while(!q.empty()){
            int r = q.front().first.first;
            int c = q.front().first.second;
            int t = q.front().second;
            time = max(time,t);
            q.pop();
            //exactly 4 neighbours
            for(int i=0;i<4;i++){
                int nrow = r + drow[i];
                int ncol = c + dcol[i];
                if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol]==1 && vis[nrow][ncol]!=2){
                    q.push({{nrow,ncol},t+1});
                    vis[nrow][ncol]=2;//mark rotten
                    cnt++;
                }
            }
        }
        //if all oranges are not rotten
        if(cnt!=count)
            return -1;
        return time;    
    }
//16.Minimum Swaps to Sort
   static bool comp(pair<int,int> a,pair<int,int> b){
        if(a.first<b.first) return true;
        else return false;
    }
    //Function to find the minimum number of swaps required to sort the array. 
	int minSwaps(vector<int>&nums)
	{
	    // Code here
	    vector<pair<int,int>> v;
	    int j=0,cnt=0;
	    for(auto i:nums){
	        v.push_back({i,j});
	        j++;
	    }
	    sort(v.begin(),v.end(),comp);
	    for(int i=0;i<nums.size();){
	        if(i!=v[i].second){
	            cnt++;
	            swap(v[i],v[v[i].second]);
	        }else i++;
	    }
	    return cnt;
	}
//17.Steps by Knight
//Function to find out minimum steps Knight needs to reach target position.
	int minStepToReachTarget(vector<int>&KnightPos,vector<int>&TargetPos,int N)
	{
	    // Code here
	    //same like distance problem but need just one distance from src to destn.
	    vector<vector<int>> visited(N+1,vector<int> (N+1,0));//N+1 since 1 based indexing
	    int kx=KnightPos[0],ky=KnightPos[1],tx=TargetPos[0],ty=TargetPos[1];
	    int delx[8]={-2,-2,-1,-1,1,1,2,2};
	    int dely[8]={-1,1,-2,2,-2,2,-1,1};
	    queue<pair<pair<int,int>,int>> q;
	    q.push({{kx,ky},0});//start from source (knightpos)
	    while(q.empty()!=true){
	        pair<pair<int,int>,int> front=q.front();
	        q.pop();
	        int r=front.first.first;
	        int c=front.first.second;
	        int steps=front.second;
	        if(r==tx&&c==ty) return steps;
	        for(int i=0;i<8;i++){
	           int nr=r+delx[i];
	           int nc=c+dely[i];
	           if(nr>=1&&nr<(N+1)&&nc>=1&&nc<(N+1)&&visited[nr][nc]!=1){
	               q.push({{nr,nc},steps+1});
	               visited[nr][nc]=1;
	           }
	        }
	    }
	    return -1;
	}
//18.Implementing Dijkstra Algorithm
	//Function to find the shortest distance of all the vertices
    //from the source vertex S.
    vector <int> dijkstra(int V, vector<vector<int>> adj[], int S)
    {
        // Code here
        vector<int> dis(V,INT_MAX);
        dis[S]=0;
        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;
        pq.push({S,0});
        while(pq.empty()!=true){
            pair<int,int> top=pq.top();
            pq.pop();
            int currnode=top.first;
            int distancetillnow=top.second;
            for(auto child:adj[currnode]){
                int adjnode=child[0];
                int adjdis=child[1];
                if(distancetillnow+adjdis<dis[adjnode]){
                    dis[adjnode]=distancetillnow+adjdis;
                    pq.push({adjnode,dis[adjnode]});
                }
            }
        }
        return dis;
    }
//19.Minimum Spanning Tree
//Function to find sum of weights of edges of the Minimum Spanning Tree.
    int spanningTree(int V, vector<vector<int>> adj[])
    {
        // code here
        //prim's algo:
        vector<bool> visited(V,false);
        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;
        pq.push({0,0});//{wt,src} here pq is giving priority based on wt.
        int res=0;
        while(pq.empty()!=true){
            pair<int,int> top=pq.top();
            pq.pop();
            int currnode=top.second;
            int distance=top.first;
            if(visited[currnode]==false){
                res+=distance;
                visited[currnode]=true;
                for(auto child:adj[currnode]){
                    if(visited[child[0]]==false){
                        pq.push({child[1],child[0]});
                    }
                }
            }
        }
        return res;
    }
//20.Strongly Connected Components (Kosaraju's Algo)
 public: 
//Kosaraju Algo:
//  1.  do dfs on the graph and store nodes end time wise in the stack.

//  2.  reverseEdges the given graph(transpose)

//  3.   do the dfs(accordig to the top element of the stack you got from step 1) and count everytime you run the dfs  

//dfs the graph:  
 void dfsSort(int src, vector<int>&vist, vector<int>adj[], stack<int>&st){
       vist[src]=1;
       for(auto x:adj[src]){
           if(!vist[x]){
               dfsSort(x,vist,adj,st);
           }
       }
       st.push(src);
   }
//revdfs the graph
 void revDfs(int node, vector<int>&vist, vector<int>transpose[]){
       vist[node]=1;
       for(auto it:transpose[node]){
           if(!vist[it]){
               revDfs(it,vist,transpose);
           }
       }
 }
 int kosaraju(int V, vector<int> adj[]){
       vector<int>vist(V,0);
       stack<int>st;        
       // fist point is done means all element push in the stack 
       for(int i=0; i<V; i++){
           if(!vist[i]){
              dfsSort(i,vist,adj,st);
           }
       }    
      // second point is done means transpose of the graph
      vector<int> transpose[V];
       for(int i=0; i<V; i++){
           vist[i]=0;
           for(auto it:adj[i]){
               transpose[it].push_back(i);
           }
       }
      // 3rd point is done 
       int  components=0;
      while(!st.empty()){
        int node = st.top();
        st.pop(); 
        if(!vist[node]){
           components++;
           revDfs(node, vist, transpose); 
        } 
       }
    return  components;
    }
//21.Minimum Cost Path
 public:
    int delx[4]={0,0,-1,1};
    int dely[4]={-1,1,0,0};
    void dijkstra(vector<vector<int>> &grid,int i,int j,int & cost){
        vector<vector<int>> distance(grid.size(),vector<int> (grid[0].size(),INT_MAX));
        priority_queue<pair<pair<int,int>,int>,vector<pair<pair<int,int>,int>>,mycomp> pq;
        distance[0][0]=grid[0][0];//source
        pq.push({{i,j},grid[i][j]});//push soruce
        while(pq.empty()!=true){
            pair<pair<int,int>,int> top=pq.top();
            pq.pop();
            i=top.first.first;
            j=top.first.second;
            int dist=top.second;
            if(i==(grid.size()-1)&&j==(grid[0].size()-1)){cost=distance[i][j];return;}
            for(int k=0;k<4;k++){
                int nr=i+delx[k];
                int nc=j+dely[k];
                if(nr>=0&&nr<grid.size()&&nc>=0&&nc<grid[0].size()&&distance[nr][nc]>dist+grid[nr][nc]){
                    distance[nr][nc]=dist+grid[nr][nc];
                    pq.push({{nr,nc},dist+grid[nr][nc]});
                }
            }
        }
    }
    //Function to return the minimum cost to react at bottom
	//right cell from top left cell.
    int minimumCostPath(vector<vector<int>>& grid) 
    {
        // Code here
        int cost=0;
        dijkstra(grid,0,0,cost);
        return cost;
    }
//22.Bridge Edge in Graph
   void dfs(int v,vector<int> adj[],int currnode,vector<bool> &visited){
	    if(visited[currnode]==true) return;
	    visited[currnode]=true;
	    for(auto child:adj[currnode]){
	        if(visited[child]==false){
	            dfs(v,adj,child,visited);
	        }
	    }
	}
    //Function to find if the given edge is a bridge in graph.
    int isBridge(int V, vector<int> adj[], int c, int d) 
    {
        // Code here
        vector<bool> visited(V,false),vis(V,false);
        int initialnoofcomponents=0,finalnoofcomponents=0;
        for(int i=0;i<V;i++){
            if(visited[i]==false){
                dfs(V,adj,i,visited);
                initialnoofcomponents++;
            }
        }
        //remove edges:
        adj[c].erase(find(adj[c].begin(),adj[c].end(),d));
        adj[d].erase(find(adj[d].begin(),adj[d].end(),c));
        
        for(int i=0;i<V;i++){
            if(vis[i]==false){
                dfs(V,adj,i,vis);
                finalnoofcomponents++;
            }
        }
        if(finalnoofcomponents>initialnoofcomponents) return 1;
        else return 0;
    }
//23.
/*
//gfg article code:
// A recursive function that finds and prints strongly connected
// components using DFS traversal
// u --> The vertex to be visited next
// disc[] --> Stores discovery times of visited vertices
// low[] -- >> earliest visited vertex (the vertex with minimum
//             discovery time) that can be reached from subtree
//             rooted with current vertex
// *st -- >> To store all the connected ancestors (could be part
//         of SCC)
// stackMember[] --> bit/index array for faster check whether
//                 a node is in stack
void Graph::SCCUtil(int u, int disc[], int low[], stack<int> *st,
                    bool stackMember[])
{
    // A static variable is used for simplicity, we can avoid use
    // of static variable by passing a pointer.
    static int time = 0;
 
    // Initialize discovery time and low value
    disc[u] = low[u] = ++time;
    st->push(u);
    stackMember[u] = true;
 
    // Go through all vertices adjacent to this
    list<int>::iterator i;
    for (i = adj[u].begin(); i != adj[u].end(); ++i)
    {
        int v = *i; // v is current adjacent of 'u'
 
        // If v is not visited yet, then recur for it
        if (disc[v] == -1)
        {
            SCCUtil(v, disc, low, st, stackMember);
 
            // Check if the subtree rooted with 'v' has a
            // connection to one of the ancestors of 'u'
            // Case 1 (per above discussion on Disc and Low value)
            low[u] = min(low[u], low[v]);
        }
 
        // Update low value of 'u' only of 'v' is still in stack
        // (i.e. it's a back edge, not cross edge).
        // Case 2 (per above discussion on Disc and Low value)
        else if (stackMember[v] == true)
            low[u] = min(low[u], disc[v]);
    }
 
    // head node found, pop the stack and print an SCC
    int w = 0; // To store stack extracted vertices
    if (low[u] == disc[u])
    {
        while (st->top() != u)
        {
            w = (int) st->top();
            cout << w << " ";
            stackMember[w] = false;
            st->pop();
        }
        w = (int) st->top();
        cout << w << "\n";
        stackMember[w] = false;
        st->pop();
    }
}
 
// The function to do DFS traversal. It uses SCCUtil()
void Graph::SCC()
{
    int *disc = new int[V];
    int *low = new int[V];
    bool *stackMember = new bool[V];
    stack<int> *st = new stack<int>();
 
    // Initialize disc and low, and stackMember arrays
    for (int i = 0; i < V; i++)
    {
        disc[i] = NIL;
        low[i] = NIL;
        stackMember[i] = false;
    }
 
    // Call the recursive helper function to find strongly
    // connected components in DFS tree with vertex 'i'
    for (int i = 0; i < V; i++)
        if (disc[i] == NIL)
            SCCUtil(i, disc, low, st, stackMember);
}
 
*/
//gfg practice code:
void tarjanhelper(int currnode,int v,vector<int> adj[],vector<int> &discovery,vector<int> &low,vector<bool> &stackmember,stack<int> &st,vector<vector<int>> &ans,int &time){
	    discovery[currnode]=low[currnode]=time++;
	    st.push(currnode);
	    stackmember[currnode]=true;
	    for(auto child:adj[currnode]){
	        if(discovery[child]==-1){
	            tarjanhelper(child,v,adj,discovery,low,stackmember,st,ans,time);
	            low[currnode]=min(low[currnode],low[child]);
	        }else if(stackmember[child]==true){
	            low[currnode]=min(low[currnode],discovery[child]);
	        }
	    }
	    if(low[currnode]==discovery[currnode]){
    	    vector<int> connectedcomponentslist;
    	    while(st.top()!=currnode){
    	        connectedcomponentslist.push_back(st.top());
    	        stackmember[st.top()]=false;
    	        st.pop();
    	    }
    	    connectedcomponentslist.push_back(st.top());
    	    stackmember[st.top()]=false;
    	    st.pop();
    	    sort(connectedcomponentslist.begin(),connectedcomponentslist.end());
    	    ans.push_back(connectedcomponentslist);
	    }
	}
    //Function to return a list of lists of integers denoting the members 
    //of strongly connected components in the given graph.
    vector<vector<int>> tarjans(int V, vector<int> adj[])
    {
        //code here
        vector<int> discovery(V,-1);
        vector<int> low(V,-1);
        vector<bool> stackmember(V,false);
        stack<int> st;
        vector<vector<int>> ans;
        int time=0;
        for(int i=0;i<V;i++){
            if(discovery[i]==-1){
                tarjanhelper(i,V,adj,discovery,low,stackmember,st,ans,time);
            }
        }
        sort(ans.begin(),ans.end());
        return ans;
    }
//24.Articulation points
/* 
//gfg article:
// A recursive function that find articulation
// points using DFS traversal
// adj[] --> Adjacency List representation of the graph
// u --> The vertex to be visited next
// visited[] --> keeps track of visited vertices
// disc[] --> Stores discovery times of visited vertices
// low[] -- >> earliest visited vertex (the vertex with minimum
// discovery time) that can be reached from subtree
// rooted with current vertex
// parent --> Stores the parent vertex in DFS tree
// isAP[] --> Stores articulation points
void APUtil(vector<int> adj[], int u, bool visited[],
            int disc[], int low[], int& time, int parent,
            bool isAP[])
{
    // Count of children in DFS Tree
    int children = 0;
 
    // Mark the current node as visited
    visited[u] = true;
 
    // Initialize discovery time and low value
    disc[u] = low[u] = ++time;
 
    // Go through all vertices adjacent to this
    for (auto v : adj[u]) {
        // If v is not visited yet, then make it a child of u
        // in DFS tree and recur for it
        if (!visited[v]) {
            children++;
            APUtil(adj, v, visited, disc, low, time, u, isAP);
 
            // Check if the subtree rooted with v has
            // a connection to one of the ancestors of u
            low[u] = min(low[u], low[v]);
 
            // If u is not root and low value of one of
            // its child is more than discovery value of u.
            if (parent != -1 && low[v] >= disc[u])
                isAP[u] = true;
        }
 
        // Update low value of u for parent function calls.
        else if (v != parent)
            low[u] = min(low[u], disc[v]);
    }
 
    // If u is root of DFS tree and has two or more children.
    if (parent == -1 && children > 1)
        isAP[u] = true;
}
 
void AP(vector<int> adj[], int V)
{
    int disc[V] = { 0 };
    int low[V];
    bool visited[V] = { false };
    bool isAP[V] = { false };
    int time = 0, par = -1;
 
    // Adding this loop so that the
    // code works even if we are given
    // disconnected graph
    for (int u = 0; u < V; u++)
        if (!visited[u])
            APUtil(adj, u, visited, disc, low,
                   time, par, isAP);
 
    // Printing the APs
    for (int u = 0; u < V; u++)
        if (isAP[u] == true)
            cout << u << " ";
}
*/
//gfg practice:
void aphelper(int currnode,int v,vector<int> adj[],vector<bool> &visited,vector<int> &disc,vector<int> &low,set<int> &ans,int &time,int parent){
        visited[currnode]=true;
        disc[currnode]=low[currnode]=++time;
        int noofchild=0;
        for(auto child:adj[currnode]){
            if(disc[child]==-1){
                noofchild++;
                aphelper(child,v,adj,visited,disc,low,ans,time,currnode);
                low[currnode]=min(low[currnode],low[child]);
                if(parent!=-1&&low[child]>=disc[currnode]){// we are comparing disc of currnode instead of low of currnode as its low may get change
                    ans.insert(currnode);
                }
            }else if(child!=parent){
               low[currnode]=min(low[currnode],disc[child]);    
            }
            
        }
        if(parent==-1&&noofchild>1){
                ans.insert(currnode);
        }
    }
    vector<int> articulationPoints(int V, vector<int>adj[]) {
        // Code here
        vector<bool> visited(V,false);
        vector<int> disc(V,-1);
        vector<int> low(V,-1);
        set<int> ans;
        int time=0,parent=-1;
        for(int i=0;i<V;i++){
            if(disc[i]==-1){
                aphelper(i,V,adj,visited,disc,low,ans,time,parent);
            }
        }
        if(ans.size()==0){return {-1};}
        vector<int> res;
        for(auto i:ans){
            res.push_back(i);
        }
        return res;
    }

GREEDY:
//01.Activity Selection
 public:
    static bool mycomp(pair<int,int> a,pair<int,int> b){
        if(a.second<b.second) return true;
        else if(a.second==b.second) return a.first<b.first;
        else return false;
        
    }
    //Function to find the maximum number of activities that can
    //be performed by a single person.
    int activitySelection(vector<int> start, vector<int> end, int n)
    {
        // Your code here
        if(n<=0) return 0;
        vector<pair<int,int>> v;
        for(int i=0;i<start.size();i++){
            v.push_back({start[i],end[i]});
        }
        sort(v.begin(),v.end(),mycomp);
        int time=0,res=1,i=1;
        while(i<n){
            if(v[time].second<v[i].first){
                res++;
                time=i;
            }
            i++;
        }
        return res;
    }
//02. Huffman Decoding
void preorder(MinHeapNode *root,string &binaryString,unordered_map<string,char> &h,string temp){
    if(root==NULL) return;
    if(root->data!='$'){
        h[temp]=root->data;
    }
    preorder(root->left,binaryString,h,temp+"0");
    preorder(root->right,binaryString,h,temp+"1");
}
//Function to return the decoded string.
string decodeHuffmanData(struct MinHeapNode* root, string binaryString)
{
    // Code here
    string ans="",temp="";
    unordered_map<string,char> h;
    preorder(root,binaryString,h,temp);
    temp="";
    for(int i=0;i<binaryString.length();i++){
        temp.push_back(binaryString[i]);
        if(h.find(temp)!=h.end()){
            ans.push_back(h[temp]);
            temp="";
        }
    }
    return ans;
}
//03.N meetings in one room
public:
    static bool mycomp(pair<int,int> a,pair<int,int> b){
        if(a.second<b.second) return true;
        else if(a.second==b.second){
            if(abs(a.second-a.first)<abs(b.second-b.first)) return true;
            else return false;
        }else return false;
    }
    //Function to find the maximum number of meetings that can
    //be performed in a meeting room.
    int maxMeetings(int start[], int end[], int n)
    {
        // Your code here
        if(n<=0) return 0;
        vector<pair<int,int>> v;
        for(int i=0;i<n;i++){
            v.push_back({start[i],end[i]});
        }
        sort(v.begin(),v.end(),mycomp);
        int time=0,i=1,res=1;
        while(i<n){
            if(v[time].second<v[i].first){
                res++;
                time=i;
            }
            i++;
        }
        return res;
    }
//04.Fractional Knapsack
bool static mycomp(Item a,Item b){
        return ((a.value*1.0)/a.weight)>((b.value*1.0)/b.weight) ;
    }
    //Function to get the maximum total value in the knapsack.
    double fractionalKnapsack(int W, Item arr[], int n)
    {
        // Your code here
        if(n<=0) return 0.0;
        sort(arr,arr+n,mycomp);
        double res=0;
        int a=0;
        while(W>0&&a<n){
            if(arr[a].weight<W){
                res+=(arr[a].value);
                W-=(arr[a].weight);
                a++;
            }else {
                res+=(W*((arr[a].value*1.0)/arr[a].weight));
                W=0;//w=w-w;
                a++;
            }
        }
        return res;
    }
//05.Largest number with given sum
 public:
    //Function to return the largest possible number of n digits
    //with sum equal to given sum.
    //each digit can be used only once.
    string largestNumber(int n, int sum)
    {
        // Your code here
        vector<int> v={9,8,7,6,5,4,3,2,1,0};
        string res="";
        int i=0;
        while(sum>0&&n>0&&i<10){
            if(sum>=v[i]){
                res+=to_string(v[i]);
                sum-=v[i];
                n--;
            }else i++;
            
        }
        if(sum>0) return "-1";
        while(n>0&&sum<=0){
            res+='0';
            n--;
        }
        return res;
    }
//06.Job Sequencing Problem
public:
    bool static mycomp(Job a,Job b){
        if(a.profit>b.profit) return true;
        else return false;
    }
    //Function to find the maximum profit and the number of jobs done.
    vector<int> JobScheduling(Job arr[], int n) 
    { 
        // your code here
        int maxitime=INT_MIN;
        for(int i=0;i<n;i++){
            if(maxitime<arr[i].dead){
                maxitime=arr[i].dead;
            }
        }
        sort(arr,arr+n,mycomp);
        vector<int> v(maxitime+1,0);
        int profit=0,count=0,i=0,t=0;
        while(i<n){
                t=arr[i].dead;
                while(v[t]!=0&&t>=1){
                    t--;
                }
                if(t!=0){
                    v[t]=arr[i].id;
                    profit+=arr[i].profit;
                    count++;
                }
                i++;
        }
        return {count,profit};
    } 

BACKTRACKING:
//01.Largest number in K swaps
void solve(string str,int k,string &ans,int index,int n){
        if(k==0)return;
        char mx=str[index];
        for(int i=index+1;i<n;i++){
            mx=max(mx,str[i]);
        }
        if(mx!=str[index]) k--;
        for(int i=n-1;i>=index;i--){
            if(str[i]==mx){
                swap(str[index],str[i]);
                if(ans<str) ans=str;
                solve(str,k,ans,index+1,n);
                swap(str[index],str[i]);
            }
        }
    }
    //Function to find the largest number after k swaps.
    string findMaximumNum(string str, int k)
    {
       // code here.
       string ans="";
       solve(str,k,ans,0,str.length());
       return ans;
    }
//02.Rat Maze With Multiple Jumps
bool isSafe(int i, int j, int n, vector<vector<int>> &matrix) {
        return (i < n && j < n && matrix[i][j] != 0);
    }

    bool distanceRec(vector<vector<int>> &matrix, int n, int i, int j) {
        
        if (i == n - 1 && j == n - 1) {
            matrix[i][j] = -1;
            return true;
        }
        if(isSafe(i, j, n, matrix)) {
            int x = matrix[i][j];
            matrix[i][j] = -1;
            for (int a = 1; a <= x; a++) {
                if (distanceRec(matrix, n, i, j + a) == true) return true;
                if (distanceRec(matrix, n, i + a, j) == true) return true;
            }
            matrix[i][j] = 0;
        }
        return false;
    }
    
	vector<vector<int>> ShortestDistance(vector<vector<int>>&matrix){
	   // Code here
	   int n = matrix.size();
	   bool flag = distanceRec(matrix, n, 0, 0);
	   if (flag) {
	       for (int i = 0; i < n; i++) {
	           for (int j = 0; j < n; j++) {
	               if(matrix[i][j] == -1) matrix[i][j] = 1;
	               else matrix[i][j] = 0;
	           }
	       }
	       return matrix;
	   }
	   else return {{-1}};
	   
	}
//03.Black and White
//here just check the total blocks on chessboard 
//that are occupied by first knight and subtract 
//it from total possible blocks which will 
//result in the no of possible blocks where second knight can be placed.
bool isSafe(int r,int c,int n,int m){
    if(r<0||r>=n||c<0||c>=m) return false;
    else return true;
}
long long int validmoves(int *delx,int *dely,long long int allmoves,int r,int c,int n,int m){
    long long int res=0;
    for(int k=0;k<8;k++){
        if(isSafe(r+delx[k],c+dely[k],n,m)) res++;
    }
    return res;
}
//Function to find out the number of ways we can place a black and a 
//white Knight on this chessboard such that they cannot attack each other.
long long numOfWays(int n, int m)
{
    // write code here
    int delx[8]={2,1,2,1,1,2,2,1};
    int dely[8]={-1,2,1,2,2,1,-1,-2};
    long long int count=0,allmoves=n*m;
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
           count=count+(allmoves-validmoves(delx,dely,allmoves,i,j,n,m)-1);
           count=count%(1000000007);
        }
    }
    return count;
}
//04.Combination Sum
//This is subset sum problem with some slight
// variation.....first we must remove the 
//duplicates from the arr and then sort in 
//increasing order as it is been asked in 
//the question to give output in increasing 
//order
void solve(vector<int> &arr, int index, int n, int sum, vector<vector<int>> &ans, vector<int> temp){
        if(sum == 0){
            ans.push_back(temp);
            return;
        }
        if(index >= n || sum < 0){
            return;
        }
        if(arr[index] <= sum){
            temp.push_back(arr[index]);
            solve(arr,index,n,sum-arr[index],ans,temp);
            temp.pop_back();
            solve(arr,index+1,n,sum,ans,temp);
        }
        else{
            solve(arr,index+1,n,sum,ans,temp);
        }
    }
    vector<vector<int> > combinationSum(vector<int> &A, int B) {
        set<int> s;
        for(auto x:A){
            s.insert(x);
        }
        vector<int> arr;
        for(auto x:s){
            arr.push_back(x);
        }
        sort(arr.begin(), arr.end());
        vector<vector<int>> ans;
        vector<int> temp;
        solve(arr, 0, arr.size() , B, ans, temp);
        return ans;
    }
//05.Unique Subsets
    set<vector<int>> m;
    void solve(vector<int> &v,int n,vector<vector<int>> &ans,int index,vector<int> &s){
        if(index==n){
           m.insert(s);
           return;
        }
        if(index>n) return;
        s.push_back(v[index]);
        solve(v,n,ans,index+1,s);
        s.pop_back();
        solve(v,n,ans,index+1,s);
    }
    //Function to find all possible unique subsets.
    vector<vector<int> > AllSubsets(vector<int> arr, int n)
    {
        // code here 
        sort(arr.begin(),arr.end());
        vector<vector<int>> ans;
        vector<int> temp;
        solve(arr,n,ans,0,temp);
        for(auto v:m){
            ans.emplace_back(v);
        }
        return ans;
    }
//06. M-Coloring Problem
 bool isPossible(bool graph[101][101],int m,int n,vector<int> &color,int currnode,int currcolor){
        for(int child=0;child<n;child++){
            if(graph[currnode][child]==1){
                if(color[child]==currcolor) return false;
            }
        }
        return true;
    }
    bool rec(bool graph[101][101],int m,int n,vector<int>&color, int currnode){
        if(currnode>=n) return true;
        for(int clr=1;clr<=m;clr++){//for each node total m colors to pick and check: thus clr=1 to m
            if(isPossible(graph,m,n,color,currnode,clr)==true){
               color[currnode]=clr;
               if(rec(graph,m,n,color,currnode+1)==true) return true; 
               else color[currnode]=0;//backtracking
            }
        }
        return false;
    }
    // Function to determine if graph can be coloured with at most M colours such
    // that no two adjacent vertices of graph are coloured with same colour.
    bool graphColoring(bool graph[101][101], int m, int n) {
        // your code here
      vector<int> color(n,0);
      return rec(graph,m,n,color,0);
    }
//07.Solve the Sudoku
 public:
    bool isPossible(int grid[N][N],int currval,int r,int c){
        int blkrow=(r/3)*3,blkcol=(c/3)*3;
        for(int i=0;i<N;i++){
            if(i!=c&&grid[r][i]==currval) return false;
            if(i!=r&&grid[i][c]==currval) return false;
            if(grid[blkrow+i/3][blkcol+i%3]==currval) return false;
        }
      
        return true;
    }
    bool rec(int grid[N][N]){
        for(int i=0;i<N;i++){
            for(int j=0;j<N;j++){
                if(grid[i][j]==0){
                    for(int currval=1;currval<=9;currval++){
                        if(isPossible(grid,currval,i,j)){
                            grid[i][j]=currval;
                            if(rec(grid)==true) return true;
                            else grid[i][j]=0;
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    }
    //Function to find a solved Sudoku. 
    bool SolveSudoku(int grid[N][N])  
    { 
        // Your code here
        
       return rec(grid);
    }
    
    //Function to print grids of the Sudoku.
    void printGrid (int grid[N][N]) 
    {
        // Your code here 
        for(int i=0;i<N;i++){
            for(int j=0;j<N;j++){
                cout<<grid[i][j]<<" ";
            }
        }
    }


DYNAMIC PROGRAMMING:
//03.Print first n Fibonacci Numbers
long long int nthFibonacci(long long int n){
        // code here
        if(n==1||n==2) return 1;
        if(n<=0) return 0;
        long long int first=1,second=1,curr=0;
        for(long long int i=3;i<=n;i++){
            curr=(second+first)%1000000007;
            first=second%1000000007;
            second=curr%1000000007;
        }
        return curr;
    }
//04. Nth catalan number
public:
    //Function to find the nth catalan number.
    cpp_int findCatalan(int n) 
    {
        //code here
        //use recurrence: cn=((4n-2)/(n+1))*cn-1
        cpp_int cat=1;
        if(n==0) return cat;
        for(cpp_int i=1;i<=n;i++){
        cat*=(4*i-2);
        cat/=(i+1);
        }
        return cat;
    }
//05.Coin Change - Minimum number of coins

	public:
	/* //inc exc way of recursion
    long long int rec(int coins[],int n,int target,int index,long long int &res){
        if(target<0||index>=n)return INT_MAX;
        if(target==0) return 0;
        long long int inc=1+rec(coins,n,target-coins[index],index,res);
        long long int exc=rec(coins,n,target,index+1,res);
        return min(inc,exc);
    }
    */
    // chose one by one from all way of recursion
    long long int rec(int coins[],int n,int target){
        if(target<0) return INT_MAX;
        if(target==0) return 0;
        long long int res=INT_MAX;
        for(int i=0;i<n;i++){
            if(coins[i]<=target){
                res=min(res,(1+rec(coins,n,target-coins[i])));
            }
        }
        return res;
    }
    long long int recMemo(int coins[],int n,long long int target,vector<long long int> &dp){
        if(target<0) return INT_MAX;
        if(target==0) return 0;
        if(dp[target]!=-1) return dp[target];
        long long int res=INT_MAX;
        for(int i=0;i<n;i++){
            if(coins[i]<=target){
                res=min(res,(1+recMemo(coins,n,target-coins[i],dp)));
            }
        }
        dp[target]=res;
        return dp[target];
    }
    int Tab(int coins[],int n,int target,vector<int> &dp){
        for(int sum=1;sum<=target;sum++){
            for(int coin=0;coin<n;coin++){
                if(((sum-coins[coin])>=0)&&(dp[sum-coins[coin]]!=INT_MAX)){
                  dp[sum]=min(dp[sum],1+dp[sum-coins[coin]]);
                }
            }
        }
    }
    
    int minCoins(int coins[], int M, int V) 
	{ 
	    // Your code goes here
	    /*
	    long long int res,target=V;
	    vector<long long int> dp(V+1,-1);
	    res=recMemo(coins,M,target,dp);
	    */
	    int res;
	    vector<int> dp(V+1,INT_MAX);
	    dp[0]=0;
	    Tab(coins,M,V,dp);
	    res=dp[V];
	    if(res==INT_MAX) return -1;
	    else return res;
	} 

//06.Coin Change - Number of ways
 /*recursion:
   //here qn is to find min no of coins
    static bool comp(int a,int b){
        return a>b;
    }
    map<int,vector<int>> h;
    void rec(vector<int> &coins,vector<int> ans,int target,int ind){
        if(target==0){
            int s=ans.size();
            h[s]=ans;
        }
        if(ind>=coins.size()||target<0){return;}
        if(coins[ind]<=target){
            ans.push_back(coins[ind]);
            rec(coins,ans,target-coins[ind],ind);
            ans.pop_back();
            rec(coins,ans,target,ind+1);
        }else {
            rec(coins,ans,target,ind+1);
        }
    }
    vector<int> minPartition(int N)
    {
        // code here
        vector<int> ans;
        vector<int> coins({1,2,5,10,20,50,100,200,500,2000});
        rec(coins,ans,N,0);
        if(h.size()==0) return {};
        auto it=h.begin();
        ans=(*it).second;
        sort(ans.begin(),ans.end(),comp);
        return ans;
    }
    */
    //greedy:
    vector<int> minPartition(int N)
    {
        // code here
        vector<int> ans;
        vector<int> coins({2000,500,200,100,50,20,10,5,2,1});
        int ind=0;
        while(N>0&&ind<10){
            while(N>=coins[ind]){
                N-=coins[ind];
                ans.push_back(coins[ind]);
            }
            ind++;
        }
        return ans;
    }
  //dp:
  //coin change :Here qn is:no of ways to make sum is to find .
 long long int rec(int coins[], int n, int i, int sum){
        
        if(sum==0)
        return 1;
        
        if(i==n || sum<0)
        return 0;
        
        return rec(coins, n, i, sum-coins[i])+rec(coins, n, i+1, sum);
    }
    long long int recMemo(int coins[],int n,int sum,int ind,vector<vector<long long int>> &dp){
        if(sum<0||ind>=n) return 0;
        if(sum==0) return 1;
        if(dp[sum][ind]==-1){
             long long int inc=recMemo(coins,n,sum-coins[ind],ind,dp);
             long long int exc=recMemo(coins,n,sum,ind+1,dp);
             dp[sum][ind]=inc+exc;
             return dp[sum][ind];
        }
        else return dp[sum][ind];
    }
    long long int Tab(int coins[],int n,vector<vector<long long int>> &dp,int target){
        for(int j=0;j<=n;j++) dp[0][j]=1;
        for(int i=0;i<=target;i++){
            for(int j=n-1;j>=0;j--){
                long long int inc=0;
                if((i-coins[j])>=0){
                    inc=dp[i-coins[j]][j];
                }
                long long int exc=dp[i][j+1];
                dp[i][j]=inc+exc;
            }
        }
        return dp[target][0];
    }
    long long int count(int coins[], int N, int sum) {

        // code here.
        vector<vector<long long int>> dp(sum+1,vector<long long int> (N+1,0));
        return Tab(coins,N,dp,sum);
    }
//07. Ways to write n as sum
 int rec(int arr[],int n,int target){
        if(target<0) return 0;
        if(target==0){
            return 1;
        }
        int res=0;
        for(int i=0;i<n;i++){
            if(arr[i]<=target){
             res+=rec(arr,n,target-arr[i]);
            }
        }
        return res;
    }
    int recMemo(int arr[],int n,long long int target,vector<long long int> &dp){
        if(target<0) return 0;
        if(target==0){
            return 1;
        }
        if(dp[target]!=-1) return dp[target];
        long long int res=0;
        for(int i=0;i<n;i++){
            if(arr[i]<=target){
             res=(res+(recMemo(arr,n,target-arr[i],dp)%1000000007))%1000000007;
            }
        }
        dp[target]=res;
        return dp[target];
    }
    
    int tab(int arr[],int n,long long int target,vector<long long int> &dp){
        dp[0]=1;
        for(long long int sum=1;sum<=target;sum++){
            for(long long int val=0;val<n;val++){
                if(((sum-arr[val])>=0)&&(dp[sum-arr[val]]!=0)&&(arr[val]<=sum)){
                  dp[sum]=(dp[sum]+(dp[sum-arr[val]]%1000000007))%1000000007;
                }
            }
        }
        return dp[target];
    }
    // function to count the total  
    // number of ways to sum up to 'N' 
    int countWays(int arr[], int m, int N) 
    { 
      //code here.
      vector<long long int> dp(N+1,0);
      int res=tab(arr,m,(long long int)N,dp);
      return res;
    } 
//08. Count ways to reach the n'th stair
public:
    const long long int mod=1e9+7;
    int rec(int n){
        if(n<0) return 0;
        if(n==0) return 1;
        long long int res=0;
        res=(res+rec(n-1))%mod;
        res=(res+rec(n-2))%mod;
        return res;
    }
    int recMemo(int n,vector<long long int> &dp){
        if(n<0) return 0;
        if(n==0) return 1;
        if(dp[n]!=-1) return dp[n];
        long long int res=0;
        res=(res+recMemo(n-1,dp))%mod;
        res=(res+recMemo(n-2,dp))%mod;
        dp[n]=res;
        return dp[n];
    }
    int tab(int n,vector<long long int> &dp){
        dp[0]=1;
        for(long long int i=1;i<=n;i++){//i:noofstair
            for(long long int j=1;j<=2;j++){//j:noofsteps
                if(((i-j)>=0)&&(dp[i-j]!=0)){
                   dp[i]=(dp[i]+dp[i-j])%mod;
                }
            }
        }
        return dp[n];
    }
    //Function to count number of ways to reach the nth stair.
    int countWays(int n)
    {
        // your code here
        vector<long long int> dp(n+1,0);
        int res;
        res=tab(n,dp);
        return res;
    }
//09.Count ways to N'th Stair(Order does not matter)
     int nthStair(int n){
        //  Code here
	return (n/2)+1;
     }
	public:
	//order does not matter means: {1,2,1},{1,1,2},{2,1,1} all are same.
	int nthStair(int n){
	    //  Code here
	    /*m1:return (n/2)+1;
	    Consider that you have N stairs. First of all you have to understand if N is odd or even.
            If is even than it will be a multiple of 2: N = 2*S, where S is the number of pair of stairs.
            Suppose N = 6 and S = 3. Your first solution is {2,2,2}. than you can change the first 2 stairs with 1 + 1 stairs and you have your second solution {1, 1, 2 ,2}. 
            Since order doesn't matter let's proceed with the next pair and we have our third solution {1, 1, 1, 1, 2} and then the fourth {1, 1, 1, 1, 1, 1}
            Given N = 2*S the number of possible solutions are S + 1.
            Now suppose N is odd and N = 2S + 1. Let N = 7 and S = 3. Our solutions are {2,2,2,1}, {1,1,2,2,1}, {1,1,1,1,2,1} and {1,1,1,1,1,1,1}. Again, the number of solutions is given by S+1
            Now your algorithm is pretty simple:
            return N/2 + 1
		    */
	    /*m2:
	    example:
            jumps =[1,2]
            Lets say that jump =1, so for any stair, the number of ways will always be equal to 1.
            Now for jump=2, say for stair 8: no of ways will be (no of ways to reach 8 using 1 only)+(no of ways to reach 6 using both 1 and 2 because you can reach to 8 from 6 by just a jump of 2).
            So the code will looks like:
             for(int i=1; i<=n;i++)
                 dp[i]=1;
            for(int i=2;i<=n;i++)
                dp[i]=dp[i]+dp[i-2];
            return dp[n];
            */
	     vector<int> dp(n+1,1);
             dp[0]=1;
	     for(int i=2;i<=n;i++){
		dp[i]=dp[i]+dp[i-2];
	     }
       	    return dp[n];
	}
//10. Count number of hops
 public:
    const long long int mod=1e9+7;
    long long int rec(int n){
        if(n<0) return 0;
        if(n==0) return 1;
        long long int res=0;
        res=(res+rec(n-1))%mod;
        res=(res+rec(n-2))%mod;
        res=(res+rec(n-3))%mod;
        return res;
    }
    long long int recMemo(int n,vector<long long int> &dp){
        if(n<0) return 0;
        if(n==0) return 1;
        if(dp[n]!=-1) return dp[n];
        long long int res=0;
        res=(res+recMemo(n-1,dp))%mod;
        res=(res+recMemo(n-2,dp))%mod;
        res=(res+recMemo(n-3,dp))%mod;
        dp[n]=res;
        return dp[n];
    }
    long long int tab(int n,vector<long long int> &dp){
        dp[0]=1;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=3;j++){
                if((i-j)>=0&&dp[i-j]!=0)
                  dp[i]=(dp[i]+dp[i-j])%mod;
            }
        }
        return dp[n];
    }
    //Function to count the number of ways in which frog can reach the top.
    long long countWays(int n)
    {
        // your code here
        vector<long long int> dp(n+1,0);
        long long int res;
        res=tab(n,dp);
        return res;
    }
//11. Reach a given score
const long long int mod=1e9+7;
long long int rec(vector<long long int> &arr,long long int n,long long int index){
    if(n<0||index>=arr.size()) return 0;
    if(n==0) return 1;
    long long int inc=rec(arr,n-arr[index],index)%mod;
    long long int exc=rec(arr,n,index+1)%mod;
    return (inc+exc)%mod;
}
long long int recMemo(vector<long long int> &arr,long long int n,long long int index,vector<vector<long long int>> &dp){
    if(n<0||index>=arr.size()) return 0;
    if(n==0) return 1;
    if(dp[n][index]!=-1) return dp[n][index];
    long long int inc=recMemo(arr,n-arr[index],index,dp)%mod;
    long long int exc=recMemo(arr,n,index+1,dp)%mod;
    dp[n][index]=(inc+exc)%mod;
    return dp[n][index];
}
long long int tab1(vector<long long int> &arr,long long int n,long long int index,vector<vector<long long int>> &dp){
     for(int i = 0;i<=3;i++){
           dp[0][i] = 1;
       }
       for(int i = 1;i<=n;i++){
           for(int j = 1;j<4;j++){
               if(i>=arr[j-1]){
                   dp[i][j] =(dp[i][j-1]+dp[i-arr[j-1]][j])%mod;
               }else{
                   dp[i][j] =(dp[i][j-1])%mod;
               }
           }
       }
       return dp[n][3];
}
long long int tab2(vector<long long int> &arr,long long int n,long long int index,vector<long long int> &dp){
    dp[0]=1;
    for(int i=0;i<arr.size();i++){
     for(int j=arr[i];j<n+1;j++){
         dp[j]+=dp[j-arr[i]];
     }
 }
    return dp[n];
}

long long int count(long long int n)
{  
	long long int res;
	vector<long long int> arr({3,5,10});
	vector<vector<long long int>> dp1(n+1,vector<long long int> ((arr.size()+1),0));
	vector<long long int> dp2(n+1,0);
	res=tab2(arr,n,0,dp2);
	return res;
}
//12.Minimum number of jumps
//refer gfg
int minJumps(int arr[], int n){
      if(n==1) return 0;
      if(arr[0]==0) return -1;
      int rng=arr[0];
      int steps=arr[0];
      int jump=1;
      for(int i=1;i<n;i++){
          if(i==n-1) return jump;
          rng=max(rng,i+arr[i]);
          steps--;
          if(steps==0){
              jump++;
              if(rng<=i) return -1;
              steps=rng-i;
          }
      }
    return -1;
    }
//13.nCr
const long long int mod=1e9+7;
    long long int rec(int n,int r){//USE NCR+NC(R-1) = (N+1)CR
        if(n<r||n<0||r<0) return 0;
        else if((n==r)||(n>r&&r==0)) return 1;
        else if((n>r&&r==1)||(n>r&&((n-r)==1))) return n;
        return (rec(n-1,r-1)%mod+rec(n-1,r)%mod)%mod;
    }
     long long int recMemo(long long int n,long long int r,vector<vector<long long int>> &dp){
        if(n<r||n<0||r<0) return 0;
        else if((n==r)||(n>r&&r==0)) return 1;
        else if((n>r&&r==1)||(n>r&&((n-r)==1))) return n;
        long long int first=-1,second=-1;
        if(dp[n-1][r-1]!=-1) first=dp[n-1][r-1];
        else if(first==-1) first=recMemo(n-1,r-1,dp)%mod;
        if(dp[n-1][r]!=-1)  second=dp[n-1][r];
        else if(second==-1) second=recMemo(n-1,r,dp)%mod;
        return (first+second)%mod;
    }
    int nCr(int n, int r){
        // code here
       /* 
        vector<vector<long long int>> dp(n+1,vector<long long int> (r+1,-1));
        for(long long int i=0;i<=r;i++){
            dp[0][i]=0;
        }
        for(long long int i=0;i<=n;i++){
            dp[i][0]=1;
        }
        for(long long int i=1;i<=n;i++){
            dp[i][1]=i;
        }
        return recMemo((long long int)n,(long long int)r,dp);
        */ 
        //TABULATION
        vector<vector<long long int>> dp(n+1,vector<long long int> (r+1,0));
        for(long long int i=0;i<=r;i++){
            dp[0][i]=0;
        }
         for(long long int i=0;i<=n;i++){
            dp[i][0]=1;
        }
        for(long long int i=1;i<=n;i++){
            dp[i][1]=i;
        }
        for(long long int i=1;i<=n;i++){
            for(long long int j=1;j<=r;j++){
                dp[i][j]=(dp[i-1][j]%mod+dp[i-1][j-1]%mod)%mod;
            }
        }
        return dp[n][r];
    }
//14. Kadane's Algorithm
long long maxSubarraySum(int arr[], int n){
        
        // Your code here
        long long int sum=0,res=INT_MIN;
        for(int i=0;i<n;i++){
            sum+=arr[i];
            res=max(res,sum);
            if(sum<0) sum=0;
        }
        return res;
        
    }
//16. Unique BST's
const long long int mod=1e9+7;
    /* use catalan recurrence
    long long int rec(int n){
        if(n<=0) return 1;
        if(n==1) return 1;
        return (((rec(n-1)%mod)*(4*n-2))%mod/(n+1))%mod;
    }
    */
    long long int rec(int n){
        if(n<=0) return 1;
        if(n==1) return 1;
        long long int res=0;
        for(int i=0;i<n;i++){// in a bst  for n nodes no of unique structures: i nodes in left * n-i-1 nodes in right; eg for i=0-> rootnode=1,left=0 nodes,right=2 to n nodes;
            res=(res+((rec(i)%mod)*(rec(n-i-1)%mod))%mod)%mod;
        }
        return res;
    }
    long long int recMemo(int n,vector<long long int> &dp){
        if(n<=0) return 1;
        if(n==1) return 1;
        if(dp[n]!=-1) return dp[n];
        long long int res=0;
        for(int i=0;i<n;i++){
            res=(res+((recMemo(i,dp)%mod)*(recMemo(n-i-1,dp)%mod))%mod)%mod;
        }
        dp[n]=res;
        return dp[n];
    }
    long long int tab(int n,vector<long long int> &dp){
        dp[0]=1;
        dp[1]=1;
        for(int i=2;i<=n;i++){ //i is no of nodes and in left there are j nodes and in right n-j-1
            for(int j=0;j<i;j++){
                dp[i]=(dp[i]+((dp[j]%mod)*(dp[i-j-1]%mod)))%mod;
            }
        }
        return dp[n];
    }
    //Function to return the total number of possible unique BST. 
    int numTrees(int N) 
    {
        // Your code here
       // vector<long long int> dp(N+1,-1); //for memo
       vector<long long int> dp(N+1,0);
       return tab(N,dp);
    }
//17.Sum of all substrings of a number
//Function to find sum of all possible substrings of the given string.
    /*
    We can solve this problem by using dynamic programming. We can write a summation of all substrings on basis of the digit at which they are ending in that case, 
Sum of all substrings = sumofdigit[0] + sumofdigit[1] + sumofdigit[2]  + sumofdigit[n-1] where n is length of string.
Where sumofdigit[i] stores the sum of all substring ending at ith index digit, in the above example, 

Example: num = 1234

sumofdigit[0] = 1 = 1
sumofdigit[1] = 2 + 12  = 14
sumofdigit[2] = 3 + 23  + 123 = 149
sumofdigit[3] = 4 + 34  + 234 + 1234  = 1506
Result = 1670

Now we can get the relation between sumofdigit values and can solve the question iteratively. Each sumofdigit can be represented in terms of previous value as shown below, For above example,

sumofdigit[3] = 4 + 34 + 234 + 1234
                     = 4 + 30 + 4 + 230 + 4 + 1230 + 4
                     = 4*4 + 10*(3 + 23 +123)
                     = 4*4 + 10*(sumofdigit[2])

In general, sumofdigit[i]  =  (i+1)*num[i] + 10*sumofdigit[i-1]
    */
    long long sumSubstrings(string s){
        const long long int mod=1e9+7;
        vector<long long int> sum(s.length(),0);
        sum[0]=s[0]-'0';
        long long int res=sum[0];
        for(int i=1;i<s.length();i++){
           sum[i]=((i+1)*(s[i]-'0')+10*(sum[i-1]))%mod;
           res=(res+sum[i])%mod;
        }
        return res%mod;
    }
//18.Max sum subarray by removing at most one element
public:
    //Function to return maximum sum subarray by removing at most one element.
    /*
    Follow the below steps to Implement the idea:

Initialize two arrays, one for prefix max sum fw[] and another for suffix max sum bw[].
Run two for loops 
First one to store the maximum current sum from prefix in fw[] and 
The other loop stores the same for suffix in bw[]. 
Getting the current maximum and updating it is the same as Kadanes algorithm. 
Now for one element removal iterate over each index i, calculate the maximum subarray sum after ignoring ith element i.e. fw[i-1] + bw[i+1] 
So loop for all possible index i and choose the maximum among them
    */
    int maxSumSubarray(int arr[], int n)
    {
       int lef[n];//forward kadane
       int ri[n];//backward kadane
        
        lef[0] = arr[0];
        ri[n-1] = arr[n-1];
        int ans = max(lef[0], ri[n-1]);
        for(int i=1; i<n; i++)
        {
            lef[i] = max(arr[i], arr[i]+lef[i-1]);
            ans = max(ans, lef[i]);
        }
        for(int i=n-2; i>=0; i--)
        {
            ri[i] = max(arr[i], arr[i]+ri[i+1]);
            ans = max(ans, ri[i]);
        }
        
        for(int i=1; i<n-1; i++)
        {
            ans = max(ans, lef[i-1]+ri[i+1]);//remove ith element
        }
        return ans;
    }
//19. Longest Increasing Subsequence
int rec(int arr[],int n,int curr,int prev){
        if(curr>=n) return 0;
        //include
        int take=0;
        if(prev==-1||arr[curr]>arr[prev]){
            take=1+rec(arr,n,curr+1,curr);
        }
        //exclude
        int notTake=0+rec(arr,n,curr+1,prev);
        return max(take,notTake);
    }
    int recMemo(int arr[],int n,int curr,int prev,vector<vector<int>> &dp){//curr:0 to n-1,prev:-1 to n-1
        if(curr>=n) return 0;
        if(dp[curr][prev+1]!=-1) return dp[curr][prev+1];
        //include
        int take=0;
        if(prev==-1||arr[curr]>arr[prev]){
            take=1+recMemo(arr,n,curr+1,curr,dp);
        }
        //exclude
        int notTake=0+recMemo(arr,n,curr+1,prev,dp);
        dp[curr][prev+1]=max(take,notTake);
        return dp[curr][prev+1];
    }
    int tab(int arr[],int n,vector<vector<int>> &dp){//curr:0 to n-1,prev:-1 to n-1
        for(int curr=n-1;curr>=0;curr--){//start from rev dir for bottom-up soln or tab --> curr:n-1 to 0
            for(int prev=curr-1;prev>=-1;prev--){//-->prev:n-1 to -1 but prev by definition means curr-1 or just one early to curr so prev:curr-1 to -1
                  //include
                    int take=0;
                    if(prev==-1||arr[curr]>arr[prev]){
                        take=1+dp[curr+1][curr+1];// here also prev coordinate is changed so do curr+1 for columns index, in rec,recmemo there was no need to do this as we had seperate prev variable and only dp needed to be mapped for changed coordinates
                    }
                    //exclude
                    int notTake=0+dp[curr+1][prev+1];//doint prev+1 to change coordinate of index from 0 to n for prev ,as -1 is not valid index
                    dp[curr][prev+1]=max(take,notTake);//doint prev+1 to change coordinate of index from 0 to n for prev ,as -1 is not valid index
            }
        }
        return dp[0][-1+1];// here return (0,-1) so doint -1+1 to change coordinate of index from 0 to n for prev ,as -1 is not valid index
      
    }
    int tabSpaceOptimized(int arr[],int n){//for space optimization we see that dp[curr][prev+1] depends on dp[curr+1][curr+1] and dp[curr+1][prev+1]; means row is common i.e (curr+1) i.e nextRow so store two rows only currRow for processing and nextRow. Also after every iteration currRow moves up and nextrow moves up to currRow. //curr:0 to n-1,prev:-1 to n-1
       vector<int> currRow(n+1,0);
       vector<int> nextRow(n+1,0);
        for(int curr=n-1;curr>=0;curr--){//start from rev dir for bottom-up soln or tab --> curr:n-1 to 0
            for(int prev=curr-1;prev>=-1;prev--){//-->prev:n-1 to -1 but prev by definition means curr-1 or just one early to curr so prev:curr-1 to -1
                  //include
                    int take=0;
                    if(prev==-1||arr[curr]>arr[prev]){
                        take=1+nextRow[curr+1];// here also prev coordinate is changed so do curr+1 for columns index, in rec,recmemo there was no need to do this as we had seperate prev variable and only dp needed to be mapped for changed coordinates
                    }
                    //exclude
                    int notTake=0+nextRow[prev+1];//doint prev+1 to change coordinate of index from 0 to n for prev ,as -1 is not valid index
                    currRow[prev+1]=max(take,notTake);//doint prev+1 to change coordinate of index from 0 to n for prev ,as -1 is not valid index
            }
            nextRow=currRow;
        }
        return nextRow[-1+1];// here return (0,-1) so doint -1+1 to change coordinate of index from 0 to n for prev ,as -1 is not valid index
      
    }
    int optimized(int arr[],int n){//dp+binary search:o(nlogn)
        if(n==0) return 0;
        vector<int> ans;
        ans.push_back(arr[0]);
        for(int i=1;i<n;i++){
            if(arr[i]>ans.back()){
                ans.push_back(arr[i]);
            }else {
                //index of just bada element in vector 
                int index=lower_bound(ans.begin(),ans.end(),arr[i])-ans.begin();//o(logn)
                ans[index]=arr[i];
            }
        }
        return ans.size();
    }
    //Function to find length of longest increasing subsequence.
    int longestSubsequence(int n, int a[])
    {
      // return rec(a,n,0,-1);
      /*vector<vector<int>> dp(n,vector<int> (n+1,-1));
      return recMemo(a,n,0,-1,dp);
      */
      /*vector<vector<int>> dp(n+1,vector<int> (n+1,0));
      return tab(a,n,dp);
      */
      //return tabSpaceOptimized(a,n);
      return optimized(a,n);
    }
//20.Longest Common Subsequence
public:
    int rec(string s1,int i,string s2,int j){
        if(i>=s1.length()||j>=s2.length()) return 0;
        //match
        if(s1[i]==s2[j]){
            return 1+rec(s1,i+1,s2,j+1);
        }else{//not a match
            return max(rec(s1,i,s2,j+1),rec(s1,i+1,s2,j));
        }
    }
    int recMemo(string s1,int i,string s2,int j,vector<vector<int>> &dp){
        if(i>=s1.length()||j>=s2.length()) return 0;
        if(dp[i][j]!=-1) return dp[i][j];
        //match
        if(s1[i]==s2[j]){
            return dp[i][j]= 1+recMemo(s1,i+1,s2,j+1,dp);
        }else{//not a match
            return dp[i][j]=max(recMemo(s1,i,s2,j+1,dp),recMemo(s1,i+1,s2,j,dp));
        }
    }
    int tab(string s1,string s2,vector<vector<int>> &dp){
        dp[s1.length()][s2.length()]=0;
        for(int i=s1.length()-1;i>=0;i--){
            for(int j=s2.length()-1;j>=0;j--){
                //match
                if(s1[i]==s2[j]){
                    dp[i][j]= 1+dp[i+1][j+1];
                }else{//not a match
                    dp[i][j]=max(dp[i][j+1],dp[i+1][j]);
                }
            }
        }
        return dp[0][0];
    }
    int tabSpaceOptimized(string s1,string s2){
        vector<int> currRow(s2.length()+1,0),nextRow(s2.length()+1,0);
        for(int i=s1.length()-1;i>=0;i--){
            for(int j=s2.length()-1;j>=0;j--){
                //match
                if(s1[i]==s2[j]){
                    currRow[j]= 1+nextRow[j+1];
                }else{//not a match
                    currRow[j]=max(currRow[j+1],nextRow[j]);
                }
            }
            nextRow=currRow;
        }
        return nextRow[0];
    }
    //Function to find the length of longest common subsequence in two strings.
    int lcs(int x, int y, string s1, string s2)
    {
        // your code here
        //return rec(s1,0,s2,0);
        /*vector<vector<int>> dp(x,vector<int> (y,-1));
        return recMemo(s1,0,s2,0,dp);
        */
        /*vector<vector<int>> dp(x+1,vector<int> (y+1,0));
         return tab(s1,s2,dp);
         */
         return tabSpaceOptimized(s1,s2);
    }
//21. Shortest Common Supersequence
 int tabSpaceOptimized(string s1,string s2){
        vector<int> currRow(s2.length()+1,0),nextRow(s2.length()+1,0);
        for(int i=s1.length()-1;i>=0;i--){
            for(int j=s2.length()-1;j>=0;j--){
                //match
                if(s1[i]==s2[j]){
                    currRow[j]= 1+nextRow[j+1];
                }else{//not a match
                    currRow[j]=max(currRow[j+1],nextRow[j]);
                }
            }
            nextRow=currRow;
        }
        return nextRow[0];
    }
    //Function to find the length of longest common subsequence in two strings.
    int lcs(int x, int y, string s1, string s2)
    {
         return tabSpaceOptimized(s1,s2);
    }
    //Function to find length of shortest common supersequence of two strings.
    int shortestCommonSupersequence(string X, string Y, int m, int n)
    {
        //code here
        return m+n-lcs(m,n,X,Y);
    }
//22.Number of Unique Paths
public:
    int rec(int a,int b,int i,int j){
        if(i>=a||j>=b) return 0;
        if(i==(a-1)&&j==(b-1)) return 1;
        return rec(a,b,i,j+1)+rec(a,b,i+1,j);
    }
    int recMemo(int a,int b,int i,int j,vector<vector<int>> &dp){
        if(i>=a||j>=b) return 0;
        if(i==(a-1)&&j==(b-1)) return 1;
        if(dp[i][j]!=-1) return dp[i][j];
        return dp[i][j]=(recMemo(a,b,i,j+1,dp)+recMemo(a,b,i+1,j,dp));
    }
    int tab(int a,int b,vector<vector<int>> &dp){
        dp[a-1][b-1]=1;
        for(int i=a-1;i>=0;i--){
            for(int j=b-1;j>=0;j--){
                if(i==a-1&&j==b-1) continue;
                dp[i][j]=(dp[i][j+1]+dp[i+1][j]);
            }
        }
        return dp[0][0];
    }
    int tabSpaceOptimized(int a,int b){
        vector<int> currRow(b+1,0),nextRow(b+1,0);
        currRow[b-1]=1;
        nextRow[b-1]=1;
        for(int i=a-1;i>=0;i--){
            for(int j=b-1;j>=0;j--){
                if(i==a-1&&j==b-1) continue;
                currRow[j]=(currRow[j+1]+nextRow[j]);
            }
            nextRow=currRow;
        }
        return nextRow[0];
    }
    //Function to find total number of unique paths.
    int NumberOfPath(int a, int b)
    {
        //code here
        //return rec(a,b,0,0);
        /*vector<vector<int>> dp(a,vector<int> (b,-1));
        return recMemo(a,b,0,0,dp);
        */
        /*vector<vector<int>> dp(a+1,vector<int> (b+1,0));
        return tab(a,b,dp);
        */
        return tabSpaceOptimized(a,b);
    }
//23. Maximize The Cut Segments
 public:
    int rec(int n,int x,int y,int z){
        if(n<0) return INT_MIN;
        if(n==0) return 0;
        int res=INT_MIN;
        int a=rec(n-x,x,y,z);
        if(a!=INT_MIN) res=max(res,a+1);
        int b=rec(n-y,x,y,z);
        if(b!=INT_MIN) res=max(res,b+1);
        int c=rec(n-z,x,y,z);
        if(c!=INT_MIN) res=max(res,c+1);
        return res;
    }
    int recMemo(int n,int x,int y,int z,vector<int> &dp){
        if(n<0) return INT_MIN;
        if(n==0) return 0;
        if(dp[n]!=-1) return dp[n];
        int res=INT_MIN;
        int a=recMemo(n-x,x,y,z,dp);
        if(a!=INT_MIN) res=max(res,a+1);
        int b=recMemo(n-y,x,y,z,dp);
        if(b!=INT_MIN) res=max(res,b+1);
        int c=recMemo(n-z,x,y,z,dp);
        if(c!=INT_MIN) res=max(res,c+1);
        return dp[n]=res;
    }
    int tab(int n,int x,int y,int z,vector<int> &dp){
        int arr[3]={x,y,z};
        for(int i=1;i<=n;i++){
            int res=0;
            for(int j=0;j<3;j++){
                if(arr[j]-i==0){
                    int ans=1;
                    res=max(res,ans);
                }else if(i-arr[j]<0){
                    int ans=0;
                    res=max(res,ans);
                }
                else if(arr[j]<i&&dp[i-arr[j]]>0){
                    int ans=1+dp[i-arr[j]];
                    res=max(res,ans);
                }
            }
            dp[i]=res;
        }
        return dp[n];
    }
    //Function to find the maximum number of cuts.
    int maximizeTheCuts(int n, int x, int y, int z)
    {
        //Your code here
        //return rec(n,x,y,z);
        /*vector<int> dp(n+1,-1);
        int ans=recMemo(n,x,y,z,dp);
        */
        vector<int> dp(n+1,0);
        int ans=tab(n,x,y,z,dp);
        if(ans==INT_MIN) return 0;
        else return ans;
    }
//24. Subset Sum Problems
public:
    int rec(vector<int> &arr,int target,int ind){
        if(ind>=arr.size()||target<0) return 0;
        if(target==0) return 1;
        int include=rec(arr,target-arr[ind],ind+1);
        int exclude=rec(arr,target,ind+1);
        return max(include,exclude);
    }
    int recMemo(vector<int> &arr,int target,int ind,vector<vector<int>> &dp){
        if(ind>=arr.size()||target<0) return dp[ind+1][target+1]=0;
        if(target==0) return dp[ind+1][target+1]=1;
        if(dp[ind+1][target+1]!=-1) return dp[ind+1][target+1];
        int include=0;
        if(target>=arr[ind]){
          include=recMemo(arr,target-arr[ind],ind+1,dp);
        }
        int exclude=recMemo(arr,target,ind+1,dp);
        return dp[ind+1][target+1]=max(include,exclude);
    }
/* int tab(vector<int> &arr,int target,vector<vector<int>> &dp){
       for(int i=0;i<arr.size();i++) dp[i][0]=1;
       for(int i=0;i<arr.size();i++){
           for(int j=1;j<=target;j++){
              if(i==0&&arr[i]==j) dp[i][j]=1;
              if(i-1>=0){
                  int include=0;
                  if(j-arr[i]>=0){
                      include=dp[i-1][j-arr[i]];
                  }
                  int exclude=dp[i-1][j];
                  dp[i][j]=max(include,exclude);
              }
           }
       }
       return dp[arr.size()-1][target];
   }*/
   int tab(vector<int> &arr,int target,vector<vector<int>> &dp){
       for(int i=0;i<=arr.size();i++) dp[i][0]=1;
       for(int i=arr.size()-1;i>=0;i--){
           for(int j=0;j<=target;j++){
                  int include=0;
                  if(j-arr[i]>=0){
                      include=dp[i+1][j-arr[i]];
                  }
                  int exclude=dp[i+1][j];
                  dp[i][j]=max(include,exclude);
              
           }
       }
       return dp[0][target];
   }
    bool isSubsetSum(vector<int>arr, int sum){
        // code here 
        //return rec(arr,sum,0);
        /*vector<vector<int>> dp(arr.size()+1,vector<int> (sum+1,-1));
        return (bool)recMemo(arr,sum,0,dp);
        */
        /* vector<vector<int>> dp(arr.size(),vector<int> (sum+1,0));
        return tab(arr,sum,dp);
       */
        vector<vector<int>> dp(arr.size()+1,vector<int> (sum+1,0));
        return tab(arr,sum,dp);
    }
//25. 0 - 1 Knapsack Problem
 int rec(int w,int wt[],int val[],int n,int ind){
        if(ind>=n||w<=0) return 0;
        int inc=0;
        if(w>=wt[ind]) inc=val[ind]+rec(w-wt[ind],wt,val,n,ind+1);
        int exc=rec(w,wt,val,n,ind+1);
        return max(inc,exc);
    }
    int recMemo(int w,int wt[],int val[],int n,int ind,vector<vector<int>> &dp){
        if(ind>=n||w<=0) return dp[ind][w]=0;
        if(dp[ind][w]!=-1) return dp[ind][w];
        int inc=0;
        if(w>=wt[ind]) inc=val[ind]+recMemo(w-wt[ind],wt,val,n,ind+1,dp);
        int exc=recMemo(w,wt,val,n,ind+1,dp);
        return dp[ind][w]=max(inc,exc);
    }
    int tab(int w,int wt[],int val[],int n,vector<vector<int>> &dp){
        for(int i=n-1;i>=0;i--){
            for(int j=0;j<=w;j++){
                    int exc=dp[i+1][j];
                    int inc=0;
                    if(j-wt[i]>=0) inc=val[i]+dp[i+1][j-wt[i]];
                    dp[i][j]=max(inc,exc);
            }
        }
        return dp[0][w];
    }
    //Function to return max value that can be put in knapsack of capacity W.
    int knapSack(int W, int wt[], int val[], int n) 
    { 
       // Your code here
      // return rec(W,wt,val,n,0);
     /* vector<vector<int>> dp(n+1,vector<int> (W+1,-1));
      int ans=recMemo(W,wt,val,n,0,dp);
      if(ans<=0) return 0;else return ans;
      */
      vector<vector<int>> dp(n+1,vector<int> (W+1,0));
      return tab(W,wt,val,n,dp);
    }
//26. Optimal Strategy For A Game
public:
/*
Approach: As both the players are equally strong, both will try to reduce the possibility of winning of each other. Now lets see how the opponent can achieve this.
There are two choices:
1-The user chooses the ith coin with value Vi: The opponent either chooses (i+1)th coin or jth coin. The opponent intends to choose the coin which leaves the user with minimum value. 
  i.e. The user can collect the value Vi + min(F(i+2, j), F(i+1, j-1) ) where [i+2,j] is the range of array indices available to the user if the opponent chooses Vi+1 and [i+1,j-1] is the range of array indexes available if opponent chooses the jth coin. 
2-The user chooses the jth coin with value Vj: The opponent either chooses ith coin or (j-1)th coin. The opponent intends to choose the coin which leaves the user with minimum value, i.e. the user can collect the value Vj + min(F(i+1, j-1), F(i, j-2) ) where [i,j-2] is the range of array indices available for the user if the opponent picks jth coin and [i+1,j-1] is the range of indices available to the user if the opponent picks up the ith coin.
*/
    long long rec(int arr[],int n,int i,int j){
        if(i==j) return arr[i];
        if(i+1==j) return max(arr[i],arr[j]);
        long long int choiceI=arr[i]+min(rec(arr,n,i+2,j),rec(arr,n,i+1,j-1));
        long long int choiceJ=arr[j]+min(rec(arr,n,i+1,j-1),rec(arr,n,i,j-2));
        return max(choiceI,choiceJ);
    }
    long long recMemo(int arr[],int n,int i,int j,vector<vector<int>> &dp){
        if(i==j) return arr[i];
        if(i+1==j) return max(arr[i],arr[j]);
        if(dp[i][j]!=-1) return dp[i][j];
        long long int choiceI=arr[i]+min(recMemo(arr,n,i+2,j,dp),recMemo(arr,n,i+1,j-1,dp));
        long long int choiceJ=arr[j]+min(recMemo(arr,n,i+1,j-1,dp),recMemo(arr,n,i,j-2,dp));
        return dp[i][j]=max(choiceI,choiceJ);
    }
    long long int tab(int arr[],int n,vector<vector<int>> &dp){
        for(int i=n-1;i>=0;i--){
            for(int j=0;j<=n-1;j++){
                if(i==j) dp[i][j]=arr[i];
                else if(i+1==j) dp[i][j]=max(arr[i],arr[j]);
                else{
                    long long int choiceI=0,a=0,b=0;
                    if(i+2<=n&&j>=0) a=dp[i+2][j];
                    if(i+1<=n&&j-1>=0) b=dp[i+1][j-1];
                    choiceI=arr[i]+min(a,b);
                    long long int choiceJ=0;
                    if(i+1<=n&&j-1>=0) a=dp[i+1][j-1];
                    if(i<=n&&j-2>=0) b=dp[i][j-2];
                    choiceJ=arr[j]+min(a,b);
                    dp[i][j]=max(choiceI,choiceJ);
                }
            }
        }
        return dp[0][n-1];
    }
    long long int tabSpaceOptimized(int arr[],int n){
        vector<int> curr(n+1,0),next1(n+1,0),next2(n+1,0);
        for(int i=n-1;i>=0;i--){
            for(int j=0;j<=n-1;j++){
                if(i==j) curr[j]=arr[i];
                else if(i+1==j) curr[j]=max(arr[i],arr[j]);
                else{
                    long long int choiceI=0,a=0,b=0;
                    if(i+2<=n&&j>=0) a=next2[j];
                    if(i+1<=n&&j-1>=0) b=next1[j-1];
                    choiceI=arr[i]+min(a,b);
                    long long int choiceJ=0;
                    if(i+1<=n&&j-1>=0) a=next1[j-1];
                    if(i<=n&&j-2>=0) b=curr[j-2];
                    choiceJ=arr[j]+min(a,b);
                    curr[j]=max(choiceI,choiceJ);
                }
            }
            next2=next1;
            next1=curr;
        }
        return curr[n-1];
    }
    long long maximumAmount(int arr[], int n){
        // Your code here
       // return rec(arr,n,0,n-1);
       /*vector<vector<int>> dp(n+1,vector<int> (n+1,-1));
       return recMemo(arr,n,0,n-1,dp);
       */
       vector<vector<int>> dp(n+1,vector<int> (n+1,0));
       return tabSpaceOptimized(arr,n);
    }
//27. Egg Dropping Puzzle
int rec(int n,int k){
        if(n==1) return k;
        if(k==0||k==1) return k;
        int res=INT_MAX;
        for(int f=1;f<=k;f++){
            int temp=1+max(rec(n-1,f-1),rec(n,k-f));
            res=min(res,temp);
        }
        return res;
    }
    int recMemo(int n,int k,vector<vector<int>> &dp){
        if(n==1) return k;
        if(k==0||k==1) return k;
        if(dp[n][k]!=-1) return dp[n][k];
        int res=INT_MAX;
        for(int f=1;f<=k;f++){
            int temp=1+max(recMemo(n-1,f-1,dp),recMemo(n,k-f,dp));
            res=min(res,temp);
        }
        return dp[n][k]=res;
    }
    int tab(int n,int k,vector<vector<int>> &dp){
        for(int i=1;i<=n;i++){
            for(int j=0;j<=k;j++){
                if(i==1) dp[i][j]=j;
                else if(j==0||j==1) dp[i][j]=j;
                else{
                    int res=INT_MAX;
                    for(int f=1;f<=k;f++){
                        int temp=0,a=0,b=0;
                        if(i-1<=n&&j<=k) a=dp[i-1][f-1];
                        if(i<=n&&j-f<=k) b=dp[i][j-f];
                        temp=1+max(a,b);
                        res=min(res,temp);
                    }
                    dp[i][j]=res;
                }
            }
        }
        return dp[n][k];
    }
    int tabSpaceOptimized(int n,int k){
        vector<int> currRow(k+1,0),prevRow(k+1,0);
        for(int i=1;i<=n;i++){
            for(int j=0;j<=k;j++){
                if(i==1) currRow[j]=j;
                else if(j==0||j==1) currRow[j]=j;
                else{
                    int res=INT_MAX;
                    for(int f=1;f<=k;f++){
                        int temp=0,a=0,b=0;
                        if(i-1<=n&&j<=k) a=prevRow[f-1];
                        if(i<=n&&j-f<=k) b=currRow[j-f];
                        temp=1+max(a,b);
                        res=min(res,temp);
                    }
                    currRow[j]=res;
                }
            }
            prevRow=currRow;
        }
        return prevRow[k];
    }
    //Function to find minimum number of attempts needed in 
    //order to find the critical floor.
    int eggDrop(int n, int k) 
    {
        // your code here
        //return rec(n,k);
        /*vector<vector<int>> dp(n+1,vector<int> (k+1,-1));
        return recMemo(n,k,dp);
        */
        /*vector<vector<int>> dp(n+1,vector<int>(k+1,0));
        return tab(n,k,dp);
        */
        return tabSpaceOptimized(n,k);
    }
//28. Stickler Thief
public:
    int rec(int arr[],int n,int ind){
        if(ind>=n) return 0;
        int inc=arr[ind]+rec(arr,n,ind+2);
        int exc=rec(arr,n,ind+1);
        return max(inc,exc);
    }
    int recMemo(int arr[],int n,int ind,vector<int> &dp){
        if(ind>=n) return 0;
        if(dp[ind]!=-1) return dp[ind];
        int inc=arr[ind]+recMemo(arr,n,ind+2,dp);
        int exc=recMemo(arr,n,ind+1,dp);
        return dp[ind]=max(inc,exc);
    }
    int tab(int arr[],int n,vector<int> &dp){
        dp[n+1]=0;
        for(int i=n-1;i>=0;i--){
            int inc=arr[i]+dp[i+2];
            int exc=dp[i+1];
            dp[i]=max(inc,exc);
        }
        return dp[0];
    }
    int tabSpaceOptimized(int arr[],int n){
        int curr=0,next1=0,next2=0;
        for(int i=n-1;i>=0;i--){
            int inc=arr[i]+next2;
            int exc=next1;
            curr=max(inc,exc);
            next2=next1;
            next1=curr;
        }
        return curr;
    }
    //Function to find the maximum money the thief can get.
    int FindMaxSum(int arr[], int n)
    {
        // Your code here
        //return rec(arr,n,0);
        /*vector<int> dp(n+1,-1);
        return recMemo(arr,n,0,dp);
        */
        /*vector<int> dp(n+2,0);
        return tab(arr,n,dp);
        */
        return tabSpaceOptimized(arr,n);        
    }
//Maximum path sum in matrix
public:
    long long int rec(int n,vector<vector<int>> &matrix,int r,int c,long long int sum){
        if(r<0||r>=n||c<0||c>=n) return 0;
        long long int a=0,b=0,d=0,res=0;
        a=rec(n,matrix,r+1,c,sum);
        b=rec(n,matrix,r+1,c-1,sum);
        d=rec(n,matrix,r+1,c+1,sum);
        res=max(a,max(b,d));
        return matrix[r][c]+res;
    }
    long long int recMemo(int n,vector<vector<int>> &matrix,int r,int c,long long int sum,vector<vector<int>> &dp){
        if(r<0||r>=n||c<0||c>=n) return 0;
        if(dp[r][c]!=-1) return dp[r][c];
        long long int a=0,b=0,d=0,res=0;
        a=recMemo(n,matrix,r+1,c,sum,dp);
        b=recMemo(n,matrix,r+1,c-1,sum,dp);
        d=recMemo(n,matrix,r+1,c+1,sum,dp);
        res=max(a,max(b,d));
        return dp[r][c]=matrix[r][c]+res;
    }
    long long int tab(int n,vector<vector<int>> &matrix,vector<vector<int>> &dp){
        for(int j=0;j<n;j++){//last row will remain same
            dp[n-1][j]=matrix[n-1][j];
        }
        for(int i=n-2;i>=0;i--){
            for(int j=n-1;j>=0;j--){
                long long int a=0,b=0,d=0,res=0;
                if(i+1<n){a=dp[i+1][j];}
                if(i+1<n&&j-1>=0){b=dp[i+1][j-1];}
                if(i+1<n&&j+1<n){d=dp[i+1][j+1];}
                res=max(a,max(b,d));
                dp[i][j]=matrix[i][j]+res;
            }
        }
        long long int res=0,ans=0;
        for(int j=0;j<n;j++){
            res=dp[0][j];
            ans=max(ans,res);
        }
        return ans;
    }
    long long int tabSpaceOptimized(int n,vector<vector<int>> &matrix){
        vector<int> currRow(n,0),nextRow(n,0);
        for(int j=0;j<n;j++){//last row will remain same
            nextRow[j]=matrix[n-1][j];
        }
        for(int i=n-2;i>=0;i--){
            for(int j=n-1;j>=0;j--){
                long long int a=0,b=0,d=0,res=0;
                if(i+1<n){a=nextRow[j];}
                if(i+1<n&&j-1>=0){b=nextRow[j-1];}
                if(i+1<n&&j+1<n){d=nextRow[j+1];}
                res=max(a,max(b,d));
                currRow[j]=matrix[i][j]+res;
            }
            nextRow=currRow;
        }
        long long int res=0,ans=0;
        for(int j=0;j<n;j++){
            res=nextRow[j];
            ans=max(ans,res);
        }
        return ans;
    }
    int maximumPath(int N, vector<vector<int>> Matrix)
    {
        // code here
        /*long long int res=0,ans=0;
        for(int j=0;j<N;j++){
         res=rec(N,Matrix,0,j,0);
         ans=max(ans,res);
        }
        return ans;
        */
       /* vector<vector<int>> dp(N+1,vector<int> (N+1,-1));
        long long int res=0,ans=0;
        for(int j=0;j<N;j++){
         res=recMemo(N,Matrix,0,j,0,dp);
         ans=max(ans,res);
        }
        return ans;
        */
        /*vector<vector<int>> dp(N,vector<int> (N,0));
        return tab(N,Matrix,dp);
        */
        return tabSpaceOptimized(N,Matrix);
    }
TRIE:
//01. Trie _ (Insert and Search)
// trie node
/*
struct TrieNode {
    struct TrieNode *children[ALPHABET_SIZE];

    // isLeaf is true if the node represents
    // end of a word
    bool isLeaf;
};
struct TrieNode *getNode(void){
  struct TrieNode *pNode=NULL;
  pNode=(struct TrieNode*) malloc(sizeof(struct TrieNode));
  if(pNode){
    int i;
    pNode->isLeaf=false;
    for(i=0;i<26;i++) pNode->children[i]=NULL;
  }
  return pNode;
}
*/

//Function to insert string into TRIE.
void insert(struct TrieNode *root, string key)
{
    // code here
    if(key.length()==0){
        root->isLeaf=true;
        return;
    }
    TrieNode* child=NULL;
    if(root->children[key[0]-'a']!=NULL) child=root->children[key[0]-'a'];
    else{
        child=getNode();
        root->children[key[0]-'a']=child;
    }
    insert(child,key.substr(1));
}

//Function to use TRIE data structure and search the given string.
bool search(struct TrieNode *root, string key) 
{
    // code here
     if(key.length()==0){
        return root->isLeaf;
    }
    TrieNode* child=NULL;
    if(root->children[key[0]-'a']!=NULL) child=root->children[key[0]-'a'];
    else{
        return false;
    }
    return search(child,key.substr(1));
}
//02.Search Query for Strings
	vector<int>SolveQueris(string str, vector<vector<int>>Query){
	    // Code here
	    vector<int> ans;
	    for(auto q:Query){
	        int l=q[0]-1,r=q[1]-1;
	        string s=str.substr(l,r-l+1);
	        unordered_map<int,int> h;
	        for(auto i:s){
	          h[i]++;   
	        }
	        ans.push_back(h.size());
	    }
	    return ans;
	}
//03.Camel Case
public:
    /* typedef struct trieNode{
        trieNode *children[26];
        bool isLeaf;
        trieNode(){
            isLeaf=false;
            for(int i=0;i<26;i++) children[i]=NULL;
        }
    }tN;
    
    void insertWord(string s,tN *root){
        tN *curr=root;
        for(int i=0;i<s.length();i++){
            if(s[i]>='A'&&s[i]<='Z'){
              if(curr->children[s[i]-'A']!=NULL){
                  curr=curr->children[s[i]-'A'];
              }
              else{
                  tN *t=new tN();
                  curr->children[s[i]-'A']=t;
                  curr=t;
              }
                
            }
            if(i==s.length()-1) curr->isLeaf=true;
        }
    }
    bool searchWord(string s,tN *root,string pattern){
        tN *curr=root;
        int patInd=0;
        for(int i=0;i<s.length();i++){
            if(s[i]>='A'&&s[i]<='Z'&&patInd<pattern.size()){
              if(pattern[patInd++]!=s[i]){
                  return false;
              }
              else if(curr->children[s[i]-'A']==NULL){return false;}
              else{
                  curr=curr->children[s[i]-'A'];
              }
            }
        }
        if(curr!=NULL&&patInd==pattern.length()) return true;
        else return false;
    }
    */
    vector<string> CamelCase(int N, vector<string> Dictionary, string Pattern) {
        // code here
      /* tN *root=new tN();
       for(auto i:Dictionary){
         insertWord(i,root);
       }
       vector<string> ans;
        for(auto i:Dictionary){
         if(searchWord(i,root,Pattern)) ans.push_back(i);
       }
       return ans;
       */
       vector<string> ans;
       for(auto w:Dictionary){
           int patInd=0,i=0;
           for(i=0;i<w.length();i++){
               if(w[i]>='A'&&w[i]<='Z'&&patInd<Pattern.length()){
                   if(w[i]!=Pattern[patInd++]) break;
               }
           }
           if(patInd==Pattern.length()&&i==w.length()) ans.push_back(w);
       }
       return ans;
    }
};