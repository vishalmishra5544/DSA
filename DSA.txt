MATHEMATICS AND BASICS:
//finding number of digits in a number
int numOfDigits(int n){
return floor(log10(n))+1;
}
//factorial
int fact(int n){
int res=1;
for(int i=n;i>=1;i--)
  res=res*i;
return res;  
}
//palindrome
int palindrome(int n){
int res=n,rev=0;
while(n>0){
 rev=rev*10+n%10;
 n=n/10;
}
return (res==rev);
}
//gcd or hcf
int gcd(int a,int b){
while(a!=b){
if(a>b) a=a-b;
if(b>a) b=b-a;
}
return a;
}
//peak element
  public:
    int findPeak(int arr[],int n,int l,int r){
        int mid=l+(r-l)/2;
        if((mid==n-1||arr[mid]>=arr[mid+1])&&(mid==0||arr[mid-1]<=arr[mid])){
           return mid;
       }else if(mid<n-1&&arr[mid]<arr[mid+1]){
           findPeak(arr,n,mid+1,r);
       }else if(mid>0 && arr[mid-1]>arr[mid]){
           findPeak(arr,n,l,mid-1);
       }
    }
    int peakElement(int arr[], int n)
    {
       // Your code here
       int l=0,r=n-1;
       return findPeak(arr,n,l,r);
       }
return a;
}
//lcm
int lcm(int a,int b){
return (a*b)/(gcd(a,b));
}
//check for prime
bool prime(int n){
if(n==1) return false;
if(n==2||n==3) return true;
if(n%2==0||n%3==0) return false;
for(int i=5;i*i<=n;i=i+6){
 if(n%i==0||n%(i+2)==0) return false;
}
return true;
}
//prime factors
void primeFactors(int n){
while(n%2==0){
n=n/2;
cout<<2<<endl;
}
while(n%3==0){
n=n/3;
cout<<3<<endl;
}
for(int i=5;i*i<=n;i=i+6){
 while(n%i==0){
 n=n/i;
 cout<<i<<endl;
 }
 while(n%(i+2)==0){
 n=n/(i+2);
 cout<<(i+2)<<endl;
 }
}
if(n>3)
 cout<<n<<endl;
}
//All divisors of a number
void allDivisors(int n){
for(int i=1;i*i<=n;i++){
 if(n%i==0) cout<<i<<endl;
}
for(;i>=1;i--){
 if(n%i==0) cout<<n/i<<endl;
}
}
//Sieve of erathosthenes //Prints all prime numbers till n;
void sieve(int n){
vector<bool> sieve(n+1,true);
for(int i=2;i*i<=n;i++){
 if(sieve[i]==true){
  for(int j=i*i;j<=n;j++){
  sieve[i]=false;
  }
 }
}
for(int i=2;i<=n;i++){
 if(sieve[i]==true) cout<<i<<endl;
}
}


BIT MANIPULATION:
 // Function to check if given number n is a power of two.
    bool isPowerofTwo(long long n){
        
        // Your code here    
        return (n>0)&&((n&(n-1))==0);
        
    }
// getting first set bit
unsigned int getFirstSetBit(int n)
    {
       return log2(n^(n&(n-1)))+1;
    }
//Function to find the first position with different bits.
    int posOfRightMostDiffBit(int m, int n)
    {
        // Your code here
        int i=m^n,res=-1;
        res=(log2(i^(i&(i-1)))+1);
        if(res>-1) return res;
        else return -1;
    }
// Function to check if Kth bit is set or not.
    bool checkKthBit(int n, int k)
    {
        // Your code here
        // It can be a one liner logic!! Think of it!!
        return n&(1<<k);
    }
//count set bit in an integer
 int setBits(int N) {
        // Write Your Code here
        int lookup[256]={0};
        for(int i=1;i<256;i++)
            lookup[i]=(i&1)+lookup[i/2];
        int res=0;
        while(N>0){
            res=res+lookup[N&0xff];
            N=N>>8;
        }
       return res;
    }
//count set bit from 1 to n
//method-1-DP LOOKUP
int lookup[n+1]={0};
for(int i=1;i<n;i++)
    lookup[i]=(i&1)+lookup[i/2];
int res=0;
for(int i=n;i>=1;i--){
    res=res+lookup[n&0xff];
 }
return res;
//method-2-o(logn)
 int countSetBits(int n){
        n++;
        int countsetbits=n/2,pairs=0,setbits=0,remainingsetbits=0;
        int powerof2=2;
        while(powerof2<=n){
        pairs=n/powerof2;
        setbits=(pairs/2)*powerof2;
        remainingsetbits=(pairs&1)?n%powerof2:0;
        countsetbits=countsetbits+setbits+remainingsetbits;
        powerof2=powerof2<<1;
        }
    return countsetbits;
    }
 // Function to find number of bits needed to be flipped to convert A to B
    int countBitsFlip(int a, int b){
        
        // Your logic her
        int n=a^b;
        return __builtin_popcount(n);
        
    }
//Function to check if the number is sparse or not.
    bool isSparse(int n)
    {
        // Your code
        int flag=0;
        while(n>0){ 
            if(flag==2) return 0;
            if(n&1==1) flag+=1;
            else flag=0;  
            n=n>>1;
        }
        if(flag==2) return 0;
        return 1;
    }
//longest consecutive ones
int maxConsecutiveOnes(int N)
    {
        // code here
         int n=N,flag=0,maxlen=0;
        while(n>0){ 
            if(n&1==1){  flag+=1;maxlen=max(maxlen,flag);}
            else flag=0;  
            n=n>>1;
        }
      return maxlen;
    }
//binary to gray code
 string binToGrey(string B) {
        // code here
        string g;
        g.push_back(B[0]);
        for(int i=1;i<B.length();i++){
            char res=(B[i-1]==B[i])?'0':'1';
            g.push_back(res);
            }
        return g;
    }
// gray code to binary    
    string greyToBin(string G) {
        // code here
        string b="";
        b.push_back(G[0]);
        for(int i=1;i<G.length();i++){
         char res=(b[i-1]==G[i])?'0':'1';
          b.push_back(res);
        }
        return b;
    }
 //Function to swap odd and even bits.
    unsigned int swapBits(unsigned int n)
    {
    	// Your code here
    for(int i=0;i<32;i=i+2){//since int is 32 bit and check for i and i+1 th at a time
    int ithbit=(n>>i)&1;//get ith bit
    int iplus1thbit=(n>>(i+1))&1;//get i+1 th bit
    n=n-(ithbit<<i)-(iplus1thbit<<(i+1))+(ithbit<<(i+1))+(iplus1thbit<<i);//remove ith bit and i+1 th bit and addnew swapped values of ith and i+1 th bit
    }
    return n;
    }
//Maximum AND value of any pair in an array.
int checkBits(int * arr,int n,int pattern){
        int count=0;
        for(int i=0;i<n;i++){
            if((arr[i]&pattern)==pattern)//if there is a num in arr which has his bit set then do count++
                count++;// so if two or more such num present then this bit can be included in our pattern or final res.
        }
        return count;
    }
    // Function for finding maximum AND value.
    int maxAND (int arr[], int N)
    {
        // Your code here
        int res=0,setbit,count=0;
        for(int i=31;i>=0;i--){
            setbit=res|(1<<i); //set i th bit and add res or pattern(a number which will have set bits only when two such num in arr are present having this bit set) till now to check if this bit can be included or not
            count=checkBits(arr,N,setbit);// check if this setbit can be included or not
            if(count>=2)//means there are 2 numbers having this bit set thus on doing their AND this bit will be included else not
                res=res|(1<<i);//include this setbit
            
        }
        return res;
    }


RECURSION:
//Print 1 to n without using loops
    void printTillN(int N)
    {
        // Write Your Code here
        if(N<=0) return;
        printTillN(N-1);
        cout<<N<<" ";
    }
//Sum of digits
 int sumOfDigits(int N){
        //code here
        int digit=0;
       while(N>0){
           digit+=N%10;
           N=N/10;
       }
       return digit;
    }
//count digits
int evenlyDivides(int N){
        //code here
        int digit=0,count=0,n=N;
        while(N>0){
            digit=N%10;
            if(digit!=0&&n%digit==0) count++;
            N=N/10;
        }
        return count;
    }
//Digital Roots -(get repeated sum until it becomes single digit and check if it is prime or not)
public:
    int DigitalRoot(int N){//get repeated sum until it becomes single digit
        if(N<=9) return N;
        
        return (N%9==0)?9:(N%9);
    }
    int digitisPrime(int n){
        for(int i=2;i*i<=n;i++){
            if(n%i==0) return 0;
        }
        return 1;
    }
    int digitalRoot(int N)
    {
        // Write Your Code here
        int ans=DigitalRoot(N);
        if(ans<=1) return 0;
        return digitisPrime(ans);
    }
//Nth fibonacci number
public:
    long long int nthFibonacci(long long int n){
        // code here
        int fib1=1,fib2=1,fib=0;
        if(n<=0) return 0;
        if(n==1||n==2) return 1;
        for(long long int i=3;i<=n;i++){
            fib=(fib1+fib2)%1000000007;
            fib2=fib1;
            fib1=fib;
        }
        return fib;
    }
//Tower of hanoi
public:
    // You need to complete this function

    // avoid space at the starting of the string in "move disk....."
    //long long int moves=1;
    void moves(int N,int from,int to,int aux){
        if(N<1) return;
        if(N==1) {
            cout<<"move disk "<<N<<" from rod "<<from<<" to rod "<<to<<"\n";
            return;
        }
        toh(N-1,from,aux,to);
        //move 1th from 1 to 3 ;
        cout<<"move disk "<<N<<" from rod "<<from<<" to rod "<<to<<"\n";
        toh(N-1,aux,to,from);
    }
    long long toh(int N, int from, int to, int aux) {
        // Your code here
        moves(N,from,to,aux);
        return pow(2,N)-1;
    }
//josephus problem
class Solution
{
    public:
    int josephus(int n, int k)
    {
       //Your code here
       if(n<=1) return 1;
       
       return (josephus(n-1,k)+k-1)%n+1;//adjustments as k%n +1 is treated as 1st in every call.and here ordering are from 1 to N
    }
};

// lucky numbers
bool myFun(int n, int x)
    {
        if(n%x == 0)
            return false;
        if(x > n)
            return true;
        return myFun(n-(n/x), x+1);    
    }
    bool isLucky(int n) {
        return myFun(n, 2);
    }
//Power of Numbers - given N,R(reverse of N) find N power R  (fast exponentiation)
 public:
    //You need to complete this fucntion
    
    long long power(int N,int R)
    {
       //Your code here
       long long int res=1,base=N;
       while(R>0){
           if(R&1){
           res=(res*base)%1000000007;
           }
           base=(base*base)%1000000007;
           R=R>>1;
       }
       return res;
        
    }
//power set using recursion -print in lexicographically order with duplicates also
	public:
	  vector<string> ans;
	  multimap<string,int> a;
	  void powerSet(string &s,int i,string curr=""){
	       if(i==s.length()){ 
	           //a[curr]++;
	           a.insert(pair<string,int>(curr,1));
	           return;
	       }
	       
	       powerSet(s,i+1,curr+s[i]);
	       powerSet(s,i+1,curr);
	   }
	  
		vector<string> AllPossibleStrings(string s){
		    // Code here
		    int i=0;
		    powerSet(s,i,"");
		    a.erase("");
		    for(auto itr=a.begin();itr!=a.end();itr++)
		       ans.push_back(itr->first);
		    return ans;
		}

//Possible words from phone digits
public:
    vector<string> ans;
    map<int,string> mp;
    map<string,int> res;
    void possible(int a[],int n,string curr,int i){
        if(i==n){
            res[curr]++;
            return;
        }
        int digit=a[i];
        int len=mp[digit].length();
        for(int j=0;j<len;j++){ //for this digit check its alphabet string and iterate over it by including one at a time and recursively calling for next digit's string and repeat till last digit in input array a is reached thus when i==n return.
        string temp=mp[digit];
        possible(a,n,curr+temp[j],i+1);
        
        }
    }
    //Function to find list of all words possible by pressing given numbers.
    vector<string> possibleWords(int a[], int N)
    {
        //Your code here
  //store mapping of digits with alphabets
   mp.insert({0,""});
   mp.insert(make_pair(1,""));
   mp.insert(make_pair(2,"abc"));
   mp.insert(make_pair(3,"def"));
   mp.insert(make_pair(4,"ghi"));
   mp.insert(make_pair(5,"jkl"));
   mp.insert(make_pair(6,"mno"));
   mp.insert(make_pair(7,"pqrs"));
   mp.insert(make_pair(8,"tuv"));
   mp.insert(make_pair(9,"wxyz"));
   
        possible(a,N,"",0);
        for(auto itr=res.begin();itr!=res.end();itr++)
           ans.push_back(itr->first);
        return ans;
    }



ARRAYS:
//Finding majority element(element appearing greater than N/2) 
//using moore's voting algo-O(n)
 int majorityElement(int arr[], int size)
    {        
        // your code here
        int major=arr[0],count=0;
        for(int i=0;i<size;i++){
            if(major==arr[i]){
                count++;
            }else count--;
            if(count==0){
                major=arr[i];
                count=1;
            } 
        }
        count=0;
        for(int i=0;i<size;i++){
            if(arr[i]==major)
             count++;
        }
        if(count>size/2)
         return major;
        else return -1;      
       
    }
//second max in array (but ensure largest should not be equal to second largest)
 int print2largest(int arr[], int arr_size)
    {
    	//code here.
    	int largest=arr[0],secondlargest=-1;
    	for(int i=1;i<arr_size;i++){
    	    if(arr[i]>largest){ secondlargest=largest;largest=arr[i];}
    	    else if(arr[i]>secondlargest &&arr[i]!=largest){secondlargest=arr[i];}
    	}
      return secondlargest;	
    }
//find max value of(a[i]-i)-(a[j]-j) such that i!=j
 int maxVal(int a[], int n) {
        int maxval=INT_MIN,minval=INT_MAX;
        for(int i=0;i<n;i++){
            if((a[i]-i)>maxval) maxval=(a[i]-i);
            if((a[i]-i)<minval) minval=(a[i]-i);
        }
     return maxval-minval;
    }
//reverse array in groups
public:
void reverse(vector<long long>& arr, int n,int i,int k){
    int low=i,high=min(i+k-1,n-1);
    while(low<high){
        swap(arr[low],arr[high]); 
        low++,high--;
    }
}
    //Function to reverse every sub-array group of size k.
    void reverseInGroups(vector<long long>& arr, int n, int k){
        // code here
        for(int i=0;i<n;i+=(k)){
            reverse(arr,n,i,k);
        }
    }
//Rotate array by d
 public:
    void reverseArr(int arr[], int n,int low,int high){
        while(low<high){
        swap(arr[low],arr[high]); 
        low++,high--;
      }
   }
    //Function to rotate an array by d elements in counter-clockwise direction. 
    void rotateArr(int arr[], int d, int n){
        // code here
        if(d>n){
            d=d-n;
        }
        reverseArr(arr,n,0,d-1);
        reverseArr(arr,n,d,(n-1));
        reverseArr(arr,n,0,n-1);
        
    }
//Maximum occurred integer-(given n ranges find max appearing element in the ranges given)
 public:
    // L and R are input array
    // maxx : maximum in R[]
    // n: size of array
    // arr[] : declared globally with size equal to maximum in L[] and R[]
    //Function to find the maximum occurred integer in all ranges.
    int maxOccured(int L[], int R[], int n, int maxx){
    
        // Your code here
        int arr[1000000];
        memset(arr,0,sizeof arr);
        for(int i=0;i<n;i++){
            arr[L[i]]++;//mark start of ith range as 1
            arr[R[i]+1]--;//mark end of ith range as -1;
        }
        int maxOccurrences=arr[0],maxAppearingNumber=0;
        for(int i=1;i<1000000;i++){//prefix sum to get max occuring value (no of ranges in which it appears)of all numbers from 0 to 100000 
            arr[i]=arr[i]+arr[i-1];
            if(maxOccurrences<arr[i]){
                maxOccurrences=arr[i];
                maxAppearingNumber=i;
            }
        }
        return maxAppearingNumber;
    }
//wave array
public:
    // arr: input array
    // n: size of array
    //Function to sort the array into a wave-like array.
    void convertToWave(vector<int>& arr, int n){
        
        // Your code here
        for(int i=1;i<n;i+=2){
            swap(arr[i],arr[i-1]);
        }
        
    }
//frequencies of limited range array elements (in o(1) aux space)
public:
  //Function to count the frequency of all elements from 1 to N in the array.
  void frequencyCount(vector<int>& arr,int n, int P)
  {
    int expectedPos, pos=0;
    while (pos<n)
    {
        expectedPos = arr[pos]-1;
        if (arr[pos] >0 && arr[pos]<=n && arr[expectedPos]>0)
        {
            arr[pos] = arr[expectedPos];
            arr[expectedPos] = -1;
        }
        else if (arr[pos] >0 && arr[pos]<=n)
        {
            arr[expectedPos]--;
            arr[pos++] = 0;
        }
        else
        {
            pos++;
        }
    }
    for (int i=0;i<n;i++)
    { if(arr[i]>0) arr[i]=0;
        arr[i]=abs(arr[i]);    
    } 
 }
// equilibrium point
 public:
    // Function to find equilibrium point in the array.
    // a: input array
    // n: size of array
    int equilibriumPoint(long long arr[], int n) {
    
        // Your code here
        
        for(int i=1;i<n;i++){
            arr[i]=arr[i]+arr[i-1]; 
       }
       for(int i=0;i<n;i++){
           if(i==0){
               if(arr[n-1]-arr[0]==0) return 1;
           }
           if(arr[i-1]==(arr[n-1]-arr[i-1]-(arr[i]-arr[i-1]))){
               return i+1;
           }
       }
       return -1;
    }
//Leaders in an array
 //Function to find the leaders in the array.
    public:
    vector<int> leaders(int a[], int n){
        // Code here
        int lastGreater=a[n-1];
        vector<int> v;
        v.push_back(a[n-1]);
        for(int i=n-2;i>=0;i--){
           if(a[i]>=lastGreater){ lastGreater=a[i]; v.push_back(a[i]);}
        }
        int l=0,r=v.size()-1;
        while(l<r){
            swap(v[l],v[r]);
            l++,r--;
        }
        return v;
    }
//smallest positive missing number -o(n) time & o(1) space
 public:
    //Function to find the smallest positive number missing from the array.
    int missingNumber(int arr[], int n) 
    { 
        // Your code here
       int find1=0;
       for(int i=0;i<n;i++){
           if(arr[i]==1){
               find1=1;
               break;
           }
       }
       if(find1==0) return 1;//as 1 is first missing no
       for(int i=0;i<n;i++){
           if(arr[i]<=0||arr[i]>n) arr[i]=1;
       }
       for(int i=0;i<n;i++){
           arr[(arr[i]-1)%n]+=n;
       }
       for(int i=0;i<n;i++){
           if(arr[i]<=n) return i+1;
       }
    return n+1;
    }
//Rearrange Array Alternately
public:
    // This function wants you to modify the given input
    // array and no need to return anything
    // arr: input array
    // n: size of array
    //Function to rearrange  the array elements alternately.
    void rearrange(long long *arr, int n) 
    { 
    	
    	// Your code here
    /*//when arr elements differ by 1
    int max_ele=arr[n-1],min_ele=arr[0],i=0;
    	while(i<n){
    	    if(i%2!=0){
    	     arr[i]=min_ele;
    	    i++;
    	    min_ele++;
    	    }
    	    else{
        	 arr[i]=max_ele;
        	 i++;
        	 max_ele--;
    	    }
    	}
    	*/ 
    	int maxindex=n-1,minindex=0,maxelement=arr[n-1]+1;
    	for(int i=0;i<n;i++){
    	    if(i%2==0){
    	    arr[i]=arr[i]+((arr[maxindex]%maxelement)*maxelement);
    	    maxindex--;
    	    }else{
    	        arr[i]=arr[i]+((arr[minindex]%maxelement)*maxelement);
    	        minindex++;
    	    }
    	}
    	for(int i=0;i<n;i++){
    	    arr[i]=arr[i]/maxelement;
    	}
    }
//Rearrange an array with o(1) extra space
public:
    // arr: input array
    // n: size of array
    //Function to rearrange an array so that arr[i] becomes arr[arr[i]]
    //with O(1) extra space.
    void arrange(long long arr[], int n) {
        // Your code here
        for(int i=0;i<n;i++){
            arr[i]+=(arr[arr[i]]%n)*n;
        }
        for(int i=0;i<n;i++){
            arr[i]=arr[i]/n;
        }
    }
//Maximum Index
public:
        
    // A[]: input array
    // N: size of array
    // Function to find the maximum index difference.
    int maxIndexDiff(int arr[], int N) 
    { 
        // Your code here
        int LMin[N],RMax[N];
        LMin[0]=arr[0];
        for(int i=1;i<N;i++){
            LMin[i]=min(arr[i],LMin[i-1]);
        }
        RMax[N-1]=arr[N-1];
        for(int i=N-2;i>=0;i--){
            RMax[i]=max(arr[i],RMax[i+1]);
        }
        int i=0,j=0,maxDiff=-1;
        while(i<N&&j<N){
            if(LMin[i]<=RMax[j]){
                maxDiff=max(maxDiff,j-i);
                j++;
            }else i++;
        }
        return maxDiff;
    }
//// Function to find the trapped water between the blocks.
    public:
    long long trappingWater(int arr[], int n){
        // code here
    int lmax[n],rmax[n];
        long long water=0,maxstorableht=0;
        lmax[0]=arr[0];
        for(int i=1;i<n;i++){
           lmax[i]=max(lmax[i-1],arr[i]);
        }
        rmax[n-1]=arr[n-1];
        for(int i=n-2;i>=0;i--){
            rmax[i]=max(rmax[i+1],arr[i]);
        }
        for(int i=1;i<n-1;i++){
            maxstorableht=min(lmax[i],rmax[i]);
            if(maxstorableht-arr[i]>0)
              water+=maxstorableht-arr[i];
        }
        return water;
    }
//public:
//Function to find the days of buying and selling stock for max profit.
vector<vector<int> > stockBuySell(vector<int> price, int n){
vector<vector<int>> ans;
        vector<int> v;
        int i = 0;
        while (i < n - 1) {
 
        // Find Local Minima
        // Note that the limit is (n-2) as we are
        // comparing present element to the next element
        while ((i < n - 1) && (price[i + 1] <= price[i]))
            i++;
 
        // If we reached the end, break
        // as no further solution possible
        if (i == n - 1)
            break;
 
        // Store the index of minima
        int buy = i++;
 
        // Find Local Maxima
        // Note that the limit is (n-1) as we are
        // comparing to previous element
        while ((i < n) && (price[i] >= price[i - 1]))
            i++;
 
        // Store the index of maxima
        int sell = i - 1;
        v.clear();
        v.push_back(buy);
        v.push_back(sell);
        ans.push_back(v);
        //if(i==n-1)break;
       }
       return ans;
    }
//check if array is sorted or not
public:
    bool arraySortedOrNot(int arr[], int n) {
        // code here
       for(int i=n-1;i>0;i--){
           if(arr[i]-arr[i-1]<0){      
             return false;
           }
        }
        return true;
    }
//check if array is rotated or not
public:	
	int findKRotation(int arr[], int n) {
	    // code here
	    int count=0;
	   for(int i=n-1;i>0;i--){
	       if(arr[i]-arr[i-1]<0) count=i;
	    }
	    return count;
	}
//kadane's algo -maxsubarraysum
public:
    // arr: input array
    // n: size of array
    //Function to find the sum of contiguous subarray with maximum sum.
    long long maxSubarraySum(int arr[], int n){
        
        // Your code here
        int maxsum=INT_MIN,currsum=0;
        for(int i=0;i<n;i++){
            currsum+=arr[i];
            maxsum=max(maxsum,currsum);
            if(currsum<0) currsum=0;
        }
        return maxsum;
        
    }
//longest subarray with atmost k even elements (use sliding window concept)
int main()
 {
	//code
	int t,n,k;
	cin>>t;
	while(t--){
	    cin>>n>>k;
	    int arr[n];
	    for(int i=0;i<n;i++){
	      cin>>arr[i];
	      if(arr[i]%2==0)
	         arr[i]=1;
	      else
	         arr[i]=0;
	    }
	    int sum=0,count=0,maxcount=0;
	    for(int i=0;i<n;i++){
	        if((sum+arr[i])<=k){
	            sum+=arr[i];
	            count++;
	        }else if(sum!=0){
	            sum=sum-arr[i-count]+arr[i];
	        }
	        maxcount=max(count,maxcount);
	    }
	    cout<<maxcount<<'\n';
	    
	}
	return 0;
}
//max circular subarray sum
 public:
    // arr: input array
    // num: size of array
    //function for standard kadane:
    int normalSubarraySum(int arr[],int n){
        int maxSum=INT_MIN,currSum=0;
        for(int i=0;i<n;i++){
            currSum+=arr[i];
            maxSum=max(currSum,maxSum);
            if(currSum<0) currSum=0;
        }
        return maxSum;
    }
//Function to find maximum circular subarray sum.
    int circularSubarraySum(int arr[], int n){
        
        // your code here
        int normal_sum=normalSubarraySum(arr,n);//non-wrap up sum or std sum
        if(normal_sum<0){
            return normal_sum;
        }
        int arr_sum=0;
        for(int i=0;i<n;i++){
            arr_sum+=arr[i];//to get total sum
            arr[i]=-arr[i];//to get minimum sum(middle elements sum) by passing this modified array to std kadane for max minimum sum.
        }
        int circular_sum=arr_sum+normalSubarraySum(arr,n);//wrap up sum(max circular sum)=total arr sum-middle elements sum
        return max(circular_sum,normal_sum);//max of( wrap up sum,non-wrap up sum or std sum)
    }


SEARCHING:
//search an element in an array  - linear search
  public:
    // Function to search x in arr
    // arr: input array
    // X: element to be searched for
    int search(int arr[], int N, int X)
    {
       for(int i=0;i<N;i++)
         if(arr[i]==X) return i;
         
       return -1;
    }
//Searching an element in a sorted array
 public:
    // Function to find element in sorted array
    // arr: input array
    // N: size of array
    // K: element to be searche
    int searchInSorted(int arr[], int N, int K) 
    { 
    
       // Your code here
       return (binary_search(arr,arr+N,K)==1)?1:-1;
       
    }
//Count the zeroes
int countZeroes(int arr[], int n) {
        // code here
    int left = 0;
        int right = n-1;
        
        while(left <= right){
            int mid = left + (right - left)/2;
            
            if(arr[mid] == 0){
                if(mid == 0 || arr[mid-1] != arr[mid] )
                    return n-mid;
                else 
                    right = mid - 1;
            }
            else 
                left = mid + 1;
        }
        return 0;
    }
//Square root of a number
public:
    long long int floorSqrt(long long int x) 
    {
        // Your code goes here 
        long long int last,i=1,mid,low=1,high;
       while(i<x){
                last=i;
                if(last*last==x) return last;
                i=i*2;
            
        }
        high=last;
        while(low<=high){
            mid=low+(high-low)/2;
            if(mid*mid==x) return mid;
            else if(mid*mid>x) high=mid-1;
            else {last=mid;low=mid+1;}
        }
      return last;
    
    }
//left most and right most index - first and last occurrence of x in v
 public:
    pair<long,long> indexes(vector<long long> v, long long x)
    {
        // code here
        bool find=binary_search(v.begin(),v.end(),x);
        if(find==true){
        auto last=upper_bound(v.begin(),v.end(),x);
        auto first=lower_bound(v.begin(),v.end(),x);
        return make_pair(first-v.begin(),last-v.begin()-1);
        }
        return make_pair(-1,-1);
    }
//Floor in a sorted array
 public:
    // Function to find floor of x
    // n: size of vector
    // x: element whose floor is to find
    int findFloor(vector<long long> v, long long n, long long x){
        
        // Your code here
        return upper_bound(v.begin(),v.end(),x)-v.begin()-1;
        
    }
//Minimum Number in a sorted rotated array  (distinct and without duplicates)
public:
    //Function to find the minimum element in sorted and rotated array.
    int minNumber(int arr[], int low, int high)
    {
        // Your code here
        int mid,len=high-low+1;
        while(low<=high){
            mid=low+(high-low)/2;
            if(mid==0) return arr[mid];
            if(arr[mid]>arr[mid+1]) return arr[mid+1];
            if(arr[mid-1]>arr[mid]) return arr[mid];
            else if(arr[mid]>arr[high]) low=mid+1;
            else high=mid-1;
        }
        
        
    }
// with duplicates
// Function to find minimum element
int findMin(int arr[], int low, int high)
{
    while(low < high)
    {
        int mid = low + (high - low)/2;
        if (arr[mid] == arr[high])
            high--;
        else if(arr[mid] > arr[high])
            low = mid + 1;
        else
            high = mid;
    }
    return arr[high];
}
//Two Repeated Elements
public:
    //Function to find two repeated elements. num are from 1 to N range and total N+2
    vector<int> twoRepeated (int arr[], int n) {
        // Your code here
       vector<int> res;
       for(int i=0;i<n+2;i++){
           if((arr[(arr[i]%(n+1))]/(n+1))<1){
               arr[(arr[i]%(n+1))]+=(n+1);
           }else res.push_back(arr[i]%(n+1));
       }
       return res;
    }
//Roof Top
 public:
    //Function to find maximum number of consecutive steps 
    //to gain an increase in altitude with each step.
    int maxStep(int arr[], int n)
    {
       //Your code here
       int steps=0,msteps=0;
       for(int i=1;i<n;i++){
           if(arr[i]>arr[i-1]){
               steps+=1;
               msteps=max(msteps,steps);
           }else{steps=0;}
       }
       return msteps;
    }
//Maximum Water Between Two Buildings
  public:
    int maxArea(int h[],int n){
        int ht=0,l=0,area=0,i=0,j=n-1,maxarea=0;
        //we move towards height which is greater for max area using 2 pointers
        while(i<j){
                ht=min(h[i],h[j]);
                l=(j-i-1);
                area=ht*l;
                maxarea=max(maxarea,area);
                if(h[i]<h[j]){
                    i++; 
                }else if(h[j]<h[i]){
                    j--;
                }else i++,j--;
            }
      return maxarea;
    }
    int maxCandy(int h[], int n) 
    { 
        // Your code goes here
            return maxArea(h,n);
       
    } 
//count more than n/k occurrences  -o(n) extra space
 //Function to find all elements in array that appear more than n/k times.
    int countOccurence(int arr[], int n, int k) {
        // Your code here
        unordered_map<int,int> mp;
        int count=0;
        for(int i=0;i<n;i++){
            mp[arr[i]]++;
        }
        if(k<1) return mp.size();
        for(auto it=mp.begin();it!=mp.end();it++){
            if(it->second>(n/k)) count++;
        }
        return count;
    }
   
//
public:
    bool isPossible(int arr[],int n,int m,int min_pages){
        int sum=0,noofstud=1;
        for(int i=0;i<n;i++){
            if(arr[i]>min_pages) return false;
            if(sum+arr[i]>min_pages){
                noofstud++;
                sum=arr[i];
                if(noofstud>m) return false;
            }else sum+=arr[i];
        }
        return true;
    }
    //Function to find minimum number of pages.
    int findPages(int arr[], int n, int m) 
    {
        //code here
        long long sum=0;
        if(n<m) return -1;
        int l,r,res=0;
        for(int i=0;i<n;i++){
            sum+=arr[i];
            mxpages=max(mxpages,arr[i]);
        }
        l=mxpages,r=sum;
        while(l<=r){
            int mid=(r+l)/2;
            if(isPossible(arr,n,m,mid)){
                res=mid;
                r=mid-1;
            }else l=mid+1;
        }
        return res;
    } 
//subarray with given sum
public:
    //Function to find a continuous sub-array which adds up to a given number.
    vector<int> subarraySum(int arr[], int n, long long sum)
    {
        // Your code here
        vector<int> ans;
       long long int curr_sum=arr[0],l=0,r=0;
        while(r<n){
            if(curr_sum==sum) {ans.push_back(l+1);ans.push_back(r+1); return ans;} //since positions
            else if(curr_sum>sum) {curr_sum=curr_sum-arr[l];l++;}
            else {r++;curr_sum=curr_sum+arr[r];}
        }
        ans.push_back(-1);
        return ans;
    }
//median of two sorted arrays of different sizes
public:
    double Median(vector<int>& A,vector<int>& B){
        int start=0,end=A.size(),merged_mid=(A.size()+B.size()+1)/2;
        while(start<=end){
            int mid=(start+end)/2;
            int leftAsize=mid,leftBsize=merged_mid-mid;
            int leftA=(leftAsize>0)?A[leftAsize-1]:INT_MIN;
            int leftB=(leftBsize>0)?B[leftBsize-1]:INT_MIN;
            int rightA=(leftAsize<A.size())?A[leftAsize]:INT_MAX;
            int rightB=(leftBsize<B.size())?B[leftBsize]:INT_MAX;
            if(leftA<=rightB&&leftB<=rightA){
                if((A.size()+B.size())%2==0){
                    return (max(leftA,leftB)+min(rightA,rightB))/2.0;
                }
                return max(leftA,leftB);
            }
            else if(leftA>rightB){
                end=mid-1;
            }else start=mid+1;
            
        }
        return 0.0;
        
    }
    double MedianOfArrays(vector<int>& array1, vector<int>& array2)
    {
        // Your code goes here
        int n=array1.size(),m=array2.size();
        if(n>m) return Median(array2,array1);
        else return Median(array1,array2);
    
    }

SORTING:

//Bubble sort
 public:
    //Function to sort the array using bubble sort algorithm.
    
    void bubbleSort(int arr[], int n)
    {
        // Your code here  
        bool flag=false;
        for(int pass=0;pass<n-1;pass++){//n-1 passes reqd
            for(int j=0;j<n-i-1;j++){//i elements are sorted in right part thus check for only n-i-1 left elements.
                if(arr[j+1]<arr[j]){
                 arr[j]=arr[j]+arr[j+1];
                 arr[j+1]=arr[j]-arr[j+1];
                 arr[j]=arr[j]-arr[j+1];
                 flag=true;
                }
            }
            if(flag==false) return;
        }
        return;
    }
//
 public:
    //Function to sort the array using insertion sort algorithm.
    void insertionSort(int arr[], int n)
    {
        //code here
        int j=0,key;
        for(int i=1;i<n;i++){//i is from 1 because we assume 0th is already inserted in empty array.
            j=i-1;//last element in sorted arr.
            key=arr[i];//store ith ele as it will be overwritten while creating space
            while(j>=0&&j<n&&arr[j]>key){//shift and create space if last>key
                arr[j+1]=arr[j];
                  j--;
                
            }
            arr[j+1]=key;//j will be last element in sorted arr and so place this key in space created at j+1 th.
        }
        return;
    }
//Quick sort
 //Function to sort an array using quick sort algorithm.
   
    void quickSort(int arr[], int low, int high)
    {
        // code here
        
        if(low<high){//using lomuto partition
            int pivotIdx=partition(arr,low,high);
            quickSort(arr,low,pivotIdx-1);//in horae's partition it is quickSort(arr,low,pivotIdx); rest same;
            quickSort(arr,pivotIdx+1,high);
        }
        return;
        
    }
    
    public://lomuto partition
    int partition (int arr[], int low, int high)
    {
       // Your code here
       int pivot=arr[high],j=low-1;
       for(int i=low;i<=high-1;i++){
           if(arr[i]<=pivot){
               j++;
               swap(arr[j],arr[i]);
           }
       }
       swap(arr[j+1],arr[high]);
       return j+1;
    }
    int hoare(int arr[],int low,int high){
        int pivot=arr[low],i=low,j=high;
        while(1){
             do{i++;}while(arr[i]<pivot);
             do{j--;}while(arr[j]>pivot);
             if(i>=j) return j;
             swap(arr[i],arr[j]);   
         }
    }
//Binary Array Sorting
 public:
    
    // A[]: input array
    // N: input array
     
    //Function to sort the binary array.
    void binSort(int arr[], int n)
    {
       //Your code here
       
       /**************
        * No need to print the array
        * ************/
        int j=n-1;
       for(int i=0;i<n;i++){
           while(i<=j){
           if(arr[i]==1){swap(arr[i],arr[j]);j--;}
           else break;
           }
       }
    }
// count Inversions -o(nlogn) time and o(n) space
public:
    // arr[]: Input Array
    // N : Size of the Array arr[]
    long long int countAndMerge(long long int arr[],long long int low,long long int mid,long long int high){
        long long int n1=mid-low+1,n2=high-mid;
        long long int l[n1],r[n2];
        for(int i=0;i<n1;i++){
            l[i]=arr[low+i];
        }
        for(int i=0;i<n2;i++){
            r[i]=arr[mid+1+i];
        }
        long long int i=0,j=0,k=low;
        long long int res=0;
        while(i<n1&&j<n2){
            if(l[i]<=r[j]){arr[k]=l[i];k++,i++;}
            else{arr[k]=r[j];k++,j++;res+=(n1-i);//count pairs of inversion}
        }
        while(i<n1){arr[k]=l[i];i++,k++;}
        while(j<n2){arr[k]=r[j];j++,k++;}
        return res;
    }
    long long int invCount(long long int arr[],long long int low,long long int high){
        long long int inv_count=0;
        if(low<high){
            long long int mid=low+(high-low)/2;
            inv_count+=invCount(arr,low,mid);
            inv_count+=invCount(arr,mid+1,high);
            inv_count+=countAndMerge(arr,low,mid,high);
        }
        return inv_count;
    }
    // Function to count inversions in the array.
    long long int inversionCount(long long arr[], long long N)
    {        // Your Code Here
        return invCount(arr,0,N-1);        
    }
//

public:
    //arr1,arr2 : the arrays
    // n, m: size of arrays
    //Function to return a list containing the union of the two arrays. 
    vector<int> findUnion(int arr1[], int arr2[], int n, int m)
    {
        //Your code here
        //return vector with correct order of elements
        int i=0,j=0,k=0;
        vector<int> unionArr;
        while(i<n&&j<m){
            if(i>0&&arr1[i]==arr1[i-1]){ i++;continue;}
            if(j>0&&arr2[j]==arr2[j-1]){ j++; continue;}
            if(arr1[i]<arr2[j]){
             unionArr.push_back(arr1[i]);i++;
            }else if(arr1[i]>arr2[j]){
                 unionArr.push_back(arr2[j]);j++; 
            }else{unionArr.push_back(arr1[i]); i++,j++;}
        }
        while(i<n){            
          if(arr1[i]!=arr1[i-1]){ unionArr.push_back(arr1[i]);i++;}
          else i++;         
        }
        while(j<m){             
          if(arr2[j]!=arr2[j-1]){ unionArr.push_back(arr2[j]);j++;}
          else j++;
        }        
        return unionArr;
    }
//Intersection of two unsorted arrays
public:
    // Function to return the count of the number of elements in
    // the intersection of two arrays.
    int NumberofElementsInIntersection(int a[], int b[], int n, int m) {
        // Your code goes here
        unordered_set<int> hash;
        int low=n>m?m:n,max=n<m?m:n;
        int *arr1,*arr2;
        int count=0;
        if(low==n){arr1=a,arr2=b;}
        else{arr1=b,arr2=a;}
        for(int i=0;i<low;i++){
            hash.insert(arr1[i]);
        }
        for(int i=0;i<max;i++){
            if(hash.find(arr2[i])!=hash.end()){count++; hash.erase(arr2[i]);}
            
        }
        return count;
    }
//count the number of possible triangles
 public:
    //Function to count the number of possible triangles.
    int findNumberOfTriangles(int arr[], int n)
    {
        // code here
        int count=0;
        sort(arr,arr+n);
        for(int i=n-1;i>=1;i--){
            int l=0,r=i-1;
            while(l<r){
                if(arr[l]+arr[r]>arr[i]&&arr[l]+arr[i]>arr[i]&&arr[i]+arr[r]>arr[l]){
                count+=r-l;r--;
                }else l++;
            }
        }
        return count;
    }
//find triplets with zero sum -o(n2) time and o(1) space
public:
    //Function to find triplets with zero sum.
    bool findTriplets(int arr[], int n)
    { 
        //Your code here
        int count=0;
        sort(arr,arr+n);
        for(int i=n-1;i>=1;i--){
            int l=0,r=i-1;
            while(l<r){
                if(arr[i]+arr[l]+arr[r]==0){count+=1;l++;r--;return count //as we just need atleast 1 such triplet here otherwise sum all such pairs if asked;}
                else if(arr[i]+arr[l]+arr[r]<0) l++;
                else r--;
            }
        } 
        return count;
    }
//Three way partitioning    //USE DNF concept
public: 
    //Function to partition the array around the range such 
    //that array is divided into three parts.
    void threeWayPartition(vector<int>& arr,int a, int b)
    {
        // code here 
        int h=arr.size()-1,l=0,i=0; 
        while(i<=h){
            if(arr[i]<a&&arr[i]<b){swap(arr[i],arr[l]);l++;i++;}
            else if (arr[i]>b){swap(arr[h],arr[i]);h--;}
            else i++;
        }
    }

//Counting Sort
public:
    //Function to arrange all letters of a string in lexicographical 
    //order using Counting Sort.
    int charArr[26]={0};
    string countSort(string arr){
        // code here
        for(int i=0;i<arr.length();i++){
            charArr[abs('a'-arr[i])]+=1;
        }
        string s="";
        for(int i=0;i<26;i++){
            while(charArr[i]>=1){s.push_back('a'+i);charArr[i]+=-1;}
        }
        return s;
    }
// Sort an array of 0s,1s and 2s - DNF
public:
    void sort012(int arr[], int n)
    {
        // coode here 
        int h=n-1,l=0,i=0; 
        while(i<=h){
            if(arr[i]==0){swap(arr[i],arr[l]);l++;i++;}
            else if (arr[i]==2){swap(arr[h],arr[i]);h--;}
            else i++;//if arr[i]==1
        }
    }
//Sort by Absolute Difference
public:    
    // A[]: input array
    // N: size of array
    static bool mycomparator(pair<int,pair<int,int>> a ,pair<int,pair<int,int>> b){
        if(a.first!=b.first){
            return a.first<b.first;
        }else{
            return a.second.first<b.second.first;
        }
    }
    //Function to sort the array according to difference with given number.
    void sortABS(int arr[],int n, int k)
    {
       //Your code here
      /* //METHOD-1 using maps
       multimap<int,int> m;
       for(int i=0;i<n;i++){
           m.insert(make_pair(abs(arr[i]-k),arr[i]));
       }
       int i=0;
       for(auto it=m.begin();it!=m.end();it++){
           arr[i]=(*it).second;i++;
       }
       */
      //METHOD -2 using sort + vector of pairs 
       vector<pair<int,pair<int,int>>> v;
       for(int i=0;i<n;i++)
         v.push_back(make_pair(abs(arr[i]-k),make_pair(i,arr[i])));
       sort(v.begin(),v.end(),mycomparator);
       int i=0;
       for(auto it=v.begin();it!=v.end();it++){
           arr[i]=(*it).second.second;i++;
       }
    }
//Minimum difference pair  -we need to find mindiff b/w adj element pair  -o(nlogn) time
public:
   	int  minimum_difference(vector<int>nums){
   	    // Code here
   	  sort(nums.begin(),nums.end());
   	  int l=0,minDiff=INT_MAX,currDiff=0;
   	  while(l<nums.size()-1){
   	      currDiff=nums[l+1]-nums[l];
   	      if(currDiff<minDiff) minDiff=currDiff;
   	      l++;
   	  }
   	  return minDiff;
   	}
//Kth smallest element  --using quickselect algo-O(N) on avg and o(n2) in worst case time.
public:
    // arr : given array
    // l : starting index of the array i.e 0
    // r : ending index of the array i.e size-1
    int partition(int arr[],int l,int r){
       int pivot=arr[r],s=l,i;
        for(i=l;i<=r-1;i++){
            if(arr[i]<=pivot){
                swap(arr[i],arr[s]);
                s++;
            }
        }
        swap(arr[r],arr[s]);
        return s;
        
    }
    // k : find kth smallest element and return using this function
    int kthSmallest(int arr[], int l, int r, int k) {
        //code here
       
        while(l<=r){
            int p1=rand()%(r-l+1); //without this RANDOM PIVOT SELECTION TLE happens
            swap(arr[r],arr[l+p1]);
            int pivotIdx=partition(arr,l,r);
            if(pivotIdx==(k-1)) return arr[pivotIdx];
            else if(pivotIdx>(k-1)){ r=pivotIdx-1;}
            else {l=pivotIdx+1;}
        }
        return -1;
        
        /*
        // If k is smaller than number of elements in array
    if (k > 0 && k <= r - l + 1) {
        // Partition the array around last element and get
        // position of pivot element in sorted array
        int pos = partition(arr, l, r);
 
        // If position is same as k
        if (pos == k - 1)
            return arr[pos];
        if (pos > k - 1) // If position is more, recur for left subarray
            return kthSmallest(arr, l, pos - 1, k);
 
        // Else recur for right subarray
        return kthSmallest(arr, pos + 1, r, k - pos + l - 1);
    }
 
    // If k is more than number of elements in array
    return INT_MAX;
    */
    }
//Number of Pairs  -x^y>y^x
public:
    
    // X[], Y[]: input arrau
    // M, N: size of arrays X[] and Y[] respectively
   long long int count(int X[],int M,int Y[],int N,int NoOfY[],int x){
        if(x==0) return 0;
        if(x==1) return NoOfY[0];
        long long int ans=0;
        auto idx=upper_bound(Y,Y+N,x)-Y;
        ans=(N-idx);
        ans+=(NoOfY[0]+NoOfY[1]);
        if(x==2) return ans-=(NoOfY[3]+NoOfY[4]);
        if(x==3) return ans+=(NoOfY[2]);
        return ans;
    }
    //Function to count number of pairs such that x^y is greater than y^x.
    long long countPairs(int X[], int Y[], int M, int N)
    {
       //Your code here
      long long int ans=0;
      int NoOfY[5]={0};
      for(int i=0;i<N;i++){
          if(Y[i]<5){
              NoOfY[Y[i]]++;
          }
      }
      sort(Y,Y+N);
      for(int i=0;i<M;i++){
          ans=ans+count(X,M,Y,N,NoOfY,X[i]);
      }
      return ans;
    }
//Merge without extra space  -gap method.
 //Function to merge the arrays.
        void merge(long long arr1[], long long arr2[], int n, int m) 
        { 
            // code here
            int gap=ceil((float)(n+m)/2);
            int ptr1,ptr2;
            while(gap>0){
                ptr1=0,ptr2=gap;
                while(ptr2<(n+m)){
                    if(ptr1<n&&ptr2<n&&arr1[ptr1]>arr1[ptr2]){ swap(arr1[ptr1],arr1[ptr2]);}
                    else if(ptr1>(n-1)&&ptr1<(n+m)&&ptr2>(n-1)&&ptr2<(n+m)&&arr2[ptr1-n]>arr2[ptr2-n]){swap(arr2[ptr1-n],arr2[ptr2-n]);}
                    else if(ptr1<n&&ptr2>(n-1)&&ptr2<(n+m)&&arr1[ptr1]>arr2[ptr2-n]){swap(arr1[ptr1],arr2[ptr2-n]);}
                    ptr1++,ptr2++;
                }
                if(gap==1) gap=0;
                else gap=ceil((float)gap/2);
            }
        } 
 
//Nearly sorted 
public:
    //Function to return the sorted array.
    vector <int> nearlySorted(int arr[], int n, int k){
        // Your code here
        vector<int> res;
        int size=(n==k)?k:(k+1);
        priority_queue<int,vector<int>,greater<int>> heap(arr,arr+size);
      
     for(int i=size;i<n;i++){
      res.push_back(heap.top());
      heap.pop();  
      heap.push(arr[i]);
      
      }
      while(heap.empty()==false){
      res.push_back(heap.top());
       heap.pop();
       
      }
      return res;
    }

//Minimum platforms
 public:
    //Function to find the minimum number of platforms required at the
    //railway station such that no train waits.
    int findPlatform(int arr[], int dep[], int n)
    {
    	// Your code here
    	/*//method-1 using heap -o(nlogn)time and o(n)space
    	vector<pair<int,int>> v(n);
    	for(int i=0;i<n;i++){
    	    v[i]=make_pair(arr[i],dep[i]);
    	}
    	sort(v.begin(),v.end());
    	int res=1;
    	priority_queue<int,vector<int>,greater<int>> heap;
    	heap.push(v[0].second);
    	for(int i=1;i<n;i++){
    	    if(heap.top()>=v[i].first){
    	        heap.push(v[i].second);
    	        res++;
    	    }else heap.pop();
    	    heap.push(v[i].second);
    	}
    	return res;
    	*/
    	//method-2 o(nlogn)time and o(1) space
    	sort(arr,arr+n);
    	sort(dep,dep+n);
    	int arrival=1,departure=0;
    	int count=1,res=1;
    	while(arrival<n&&departure<n){
    	    if(arr[arrival]<=dep[departure]){count++;res=max(res,count);arrival++;}
    	    else{count--;departure++;}
    	}
    	return res;
    }

MATRIX:
//Addition of two square matrices
 void Addition(vector<vector<int> >& matrixA, vector<vector<int>>&matrixB) {
        // Code here
        for(int i=0;i<matrixA.size();i++){
            for(int j=0;j<matrixA.size();j++){
                matrixA[i][j]=matrixA[i][j]+matrixB[i][j];
            }
        }
    }
//Sum of upper and lower triangle
public:
    //Function to return sum of upper and lower triangles of a matrix.
    vector<int> sumTriangles(const vector<vector<int> >& matrix, int n)
    {
        // code here
        int upper=0,low=0;
        vector<int> v;
        for(int i=0;i<n;i++){
            for(int j=i;j<n;j++){
                upper=upper+matrix[i][j];
            }
        }
        for(int i=0;i<n;i++){
            for(int j=0;j<=i;j++){
                low=low+matrix[i][j];
            }
        }
        v.push_back(upper);
        v.push_back(low);
        return v;
    }
//Multiply matrices
void multiply(int a[][100], int b[][100], int c[][100], int n)
{
      //add code here.
      for(int i=0;i<n;i++){
       for(int j=0;j<n;j++){
            c[i][j]=0;
           for(int k=0;k<n;k++){
               c[i][j]+=a[i][k]*b[k][j];
           }
       }
      }
}
//Print matrix in snake pattern
public:
    //Function to return list of integers visited in snake pattern in matrix.
    vector<int> snakePattern(vector<vector<int> > matrix)
    {   
        // code here
        vector<int> v;
        int j=0;
        for(int i=0;i<matrix.size();i++){
            if(i%2==0){
                for(int j=0;j<matrix.size();j++){
                    v.push_back(matrix[i][j]);
                }
            }else{
              for(int j=matrix.size()-1;j>=0;j--){
                    v.push_back(matrix[i][j]);
                }  
            }
        }
        return v;
    }
//Transpose of matrix
public:  
    //Function to find transpose of a matrix.
    void transpose(vector<vector<int> >& matrix, int n)
    { 
        // code here 
        for(int i=0;i<n;i++){
            for(int j=i;j<n;j++){
                swap(matrix[i][j],matrix[j][i]);
            }
        }
    }
//Rotate by 90 degree
public:
    //Function to rotate matrix anticlockwise by 90 degrees.
    void rotateby90(vector<vector<int> >& matrix, int n) 
    { 
        // code here 
        //transpose
        for(int i=0;i<n;i++){
            for(int j=i;j<n;j++){
                swap(matrix[i][j],matrix[j][i]);
            }
        }
        //swap rows i, n-i
        for(int i=0;i<((n/2));i++){
            for(int j=0;j<n;j++){
                swap(matrix[i][j],matrix[n-i-1][j]);
            }
        }
        
    } 
//Determinant of a matrix
int determinantOfMatrix(vector<vector<int> > matrix, int n)
    {
        int det = 0; // the determinant value will be stored here
        if (matrix.size() == 1)
        {
            return matrix[0][0]; // no calculation needed
        }
        else if (matrix.size() == 2)
        {
            det = (matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0]);
            return det;
        }
        else
        {
            for (int p = 0; p < matrix[0].size(); p++)
            {
                vector<vector<int>> TempMatrix;
                for (int i = 1; i < matrix.size(); i++)
                {
                    vector<int> TempRow;
                    for (int j = 0; j < matrix[i].size(); j++)
                    {
                        if (j != p)
                        {
                            TempRow.push_back(matrix[i][j]);
                        }
                    }
                    if (TempRow.size() > 0)
                    TempMatrix.push_back(TempRow);
                }
                det = det + matrix[0][p] * pow(-1, p) * determinantOfMatrix(TempMatrix,matrix.size());
            }
            return det;
        }
   }
//Boundary traversal of matrix
public:
    //Function to return list of integers that form the boundary 
    //traversal of the matrix in a clockwise manner.
    vector<int> boundaryTraversal(vector<vector<int> > matrix, int n, int m) 
    {
        // code here
        
    vector<int> v;
    for(int i=0;i<1;i++){
     for(int j=0;j<m;j++)
      v.push_back(matrix[i][j]);
     }
     if(n==1)return v;
    for(int i=1;i<n;i++){
     for(int j=m-1;j<m;j++)
      v.push_back(matrix[i][j]);
    }
    if(m==1) return v;
    for(int i=n-1;i<n;i++){
     for(int j=m-2;j>=0;j--)
      v.push_back(matrix[i][j]);  
    }
    if(n==2) return v;
    for(int i=n-2;i>=1;i--){
     for(int j=0;j<1;j++)
      v.push_back(matrix[i][j]);
    }
    return v;
    }
//Spirally traversing a matrix
public: 
    //Function to return a list of integers denoting spiral traversal of matrix.
    vector<int> spirallyTraverse(vector<vector<int> > matrix, int row, int col) 
    {
        // code here 
        vector<int> v;
        int u=0,r=col-1,l=0,d=row-1;
        while((u<=d)&&(l<=r)){
            for(int i=l;i<=r;i++)
              v.push_back(matrix[u][i]);
            if((d-u+1)==1) return v;
            u++;
            for(int i=u;i<=d;i++)
               v.push_back(matrix[i][r]);
            if((r-l+1)==1) return v;
            r--;
            for(int i=r;i>=l;i--)
              v.push_back(matrix[d][i]);
            if((d-u+1)<2) return v;
            d--;
            for(int i=d;i>=u;i--)
              v.push_back(matrix[i][l]);
            l++;
            
        }
      return v;  
    }
//Search in a row-column sorted matrix
 public:
    //Function to search a given number in row-column sorted matrix.
    bool search(vector<vector<int> > matrix, int n, int m, int x) 
    {
        // code here 
        int l=m-1,d=0;
        if((x<matrix[0][0])||(x>matrix[n-1][m-1])) return false;
        while((d<n)&&(l>=0)){
            if(matrix[d][l]<x) d++;
            else if(matrix[d][l]>x) l--;
            else return true;
        }
        return false;
    }
//Boolean Matrix
 public:
    //Function to modify the matrix such that if a matrix cell matrix[i][j]
    //is 1 then all the cells in its ith row and jth column will become 1.
    void booleanMatrix(vector<vector<int> > &matrix)
    {
        // code here 
        /*
        int r=matrix.size(),c=matrix[0].size();
        bool r0=false,c0=false;
        int row[r],col[c];
        memset(row,0,sizeof row);
        memset(col,0,sizeof col);
        for(int i=0;i<r;i++){
            for(int j=0;j<c;j++){
                if(matrix[i][j]==1){row[i]=1;col[j]=1;}
            }
        }
         for(int i=0;i<r;i++){
            for(int j=0;j<c;j++){
                if((row[i]==1)||(col[j]==1)){matrix[i][j]=1;}
            }
        }
        */
        //method 2 use 0th row and 0th col of matrix as row[],col[] arrays
        int r=matrix.size(),c=matrix[0].size();
        bool r0=false,c0=false;
        //for(int i=0;i<r;i++){}
        //for(int i=0;i<c;i++){if(matrix[i][0]==1) c0=true;}
        for(int i=0;i<r;i++){
            for(int j=0;j<c;j++){
                if(i==0&&matrix[i][j]==1) r0=true;
                if(j==0&&matrix[i][j]==1) c0=true;
                if(matrix[i][j]==1){
                    matrix[0][j]=1;//like in col[j] mark 1
                    matrix[i][0]=1;//like in row[i] mark 1
                }
            }
        }
         for(int i=1;i<r;i++){
            for(int j=1;j<c;j++){
                if((matrix[i][0]==1)||(matrix[0][j]==1)){matrix[i][j]=1;}
            }
        }
        if(r0==1){ for(int i=0;i<c;i++) matrix[0][i]=1;}
        if(c0==1){ for(int j=0;j<r;j++) matrix[j][0]=1;}
        
    }
//Make matrix Beautiful  -makes rows sum and col sums same throughout the matrix
class Solution
{
    public:
    //Function to find minimum number of operations that are required 
    //to make the matrix beautiful.
    int findMinOpeartion(vector<vector<int> > matrix, int n)
    {
        // code here 
        vector<int> sumRow(n,0);
        vector<int> sumCol(n,0);
    // Calculate sumRow[] and sumCol[] array
    int maxSum = 0;
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j) {
            sumRow[i] += matrix[i][j];
            sumCol[i] += matrix[j][i];
            maxSum = max(maxSum, sumRow[i]);
        maxSum = max(maxSum, sumCol[i]);
        }
    // Find maximum sum value in either row or in column
    
   /* for (int i = 0; i < n; ++i) {
        maxSum = max(maxSum, sumRow[i]);
        maxSum = max(maxSum, sumCol[i]);
    }*/
    int count = 0;
    for (int i = 0, j = 0; i < n && j < n;) {
        // Find minimum increment required in either row or
        // column
        int diff
            = min(maxSum - sumRow[i], maxSum - sumCol[j]);
        // Add difference in corresponding cell, sumRow[]
        // and sumCol[] array
        matrix[i][j] += diff;
        sumRow[i] += diff;
        sumCol[j] += diff;
        // Update the count variable
        count += diff;
        // If ith row satisfied, increment ith value for
        // next iteration
        if (sumRow[i] == maxSum)
            ++i;
        // If jth column satisfied, increment jth value for
        // next iteration
        if (sumCol[j] == maxSum)
            ++j;
    }
    for(int i=0;i<n;i++){for(int j=0;j<n;j++){ cout<<matrix[i][j]<<" ";}cout<<"\n";}
    return count;
    } 
};
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int n;
        cin>>n;
        vector<vector<int> > matrix (n,vector<int>(n));
        for(int i=0;i<n;i++)
            for(int j=0;j<n;j++)
                cin>>matrix[i][j];
        Solution ob;
        cout << ob.findMinOpeartion(matrix, n) << endl;
    }
    return 0;
}



HASHING:
//Non-Repeating Element
 public:
    int firstNonRepeating(int arr[], int n) 
    { 
        // Complete the function
        unordered_map<int,pair<int,int>> mp;
        int count=0,j=0,res=0;
        for(int i=0;i<n;i++){
            auto id=mp.find(arr[i]);
            if(id!=mp.end()){mp[arr[i]].second+=1;}
            else{j=i;count=1;mp.insert(make_pair(arr[i],make_pair(j,count)));}
            
        }
        j=INT_MAX;
        for(auto i:mp){
            if(i.second.second==1){
                if(i.second.first<j){j=i.second.first,res=i.first;}
            }
        }
        return res;
        
    } 
//First repeating element
 public:
    // Function to return the position of the first repeating element.
    int firstRepeated(int arr[], int n) {
        // code here
        unordered_map<int,pair<int,int>> mp;
        int count=0,j=0,res=0;
        for(int i=0;i<n;i++){
            auto id=mp.find(arr[i]);
            if(id!=mp.end()){mp[arr[i]].second+=1;}
            else {j=i;count=1;mp.insert(make_pair(arr[i],make_pair(j,count)));}
            
        }
        j=INT_MAX;
        for(auto i:mp){
            if(i.second.second>1){
                if(i.second.first<j){j=i.second.first,res=i.first;}
            }
        }
        return (j==INT_MAX)?-1:(j+1);
    }
//Union of two arrays
 public:
  //Function to return the count of number of elements in union of two arrays.
    int doUnion(int a[], int n, int b[], int m)  {
        //code here
        unordered_set<int> hash;
        for(int i=0;i<n;i++){
            hash.insert(a[i]);
        }
        for(int i=0;i<m;i++){
            hash.insert(b[i]);
        }
        return hash.size();
    }
//key pair (two sum)
public:	
	// Function to check if array has 2 elements
	// whose sum is equal to the given value
	bool hasArrayTwoCandidates(int arr[], int n, int x) {
	    // code here
	    unordered_set<int> h;
	    for(int i=0;i<n;i++){
	        if(h.find((x-arr[i]))!=h.end()) return true;
	        h.insert(arr[i]);
	    }
	    return false;
	}
//check if two arrays are equal or not
 public:
    //Function to check if two arrays are equal or not.
    bool check(vector<ll> A, vector<ll> B, int N) {
        //code here
        unordered_map<int,int> h;
        for(int i=0;i<A.size();i++){
            h[A[i]]++;
        }
        for(int i=0;i<B.size();i++){
            if(h[B[i]]<=0) return false;
            h[B[i]]--;
        }
        return true;
    }
//subarray with 0 sum
public:
    //Complete this function
    //Function to check whether there is a subarray present with 0-sum or not.
    bool subArrayExists(int arr[], int n)
    {
        //Your code 
       unordered_set<int> h;
       long long int sum=0;
        for(int i=0;i<n;i++){
            sum+=arr[i];
            if(sum==0) return true;
            else if(h.find(sum)!=h.end()) return true;
            else{ h.insert(sum);}
        }
        return false;
    }
//winner of an election
public:
    //Function to return the name of candidate that received maximum votes.
    vector<string> winner(string arr[],int n)
    {
        // Your code here
        // Return the string containing the name and an integer
        // representing the number of votes the winning candidate got
        vector<string> v;
        unordered_map<string,int> h;
        for(int i=0;i<n;i++){
            h[arr[i]]++;
        }
        int maxi=INT_MIN;
        string key;
        //int val;
        for(auto i:h){
            if(i.second>maxi){ key=i.first;maxi=i.second;}
            else if(i.second==maxi){ key=min(key,i.first);maxi=i.second;}
        }
        string res=to_string(maxi);
        v.push_back(key);
        v.push_back(res);
        return v;
    }
//subarray range with given sum
public:
    //Function to count the number of subarrays which adds to the given sum.
    int subArraySum(int arr[], int n, int sum)
    {
        //Your code here
        unordered_map<int,int> m;
        int presum=0,res=0;
        for(int i=0;i<n;i++){
            presum+=arr[i];
            if(presum==sum)res++;
            if(m.find(presum-sum)!=m.end()){res+=m[presum-sum];}
            m[presum]++;
        }
        return res;
    }
//Positive Negative Pair
 public:
    //Function to return list containing all the pairs having both
    //negative and positive values of a number in the array.
    vector <int> findPairs(int arr[], int n) 
    {
        // code here
        vector<int> v;
        unordered_map<int,int> h;
        for(int i=0;i<n;i++){
            if(h.find(-1*arr[i])!=h.end()){h[-1*arr[i]]--;v.push_back(-1*abs(arr[i]));v.push_back(abs(arr[i]));}
           else h[arr[i]]++;
        }
        return v;
    }
//Zero sum subarrays
 public:
    //Function to count subarrays with sum equal to 0.
    ll findSubarray(vector<ll> arr, int n ) {
        //code here
        unordered_map<long long int,long long int> m;
        long long int presum=0,res=0,sum=0;
        for(int i=0;i<n;i++){
            presum+=arr[i];
            if(presum==sum)res++;
            if(m.find(presum-sum)!=m.end()){res+=m[presum-sum];}
            m[presum]++;
        }
        return res;
    }
//Subarrays with equal 1s and 0s
public:
    //Function to count subarrays with 1s and 0s.
    long long int countSubarrWithEqualZeroAndOne(int arr[], int n)
    {
        //Your code here
        unordered_map<long long int,long long int> m;
        long long int presum=0,res=0,sum=0;
        for(int i=0;i<n;i++){
            if(arr[i]==0)arr[i]=-1;
            presum+=arr[i];
            if(presum==sum)res++;
            if(m.find(presum-sum)!=m.end()){res+=m[presum-sum];}
            m[presum]++;
        }
        return res;        
    }
//sort an array according to the other
public:
    // A1[] : the input array-1
    // N : size of the array A1[]
    // A2[] : the input array-2
    // M : size of the array A2[]    
    //Function to sort an array according to the other array.
    vector<int> sortA1ByA2(vector<int> A1, int N, vector<int> A2, int M) 
    {
        //Your code here
        unordered_map<int,int> h;
        vector<int> v;
        for(int i=0;i<N;i++){
            h[A1[i]]++;
        }
        for(int i=0;i<M;){
            while(h[A2[i]]>0){
                v.push_back(A2[i]);
                h[A2[i]]--;
            }
            i++;
        }
        vector<int> res;
        for(auto it=h.begin();it!=h.end();){
           while((*it).second>0){
                res.push_back((*it).first);
                (*it).second--;
            }
            it++;  
        }
        sort(res.begin(),res.end());
        for(int i=0;i<res.size();i++){
            v.push_back(res[i]);
        }
        return v;
    }
//Sorting Elements of an Array by Frequency
#include<iostream>
#include<vector>
#include<unordered_map>
#include<algorithm>
using namespace std;
bool comp(pair<int,int>a,pair<int,int>b){
    if(a.second>b.second) return true;
    else if(a.second==b.second){if(a.first<b.first) return true;else return false;}
    else return false;
}
int main()
 {
	//code
	int t;
	cin>>t;
	while(t--){
	    int n,t;
	    cin>>n;
	    unordered_map<int,int> h;
	    vector<pair<int,int>> v;
	    for(int i=0;i<n;i++){
	        cin>>t;
	        h[t]++;
	    }
	    for(auto it:h){
	       v.push_back({it.first,it.second});
	    }
	    sort(v.begin(),v.end(),comp);
	    for(auto it:v){
	        int temp=it.second;
	        while(temp--)
	         cout<<it.first<<" ";
	    }
	   cout<<"\n";
	}
	return 0;
}
//Longest consecutive subsequence -o(n)time&space
public:
    // arr[] : the input array
    // N : size of the array arr[]
    //Function to return length of longest subsequence of consecutive integers.
    int findLongestConseqSubseq(int arr[], int N)
    {
      //Your code here
      int count=0,maxi=INT_MIN;
      unordered_set<int> h;
       for(int i=0;i<N;i++){
          h.insert(arr[i]);
      }
      for(int i=0;i<N;i++){
          if(h.find(arr[i]-1)==h.end()){
              int j=arr[i];
              while(h.find(j+1)!=h.end()){count++;j++;}
              count++;
              maxi=max(count,maxi);
          }
          count=0;
      }
      if(maxi==INT_MIN) return 1;
      return maxi;
    }

STRINGS:
//Naive Pattern searching
bool searchPattern(string str, string pat)
{
    // your code here
    int len=0,cnt=0;
    for(int i=0;i<str.length();i++){
        len=i;
        for(int j=0;j<pat.length()&&cnt<pat.length();j++){
            if(str[len]==pat[j]){len++;cnt++;}
            else {cnt=0;break;}
        }
        if(cnt==pat.length()) return true;
    }
    return false;
}
//Binary string (cnt of all substrings that should start and end with 1)
public:
    //Function to count the number of substrings that start and end with 1.
    long binarySubstring(int n, string a){
        
        // Your code here
        //m-1
        /*long cnt=0;
        int j=0;
        for(int i=0;i<a.length();i++){
            if(a[i]=='1'){
                j=i+1;
                while(j<a.length()){
                    if(a[j]=='1')cnt++;
                    j++;
                }
            }
        }
        return cnt;
        */
//m-2 return no of ways to form pair of 1's as count 
      long count=0;
      for(int i=0;i<a.length();i++){
          if(a[i]=='1') count++;
      }
      return count*(count-1)/2;
    }


//Implement strstr
//Function to locate the occurrence of the string x in the string s.
int strstr(string str, string pat)
{
     //Your code here
      int len=0,cnt=0;
    for(int i=0;i<str.length();i++){
        len=i;
        for(int j=0;j<pat.length()&&cnt<pat.length();j++){
            if(str[len]==pat[j]){len++;cnt++;}
            else {cnt=0;break;}
        }
        if(cnt==pat.length()) return i;
    }
    return -1;
}

//Anagram
public:
    //Function is to check whether two strings are anagram of each other or not.
    bool isAnagram(string a, string b){
        
        // Your code here
        unordered_map<int,int> h;
        if(a.length()!=b.length()) return false;
        for(int i=0;i<a.length();i++){
            h[a[i]]++;
        }
        for(int i=0;i<b.length();i++){
            if(h.find(b[i])==h.end()) return false;
            h[b[i]]--;
            if(h[b[i]]<=0) h.erase(b[i]);
        }
        return true;
    }

//Check if string is rotated by two places
 public:
    //Function to check if a string can be obtained by rotating
    //another string by exactly 2 places.
    
    void reverseArr(string &arr,int n, int low,int high){
          n=arr.length();
        while(low<high){
        swap(arr[low],arr[high]); 
        low++,high--;
      }
    }
    //Function to rotate an array by d elements in counter-clockwise direction. 
    string rotateArr(string &arr, int d, int n){
        // code here
         n=arr.length();
        if(d>n){
            d=d-n;
        }
        reverseArr(arr,n,0,d-1);
        reverseArr(arr,n,d,(n-1));
        reverseArr(arr,n,0,n-1);
        return arr;
    }
    bool isRotated(string str1, string str2)
    {
        // Your code here
        string copy=str1;
        if(str2==rotateArr(str1,2,str1.length())) return true; //counterclockwise rotation
        else if(str2==rotateArr(copy,str1.length()-2,str1.length())) return true;//clockwise rotation
        else return false;
    }

//Check if strings are rotations of each other or not
 public:
    /*
    //Function to check if two strings are rotations of each other or not.
     void reverseArr(string &arr,int n, int low,int high){
          n=arr.length();
        while(low<high){
        swap(arr[low],arr[high]); 
        low++,high--;
      }
    }
    //Function to rotate an array by d elements in counter-clockwise direction. 
    string rotateArr(string &arr, int d, int n){
        // code here
         n=arr.length();
        if(d>n){
            d=d-n;
        }
        reverseArr(arr,n,0,d-1);
        reverseArr(arr,n,d,(n-1));
        reverseArr(arr,n,0,n-1);
        return arr;
    }
    bool areRotations(string str1,string str2)
    {
        // Your code here
        string copy1,copy2;
        for(int i=0;i<str1.length();i++){
        copy1=str1;
        copy2=str1;
        if(str2==rotateArr(copy1,i,str1.length())) return true; //counterclockwise rotation
        else if(str2==rotateArr(copy2,str1.length()-i,str1.length())) return true;//clockwise rotation
        }
        return false;
    }
    */
    //method2
    bool areRotations(string str1,string str2){
        if(str1.length()!=str2.length()) return false;
        string r=str1+str1;
        if(r.find(str2)!=-1) return true;
        else return false;
    }

// ISOMORPHIC STRINGS
// This function returns true if str1 and str2 are isomorphic
bool areIsomorphic(string str1, string str2)
{
    int MAX_CHARS=256;
    int m = str1.length(), n = str2.length();

    // Length of both strings must be same for one to one
    // correspondence
    if (m != n)
        return false;

    // To mark visited characters in str2
    bool marked[MAX_CHARS] = { false };

    // To store mapping of every character from str1 to
    // that of str2. Initialize all entries of map as -1.
    int map[MAX_CHARS];
    memset(map, -1, sizeof(map));

    // Process all characters one by on
    for (int i = 0; i < n; i++) {
        // If current character of str1 is seen first
        // time in it.
        if (map[str1[i]] == -1) {
            // If current character of str2 is already
            // seen, one to one mapping not possible
            if (marked[str2[i]] == true)
                return false;

            // Mark current character of str2 as visited
            marked[str2[i]] = true;

            // Store mapping of current characters
            map[str1[i]] = str2[i];
        }

        // If this is not first appearance of current
        // character in str1, then check if previous
        // appearance mapped to same character of str2
        else if (map[str1[i]] != str2[i])
            return false;
    }

    return true;
}

// check if a string is Isogram or not
 public:
    //Function to check if a string is Isogram or not.
    bool isIsogram(string s)
    {
        //Your code here
        unordered_set<int> h;
        for(int i=0;i<s.length();i++){
            if(h.find(s[i])!=h.end()) return false;
            h.insert(s[i]);
        }
        return true;
    }

//Keypad typing
string printNumber(string s, int n) 
{
    //code here
   string one=" ",two="abc",three="def",four="ghi",five="jkl",six="mno",seven="pqrs",eight="tuv",nine="wxyz",star="*";
    string res="";
    for(int i=0;i<s.length();i++){
        if(one.find(s[i])!=-1) res+='1';
        else if(one.find(s[i])!=-1) res+='1';
        else if(two.find(s[i])!=-1) res+='2';
        else if(three.find(s[i])!=-1) res+='3';
        else if(four.find(s[i])!=-1) res+='4';
        else if(five.find(s[i])!=-1) res+='5';
        else if(six.find(s[i])!=-1) res+='6';
        else if(seven.find(s[i])!=-1) res+='7';
        else if(eight.find(s[i])!=-1) res+='8';
        else if(nine.find(s[i])!=-1) res+='9';
     }
    return res;
}

//Repeated Character
public:
    char firstRep (string s)
    {
        //code here.
       unordered_map<char,int> h;
       for(int i=0;i<s.length();i++){
           h[s[i]]++;
       }
       for(int i=0;i<s.length();i++){
           if(h[s[i]]>1) return s[i];
       }
       return '#';
    }
//Non Repeating Character
public:
    //Function to find the first non-repeating character in a string.
    char nonrepeatingCharacter(string s)
    {
       //Your code here
        unordered_map<char,int> h;
       for(int i=0;i<s.length();i++){
           h[s[i]]++;
       }
       for(int i=0;i<s.length();i++){
           if(h[s[i]]==1) return s[i];
       }
       return '$';
       
    }

//Maximum Occuring Character
public:
    //Function to find the maximum occurring character in a string.
    char getMaxOccuringChar(string str)
    {
        // Your code here
        unordered_map<char,int> h;
        char res;
        int maxi=INT_MIN;
        for(int i=0;i<str.length();i++){
            h[str[i]]++;
        }
        for(auto i:h){
            if(i.second>maxi) maxi=i.second,res=i.first;
            else if(i.second==maxi){
                if(i.first<res) res=i.first;
            }
        }
        return res;
    }

//Remove common characters and concatenate
public:
    //Function to remove common characters and concatenate two strings.
    string concatenatedString(string s1, string s2) 
    { 
        // Your code here
        unordered_map<char,int> h1,h2;
        int temp;
        string res="";
        
        for(int i=0;i<s1.length();i++){
            h1[s1[i]]++;
        }
        for(int i=0;i<s2.length();i++){
            h2[s2[i]]++;
        }
       for(int i=0;i<s1.length();i++){
           if(h2.find(s1[i])==h2.end()) res+=s1[i];
       }
       for(int i=0;i<s2.length();i++){
           if(h1.find(s2[i])==h2.end()) res+=s2[i];
       }
       if(res=="") return "-1";
       return res;
    }
//Reverse words in a given string
public:
    //Function to reverse words in a given string.
    string reverseWords(string s) 
    { 
        // code here 
        stack<string> st;
        string temp="",res="";
        for(int i=0;i<s.length();i++){
            if(s[i]=='.'){ st.push(temp);temp="";}
            else temp+=s[i];
        }
        st.push(temp);
        while(st.empty()!=true){
            res+=st.top();
            if(st.size()!=1)
              res+=".";
            st.pop();
        }
        
        return res;
    }
//Sum of numbers in string 
 public:
    int stoi(string temp){
        int len=(temp.length()),res=0,val=0,i=0;
        while(len--){
            val=temp[i]-'0';
            res*=10;
            res+=val;
            i++;
        }
        return res;
    }
    //Function to calculate sum of all numbers present in a string.
    int findSum(string str)
    {    	// Your code here
    	int res=0;
    	string temp="";
    	for(int i=0;i<str.length();i++){
    	    if(str[i]=='0'||str[i]=='1'||str[i]=='2'||str[i]=='3'||str[i]=='4'||str[i]=='5'||str[i]=='6'||str[i]=='7'||str[i]=='8'||str[i]=='9')
    	        temp+=str[i];
    	   else{
    	       if(str[i]=='\0') break;
    	         res+=stoi(temp);
    	         temp="";
    	   }
    	    
    	}
    	res+=stoi(temp);
    	return res;
    }

//Pangram Checking
public:
    //Function to check if a string is Pangram or not.
    bool checkPangram (string &str) {
        // your code here
        int chars[26]={0};
        transform(str.begin(),str.end(),str.begin(),::tolower);
        for(int i=0;i<str.length();i++){
            if(str[i]!='.'||str[i]!=','||str[i]!='?'||str[i]!=' ') chars[str[i]-'a']=1;
        }
        for(int i=0;i<26;i++){
            if(chars[i]!=1) return false;
        }
        return true;
    }

//Minimum indexed character 
public:
    //Function to find the minimum indexed character.
    int minIndexChar(string str, string patt)
    {
        // Your code here
        for(int i=0;i<str.length();i++){
            if(patt.find(str[i])!=string::npos) return i;
        }
        return -1;
    }
//Smallest window in a string containing all the characters of another string
string Minimum_Window(string s, string t)
{
//sliding window -o(s) time and o(1) space.
    int m[256] = { 0 };

    // Answer
    int ans = INT_MAX; // length of ans
    int start = 0; // starting index of ans
    int count = 0;
  
    // creating map
    for (int i = 0; i < t.length(); i++) {
        if (m[t[i]] == 0)
            count++;
        m[t[i]]++;
    }

    // References of Window
    int i = 0;
    int j = 0;

    // Traversing the window
    while (j < s.length()) {
        // Calculations
        m[s[j]]--;
        if (m[s[j]] == 0)
            count--;

        // Condition matching
        if (count == 0) {
            while (count == 0) {
                // Sorting ans
                if (ans > j - i + 1) {
                    ans = min(ans, j - i + 1);
                    start = i;
                }
                // Sliding I
                // Calculation for removing I

                m[s[i]]++;
                if (m[s[i]] > 0)
                    count++;

                i++;
            }
        }
        j++;
    }

    if (ans != INT_MAX)
        return s.substr(start, ans);
    else
        return "-1";
}

//Nth number made of prime digits
public:
    //Function to find nth number made of only prime digits.
    int primeDigits(int n)
    {
        //code here
        int rem=0;
        string res="";
        while(n){
            rem=n%4;
            switch(rem){
                case 1:res.push_back('2'); break;
                case 2: res.push_back('3');break;
                case 3:res.push_back('5'); break;
                case 0: res.push_back('7');break;
            }
            if(n%4==0) n--;
            n=n/4;
        }
        reverse(res.begin(),res.end());
        return stoi(res);
        
    }
//The Modified String
public:
    //Function to find minimum number of characters which Ishaan must insert  
    //such that string doesn't have three consecutive same characters.
    int modified (string a)
    {
        // Your code here
        int chars[26]={0};
        int flag=0,res=0,pos=0,count=1;
        string str2;
        for(int i=1;i<a.length();i++){
            if(a[i-1]==a[i]){
                count++;
                if(count==3){ 
                res++;
                count=1;
                }
            }
            else count=1;
        }
        return res;
    }
//Case-specific Sorting of Strings
public:
    //Function to perform case-specific sorting of strings.
    string caseSort(string str, int n)
    {
        // your code here
        int low[26]={0},up[26]={0};
        int l=0,u=0;
        for(int i=0;i<str.length();i++){
            if(int(str[i])>=65&&int(str[i])<=90) up[str[i]-'A']++;
            else if(int(str[i])>=97&&int(str[i])<=122) low[str[i]-'a']++;
        }
        //string res="";
        for(int i=0;i<str.length();i++){
            if(int(str[i])>=65&&int(str[i])<=90){
                while(up[u]==0){u++;}
                str[i]=char('A'+u);
                up[u]--;
                if(up[u]==0) u++;
            }
            else if(int(str[i])>=97&&int(str[i])<=122){
                while(low[l]==0) l++;
                str[i]=char('a'+l);
                low[l]--;
                if(low[l]==0) l++;
            }
        }
        return str;
    }

//Lexicographic Rank Of A String

// Construct a count array where value at every index
// contains count of smaller characters in whole string
void populateAndIncreaseCount(int* count, string str)
{
	int i,MAX_CHAR=256;

	for (i = 0; str[i]; ++i)
		++count[str[i]];

	for (i = 1; i < MAX_CHAR; ++i)
		count[i] += count[i - 1];
}

// Removes a character ch from count[] array
// constructed by populateAndIncreaseCount()
void updatecount(int* count, char ch)
{
	int i,MAX_CHAR=256;;
	for (i = ch; i < MAX_CHAR; ++i)
		--count[i];
}
// A function to find rank of a string in all permutations
// of characters
int findRank(string str)
{
	int len = strlen(str);
	int mul = fact(len);
	int rank = 1, i,MAX_CHAR=256;;

	// all elements of count[] are initialized with 0
	int count[MAX_CHAR] = { 0 };

	// Populate the count array such that count[i]
	// contains count of characters which are present
	// in str and are smaller than i
	populateAndIncreaseCount(count, str);

	for (i = 0; i < len; ++i) {
		mul /= len - i;

		// count number of chars smaller than str[i]
		// from str[i+1] to str[len-1]
		rank += count[str[i] - 1] * mul;

		// Reduce count of characters greater than str[i]
		updatecount(count, str[i]);
	}

	return rank;
}

//Rabin Karp - Pattern Searching
 public:
        vector <int> search(string pat, string txt)
        {
            //code here.
            vector<int> res;
            int q=INT_MAX,h=1,d=256,p=0,t=0;
            int m=pat.length(),n=txt.length();
            for(int i=0;i<m-1;i++){
                h=(h*d)%q;
            }
            for(int i=0;i<=m-1;i++){
                p=(p*d+pat[i])%q;
                t=(t*d+txt[i])%q;
            }
            for(int i=0;i<=n-m;i++){
               if(p==t){
                 bool flag=true;
                 for(int j=0;j<m;j++){
                     if(txt[i+j]!=pat[j]){flag=false;break;}
                 }
                 if(flag==true) res.push_back(i+1);
               }
               if(i<n-m){
                   t=(d*(t-txt[i]*h)+txt[i+m])%q;
                   if(t<0) t=t+q;
               }
            }
            if(res.size()<1) res.push_back(-1);
            return res;
        }

// Pattern Search KMP
// Prints occurrences of txt[] in pat[]
// Fills lps[] for given patttern pat[0..M-1]
void computeLPSArray(char* pat, int M, int* lps)
{
    // length of the previous longest prefix suffix
    int len = 0;

    lps[0] = 0; // lps[0] is always 0

    // the loop calculates lps[i] for i = 1 to M-1
    int i = 1;
    while (i < M) {
        if (pat[i] == pat[len]) {
            len++;
            lps[i] = len;
            i++;
        }
        else // (pat[i] != pat[len])
        {
            // This is tricky. Consider the example.
            // AAACAAAA and i = 7. The idea is similar
            // to search step.
            if (len != 0) {
                len = lps[len - 1];

                // Also, note that we do not increment
                // i here
            }
            else // if (len == 0)
            {
                lps[i] = 0;
                i++;
            }
        }
    }
}

void KMPSearch(char* pat, char* txt)
{
    int M = strlen(pat);
    int N = strlen(txt);

    // create lps[] that will hold the longest prefix suffix
    // values for pattern
    int lps[M];

    // Preprocess the pattern (calculate lps[] array)
    computeLPSArray(pat, M, lps);

    int i = 0; // index for txt[]
    int j = 0; // index for pat[]
    while (i < N) {
        if (pat[j] == txt[i]) {
            j++;
            i++;
        }

        if (j == M) {
            printf("Found pattern at index %d ", i - j);
            j = lps[j - 1];
        }

        // mismatch after j matches
        else if (i < N && pat[j] != txt[i]) {
            // Do not match lps[0..lps[j-1]] characters,
            // they will match anyway
            if (j != 0)
                j = lps[j - 1];
            else
                i = i + 1;
        }
    }
}
//Check if a String is Subsequence of Other
public:
    bool isSubSequence(string A, string B) 
    {
        // code here
        if(A.length()>B.length()) return false;
        int i=0,j=0;
        while(j<B.length()&&i<A.length()){
            if(A[i]==B[j]){i++,j++;}
            else j++;
        }
        if(i==A.length()) return true;
        else return false;
    }


LINKEDLISTS:
//01.Count nodes of linked list
//public:
    //Function to count nodes of a linked list.
    int getCount(struct Node* head){
    
        //Code here
        if(head==NULL) return 0;
        Node *p=head;
        int count=0;
        while(p!=NULL&&p->next!=NULL){
            count++;
            p=p->next;
        }
    return count+1;
    }

//02.Linked List Insertion
 public:
    //Function to insert a node at the beginning of the linked list.
    Node *insertAtBegining(Node *head, int x) {
       // Your code here
       if(head==NULL){head=new Node(x);return head;}
       Node *n=new Node(x);
       n->next=head;
       return n;
       
    }  
    //Function to insert a node at the end of the linked list.
    Node *insertAtEnd(Node *head, int x)  {
       // Your code here
       if(head==NULL){head=new Node(x);return head;}
       Node *n=new Node(x);
       Node *t=head;
       while(t->next!=NULL) t=t->next;
       t->next=n;
       return head;
    }

//03.Doubly linked list Insertion at given position
void addNode(Node *head, int pos, int x)
{
   // Your code here
   int count=0;
   Node *n=new Node(x);
   Node * t=head;
   while(count!=pos){
       t=t->next;
       count++;
   }
   if(t->next==NULL){t->next=n;n->prev=t; return;}
   n->next=t->next;
   n->prev=t;
   t->next=n;
   n->next->prev=n;
   return;
   
}
//04.Insert in Middle of Linked List
//Function to insert a node in the middle of the linked list.
Node* insertInMiddle(Node* head, int x)
{
	// Code here
	Node * slow=NULL;
	Node * fast=NULL;
	Node * n=new Node(x);
	if(head==NULL){head=n; return head;}
	slow=head;
	fast=head;
	while(fast!=NULL&&fast->next!=NULL&&fast->next->next!=NULL){
	    slow=slow->next;
	    fast=fast->next->next;
	}
	n->next=slow->next;
   	slow->next=n; 
	return head;
}

//05.Identical Linked Lists
//Function to check whether two linked lists are identical or not. 
bool areIdentical(struct Node *head1, struct Node *head2)
{
    // Code here
    Node *h1=head1;
    Node *h2=head2;
    while(h1!=NULL&&h2!=NULL&&h1->data==h2->data){
        h1=h1->next;
        h2=h2->next;
    }
    if(h1==NULL&&h2==NULL) return true;
    else return false;    
}

//06.Delete without head pointer
 public:
    //Function to delete a node without any reference to head pointer.
    void deleteNode(Node *del)
    {
       // Your code here
       del->data=del->next->data;
       Node *t=del->next;
       del->next=del->next->next;
       t->next=NULL;
       delete t;
    }
//07. Remove duplicate element from sorted Linked List
//Function to remove duplicates from sorted linked list.
Node *removeDuplicates(Node *head)
{
 // your code goes here
 Node *t=head;
 Node *q=head;
 while(t!=NULL&&t->next!=NULL){
     if(t->next!=NULL&&t->data!=t->next->data){t=t->next;}
     else if(t->next!=NULL&&t->data==t->next->data){
         q=t->next;
         t->next=t->next->next;
         q->next=NULL;
         delete q;
     }
 }
 return head;
}

//08.Remove duplicates from an unsorted linked list
public:
    //Function to remove duplicates from unsorted linked list.
    Node * removeDuplicates( Node *head) 
    {
     // your code goes here
     unordered_set<int> h;
     Node * curr=head;
     Node * prev=NULL;
     while(curr!=NULL){
         if(h.find(curr->data)!=h.end()){prev->next=curr->next;delete curr;}
         else{ 
             h.insert(curr->data);
             prev=curr;
         }
         curr=prev->next;
     }
     return head;
    }
//09.Merge two sorted linked lists
//Function to merge two sorted linked list.
Node* sortedMerge(Node* head1, Node* head2)  
{  
    // code here
    if(head1==NULL)return head2;
    if(head2==NULL)return head1;
    Node *head=NULL;
    Node *tail=NULL;
    if(head1->data<=head2->data){
        head=tail=head1;
        head1=head1->next;
    }
    else {
        head=tail=head2;
        head2=head2->next;
    }
    while(head1!=NULL&&head2!=NULL){
        if(head1->data<=head2->data){
            tail->next=head1;
            tail=head1;
            head1=head1->next;
        }
        else{
            tail->next=head2;
            tail=head2;
            head2=head2->next;
        }
    }
    if(head1==NULL){
        tail->next=head2;
    }else{
        tail->next=head1;
    }
    return head;    
}  
//10.Nth node from end of linked list
//Function to find the data of nth node from the end of a linked list.
int getNthFromLast(Node *head, int n)
{
       // Your code here
       if(head==NULL||n<=0)return -1;
       Node *first=head;
       Node *second=head;
       for(int i=1;i<=n;i++){
           if(first==NULL) return -1;
           first=first->next;
       }
       while(first!=NULL){
           first=first->next;
           second=second->next;
       }
       return second->data;    
}
//11.Swap Kth nodes from ends
Node *swapkthnode(Node* head, int num, int K)
{
 // Count nodes in linked list
	int n = num,k=K;        
	// Check if k is valid
	if (n < k)
		return head;
	// If x (kth node from start) and y(kth node from end)
	// are same
	if (2 * k - 1 == n)
		return head;
	// Find the kth node from the beginning of the linked
	// list. We also find previous of kth node because we
	// need to update next pointer of the previous.
	Node* x = head;
	Node* x_prev = NULL;
	for (int i = 1; i < k; i++) {
		x_prev = x;
		x = x->next;
	}
	// Similarly, find the kth node from end and its
	// previous. kth node from end is (n-k+1)th node from
	// beginning
	Node* y = head;
	Node* y_prev = NULL;
	for (int i = 1; i < n - k + 1; i++) {
		y_prev = y;
		y = y->next;
	}
	// If x_prev exists, then new next of it will be y.
	// Consider the case when y->next is x, in this case,
	// x_prev and y are same. So the statement "x_prev->next
	// = y" creates a self loop. This self loop will be
	// broken when we change y->next.
	if (x_prev)
		x_prev->next = y;
	// Same thing applies to y_prev
	if (y_prev)
		y_prev->next = x;
	// Swap next pointers of x and y. These statements also
	// break self loop if x->next is y or y->next is x
	Node* temp = x->next;
	x->next = y->next;
	y->next = temp;
	// Change head pointers when k is 1 or n
	if (k == 1)
		head = y;
	if (k == n)
		head = x;
	return head;
}
//12.Reverse a linked list
public:
    //Function to reverse a linked list.
    struct Node* reverseList(struct Node *head)
    {
        // code here
        // return head of reversed list
        if(head==NULL)return head;
        Node *curr=head;
        Node *prev=NULL;
        Node *next=head->next;
        while(curr->next!=NULL){
            curr->next=prev;
            prev=curr;
            curr=next;
            next=next->next;
        }
        curr->next=prev;
        head=curr;
        return head;
    }
//13.Detect Loop in linked list
public:
    //Function to check if the linked list has a loop.
    bool detectLoop(Node* head)
    {
        // your code here
        if(head==NULL)return false;
        Node *next=NULL;
        Node *temp=new Node(10);//dummy node;
        Node *curr=head;
        while(curr!=NULL){
            if(curr->next==NULL)return false;
            next=curr->next;
            if(curr->next==temp)return true;
            else  curr->next=temp;
            curr=next;
        }

    }
//14.Find length of Loop
//Function to find the length of a loop in the linked list.
int countNodesinLoop(struct Node *head)
{
    // Code here
    if(head==NULL)return 0;
    Node *fast=head,*slow=head;
    while(slow!=NULL&&fast!=NULL&&fast->next!=NULL){//floyd cycle detec == slow,fast pointer concept
        fast=fast->next->next;
        slow=slow->next;
        if(slow==fast){//here both pointers doesn't meet at start of loop but meet at any node in loop and then to find length of loop we count until that nodes comes again
            int count=1;
            Node *temp=slow;
            while(temp->next!=slow){
                count++;
                temp=temp->next;
            }
            return count;
        }
    }
    return 0;
}
//15.Remove loop in Linked List
int detectAndRemoveLoop(struct Node* list)
{
    struct Node *slow_p = list, *fast_p = list;

    // Iterate and find if loop exists or not
    while (slow_p && fast_p && fast_p->next) {
        slow_p = slow_p->next;
        fast_p = fast_p->next->next;

        /* If slow_p and fast_p meet at some point then there
           is a loop */
        if (slow_p == fast_p) {
            removeLoop(slow_p, list);

            /* Return 1 to indicate that loop is found */
            return 1;
        }
    }

    /* Return 0 to indicate that there is no loop*/
    return 0;
}

/* Function to remove loop.
 loop_node --> Pointer to one of the loop nodes
 head -->  Pointer to the start node of the linked list */
void removeLoop(struct Node* loop_node, struct Node* head)
{
    struct Node* ptr1 = loop_node;
    struct Node* ptr2 = loop_node;

    // Count the number of nodes in loop
    unsigned int k = 1, i;
    while (ptr1->next != ptr2) {
        ptr1 = ptr1->next;
        k++;
    }

    // Fix one pointer to head
    ptr1 = head;

    // And the other pointer to k nodes after head
    ptr2 = head;
    for (i = 0; i < k; i++)
        ptr2 = ptr2->next;

    /*  Move both pointers at the same pace,
      they will meet at loop starting node */
    while (ptr2 != ptr1) {
        ptr1 = ptr1->next;
        ptr2 = ptr2->next;
    }

    // Get pointer to the last node
    while (ptr2->next != ptr1)
        ptr2 = ptr2->next;

    /* Set the next node of the loop ending node
      to fix the loop */
    ptr2->next = NULL;
}

//16.Rotate a Linked List
public:
    //Function to rotate a linked list.
    Node* rotate(Node* head, int k)
    {
        // Your code here
        Node *t=head,*n=head;
        while(t!=NULL&&k>1){
            t=t->next;
            n=t;
            k--;
        }
        if(t==NULL)return head;
        while(n!=NULL&&n->next!=NULL){
            n=n->next;
        }
        n->next=head;
        head=t->next;
        t->next=NULL;
        return head;
    }
//17.Add two numbers represented by linked lists
 public:
    struct Node* addAtBegin(struct Node * head,int x){
        if(head==NULL){Node *n=new Node(x);head=n;return head;}
        Node *n=new Node(x);
        n->next=head;
        return n;
    }
    struct Node* reverseLL(struct Node* head){
        if(head==NULL)return head;
        Node *curr=head;
        Node *prev=NULL;
        Node *next=head->next;
        while(curr->next!=NULL){
            curr->next=prev;
            prev=curr;
            curr=next;
            next=next->next;
        }
        curr->next=prev;
        head=curr;
        return head;
    }
    //Function to add two numbers represented by linked list.
    struct Node* addTwoLists(struct Node* first, struct Node* second)
    {
        // code here
        Node *ans=NULL;
        first=reverseLL(first);
        second=reverseLL(second);
        int carry=0;
        while(first!=NULL||second!=NULL||carry==1){
            int newVal=carry;
            if(first!=NULL){newVal+=first->data;first=first->next;}
            if(second!=NULL){newVal+=second->data;second=second->next;}
            carry=newVal/10;
            newVal=newVal%10;
            ans=addAtBegin(ans,newVal);
        }
        return ans;
    }

//18.Pairwise swap of nodes in LinkeList
public:
    Node* pairWiseSwap(struct Node* head) 
    {
        // The task is to complete this method
        if(head==NULL||head->next==NULL)return head;
        Node *prev=head,*curr=head->next,*last=NULL;
        head=head->next;
        while(prev!=NULL&&prev->next!=NULL&&curr!=NULL){
            prev->next=curr->next;
            curr->next=prev;
            if(last!=NULL)last->next=curr;
            last=prev;
            prev=prev->next;
            if(prev!=NULL&&prev->next!=NULL) curr=prev->next;            
        }
        return head;
    }

//19.Check if Linked List is Palindrome
public:
    struct Node* reverseLL(struct Node* head){
        if(head==NULL)return head;
        Node *curr=head;
        Node *prev=NULL;
        Node *next=head->next;
        while(curr->next!=NULL){
            curr->next=prev;
            prev=curr;
            curr=next;
            next=next->next;
        }
        curr->next=prev;
        head=curr;
        return head;
    }
    //Function to check whether the list is palindrome.
    bool isPalindrome(Node *head)
    {
        //Your code here
        if(head==NULL) return false;
        Node *slow=head,*fast=head;
        while(fast!=NULL&&fast->next!=NULL&&fast->next->next!=NULL){
            slow=slow->next;
            fast=fast->next->next;
        }
        if(fast->next==NULL){//odd length
            slow->next=reverseLL(slow->next);
            Node * rev=slow->next;
            fast=head;
            while(fast!=slow){
                if(fast->data!=rev->data) return false;
                fast=fast->next;rev=rev->next;
            }
        }
        else {//even length
            slow->next=reverseLL(slow->next);
            Node * rev=slow->next;
            fast=head;
            while(fast!=slow->next){
                if(fast->data!=rev->data) return false;
                fast=fast->next;rev=rev->next;
            }
        }
        return true;
    }
//20.Merge Sort for Linked List
/*
Merge sort is often preferred for sorting a linked list. The slow random-access performance of a linked list makes some other algorithms (such as quicksort) perform poorly, and others (such as heapsort) completely impossible.
*/
public:
    Node* findMid(Node* head){
        if(head==NULL) return head;
        Node *slow=head,*fast=head;
        while(fast!=NULL&&fast->next!=NULL&&fast->next->next!=NULL){
            slow=slow->next;
            fast=fast->next->next;
        }
        return slow;
    }
    Node* merge(Node* l1,Node* l2){
        if(l1==NULL) return l2;
        if(l2==NULL)return l1;
        Node *head=NULL,*tail=NULL;
        if(l1->data<=l2->data){head=tail=l1;l1=l1->next;}
        else {head=tail=l2;l2=l2->next;}
        while(l1!=NULL&&l2!=NULL){
            if(l1->data<=l2->data){tail->next=l1;tail=l1;l1=l1->next;}
            else if(l1->data>l2->data){tail->next=l2;tail=l2;l2=l2->next;}
        }
        if(l1==NULL&&l2!=NULL){tail->next=l2;}
        if(l1!=NULL&&l2==NULL){tail->next=l1;}
        return head;
    }
    //Function to sort the given linked list using Merge Sort.
    Node* mergeSort(Node* head) {
        // your code here
        if(head==NULL) return head;
        if(head->next==NULL) return head;
        Node * mid=findMid(head);
        Node *head2=mid->next;
        mid->next=NULL;
        Node *l1= mergeSort(head);
        Node *l2= mergeSort(head2);
        head=merge(l1,l2);
        return head;
    }
//21.Given a linked list of 0s, 1s and 2s, sort it.
  public:
    //Function to sort a linked list of 0s, 1s and 2s.
    Node* segregate(Node *head) {
        
        // Add code here
        if(head==NULL) return NULL;
        Node *zero=NULL,*one=NULL,*t=head,*two=NULL,*z=NULL,*to=NULL,*o=NULL;
        while(t!=NULL){
            if(t->data==0){if(zero==NULL){z=zero=t;}else{zero->next=t;zero=t;} t=zero->next;zero->next=NULL;}
            else if(t->data==2){if(two==NULL){to=two=t;}else{two->next=t;two=t;} t=two->next;two->next=NULL;}
            else if(t->data==1){if(one==NULL){o=one=t;}else{one->next=t;one=t;} t=one->next;one->next=NULL;}
            
        }
        if(z!=NULL) head=z; else if(o!=NULL) head=o;else if(to!=NULL) head=to;
        if(zero!=NULL){if(o!=NULL)zero->next=o; else if(to!= NULL) zero->next=to; else zero->next=NULL;}
        if(one!=NULL){ if(to!=NULL)one->next=to;else one->next=NULL;}
        if(two!=NULL) two->next=NULL;
        return head;
    }
//22.Merge Sort on Doubly Linked List
Node *findMidDoubly(Node* head){
    if(head==NULL){return head;}
    Node *slow=head,*fast=head;
    while(fast!=NULL&&fast->next!=NULL&&fast->next->next!=NULL){
        slow=slow->next;
        fast=fast->next->next;
    }
    return slow;
    
}
Node *mergeDoubly(Node* l1,Node* l2){
    if(l1==NULL) return l2;
    if(l2==NULL) return l1;
    Node *head=NULL,*tail=NULL;
    if(l1->data<=l2->data){head=tail=l1;l1->prev=NULL;l1=l1->next;}
    else if(l1->data>l2->data){head=tail=l2;l2->prev=NULL;l2=l2->next;}
    while(l1!=NULL&&l2!=NULL){
        if(l1->data<=l2->data){tail->next=l1;l1->prev=tail;tail=l1;l1=l1->next;}
        else if(l1->data>l2->data){tail->next=l2;l2->prev=tail;tail=l2;l2=l2->next;}
    }
    if(l1!=NULL&&l2==NULL){tail->next=l1;l1->prev=tail;}
    if(l1==NULL&&l2!=NULL){tail->next=l2;l2->prev=tail;}
    return head;
}
//Function to sort the given doubly linked list using Merge Sort.
struct Node *sortDoubly(struct Node *head)
{
	// Your code here
	if(head==NULL||head->next==NULL)return head;
	Node *mid=findMidDoubly(head);
	Node *head2=mid->next;
	mid->next=NULL;
	head2->prev=NULL;
	Node *l1=sortDoubly(head);
	Node *l2=sortDoubly(head2);
	head=mergeDoubly(l1,l2);
	return head;
} 
//23.Merge K sorted linked lists
 public:
    Node* merge(Node* l1,Node* l2){
        if(l1==NULL) return l2;
        if(l2==NULL)return l1;
        Node *head=NULL,*tail=NULL;
        if(l1->data<=l2->data){head=tail=l1;l1=l1->next;}
        else {head=tail=l2;l2=l2->next;}
        while(l1!=NULL&&l2!=NULL){
            if(l1->data<=l2->data){tail->next=l1;tail=l1;l1=l1->next;}
            else if(l1->data>l2->data){tail->next=l2;tail=l2;l2=l2->next;}
        }
        if(l1==NULL&&l2!=NULL){tail->next=l2;}
        if(l1!=NULL&&l2==NULL){tail->next=l1;}
        return head;
    }
    //Function to merge K sorted linked list.
    Node * mergeKLists(Node *arr[], int K)
    {
           // Your code here
           int i=0,j;
           if(K>1) j=1;
           else return arr[0];
           while(j<K){
               arr[i]=merge(arr[i],arr[j]);
               j++;
           }
           return arr[0];
    }
//24.Intersection Point in Y Shapped Linked Lists
//Function to find intersection point in Y shaped Linked Lists.
int intersectPoint(Node* head1, Node* head2)
{
    // Your Code Here
    Node *t=head1,*p=NULL;
    int c1=0,c2=0;
    while(t!=NULL){
        t=t->next;
        c1++;
    }
    t=head2;
    while(t!=NULL){
        t=t->next;
        c2++;
    }
    int extra=abs(c1-c2);
    if(c1>=c2){t=head1;p=head2;}
    else{t=head2;p=head1;}
    while(extra>0){
        t=t->next;
        extra--;
    }
    while(t!=NULL&&p!=NULL&&t!=p){
       t=t->next;p=p->next; 
    }
    if(t!=NULL&&p!=NULL) return t->data;
    else return -1;    
}
//25.Clone a linked list with next and random pointer
public:
    Node *copyList(Node *head)
    {
        //Write your code here
        Node *h=NULL,*p=head,*n=NULL;
        while(p!=NULL){//add duplicate nodes to every original node
            n=new Node(p->data);
            n->next=p->next;
            p->next=n;
            p=p->next->next;
        }
        p=head;
        while(p!=NULL&&p->next!=NULL){//position arb of duplicates
          p->next->arb=(p->arb!=NULL)?(p->arb->next):NULL;
          p=p->next->next;
        }
        p=head;
        h=p->next;
        n=p->next;
        while(p!=NULL&&n!=NULL){//seperate duplicate list & original list
            p->next=(p->next!=NULL)?p->next->next:NULL;
            n->next=(n->next!=NULL)?n->next->next:NULL;
            p=p->next;
            n=n->next;
        }
        return h;
    }
//26.LRU Cache
//--later--\\

STACK:
//01.Implement stack using array
//Function to push an integer into the stack.
void MyStack :: push(int x)
{
    // Your Code
    if(top>=999)return;
    else top++;
    arr[top]=x;
    return;
    
}

//Function to remove an item from top of the stack.
int MyStack :: pop()
{
    // Your Code
    if(top<0)return -1;
    int res=arr[top];
    top--;
    return res;
}
//02.Implement Stack using Linked List
//Function to push an integer into the stack.
//trick is linked list grows like stack and not like normal way (one after another node)
void MyStack ::push(int x) 
{
    // Your code
    StackNode *n=new StackNode(x);
    if(top==NULL){top=n;n=NULL;delete n;}
    else{n->next=top;top=n;}
    return;
    
}

//Function to remove an item from top of the stack.
int MyStack ::pop() 
{
    // Your Code
    if(top==NULL)return -1;
    StackNode *t=top;
    int res=t->data;
    top=top->next;
    delete t;
    return res;
}
//03.Operations on Stack
//IT IS JAVA BASED QUESTION
// Function to insert element to stack
    public static void insert(Stack<Integer> st, int x)
    {
        // Your code here
        st.push(x);        
    }
    
    // Function to pop element from stack
    public static void remove(Stack<Integer> st)
    {
        int x =st.pop(); // Your code here        
    }
    
    // Function to return top of stack
    public static void headOf_Stack(Stack<Integer> st)
    {
        int x =st.peek(); // Your code here
        System.out.println(x + " ");
    }
    
    // Function to find the element in stack
    public static void find(Stack<Integer> st, int val)
    {    
        if(/*Your code here*/st.contains(val)){
            System.out.println("Yes");
        }
        else{
            System.out.println("No");
        }        
    }
//06.Parenthesis Checker
public:
    //Function to check if brackets are balanced or not.
    bool ispar(string x)
    {
        // Your code here
        if(x.length()%2!=0) return false;
        stack<char> st;
        for(int i=0;i<x.length();i++){
            if(x[i]=='{'||x[i]=='['||x[i]=='('){st.push(x[i]);}
            else if(st.empty()==true&&(x[i]=='}'||x[i]==']'||x[i]==')')){return false;}
            else if(x[i]=='}'){if(st.top()!='{') return false; else st.pop();}
            else if(x[i]==']'){if(st.top()!='[') return false; else st.pop();}
            else if(x[i]==')'){if(st.top()!='(') return false; else st.pop();}
        }
        if(st.empty()==true) return true;
        else return false;
    }
//07.Implement two stacks in an array
//Function to push an integer into the stack1.
void twoStacks :: push1(int x)
{
 if(top1+1==top2)return;
 top1++;
 arr[top1]=x;
}
   
//Function to push an integer into the stack2.
void twoStacks ::push2(int x)
{
 if(top1+1==top2) return;
 top2--;
 arr[top2]=x;
}
   
//Function to remove an element from top of the stack1.
int twoStacks ::pop1()
{
  if(top1==-1)return -1;
  int res=arr[top1];
  top1--;
  return res;
}

//Function to remove an element from top of the stack2.
int twoStacks :: pop2()
{
  if(top2==size) return -1;
  int res=arr[top2];
  top2++;
  return res;
}
//08.Get min at pop
//Function to push all the elements into the stack.
stack<int> _push(int arr[],int n)
{  //put all min in stack
   // your code here
   stack<int> res;
   int mini=INT_MAX;
   for(int i=0;i<n;i++){
       mini=min(mini,arr[i]);
       res.push(mini);
   }
   return res;
}

//Function to print minimum value in stack each time while popping.
void _getMinAtPop(stack<int>s)
{   //pop items in stack,stack contains all min
    // your code here
    while(s.size()>0){
        cout<<s.top()<<" ";
        s.pop();
    }  
}
//09.Delete middle element of a stack
public:
    //Function to delete middle element of a stack.
    void deleteFun(stack<int>&st,int sizeOfStack,int count){
        if(count<=0){st.pop(); return;}
        int temp=st.top();
        st.pop();
        count--;
        deleteFun(st, sizeOfStack-1,count);
        st.push(temp);
        return;
    }
    void deleteMid(stack<int>&st, int sizeOfStack)
    {
        // code here..
        if(sizeOfStack<=0) return;
        int count=(sizeOfStack%2!=0)?(sizeOfStack-(ceil(sizeOfStack+1)/2)):(sizeOfStack-(ceil(sizeOfStack)/2));
        deleteFun(st,sizeOfStack,count);
        return;
    }
//10.Infix to Postfix
 int prec(char c){
       if(c=='^'){return 3;}
       else if(c=='/'||c=='*'){return 2;}
       else if(c=='+'||c=='-'){return 1;}
       else{return -1;}
   }
   string infixToPostfix(string s) {
       // Your code here
       stack<char> st;
       string ans;
       for(int i=0;i<s.length();i++){
           if(s[i]>='a' && s[i]<='z' || s[i]>='A' && s[i]<='Z'){
               ans+=s[i]; //add the character by concatenation
           }
           else if(s[i]=='('){
               st.push(s[i]);
           }
           else if(s[i]==')'){
               while(st.top()!='('){
                   ans+=st.top();
                   st.pop();
               }
               st.pop();
           }
           else{
               while(!st.empty() && prec(s[i])<=prec(st.top())){
                   ans+=st.top();
                   st.pop();
               }
               st.push(s[i]);
           }
       }
       while(!st.empty()){
           ans+=st.top();
           st.pop();
       }
       return ans;
   }
//11.Evaluation of Postfix Expression
 public:
    int calc(int a,int b,char c){
        if(c=='/') return a/b;
        else if(c=='*') return a*b;
        else if(c=='+') return a+b;
        else if(c=='-') return a-b;
        else if(c=='^') return pow(a,b);
    }
    //Function to evaluate a postfix expression.
    int evaluatePostfix(string S)
    {
        // Your code here
        stack<int > st;
        int res=0;
        for(int i=0;i<S.length();i++){
            res=0;
            char c=S[i];
            if(c=='/'||c=='*'||c=='+'||c=='-'||c=='^'){
                int op1=st.top();st.pop();int op2=st.top();st.pop();
                res=calc(op2,op1,c);
                st.push(res);
            }
            else {st.push(int(c-48));}
        }
        res=st.top();
        st.pop();
        return res;
    }
//12.Stock span problem
void calculateSpan(int price[], int n, int S[])
{
    // Create a stack and push index of first
    // element to it
    stack<int> st;
    st.push(0);

    // Span value of first element is always 1
    S[0] = 1;

    // Calculate span values for rest of the elements
    for (int i = 1; i < n; i++) {
        // Pop elements from stack while stack is not
        // empty and top of stack is smaller than
      // price[i]
        while (!st.empty() && price[st.top()] <= price[i])
            st.pop();

        // If stack becomes empty, then price[i] is
        // greater than all elements on left of it,
        // i.e., price[0], price[1], ..price[i-1].  Else
        // price[i] is greater than elements after
        // top of stack
        S[i] = (st.empty()) ? (i + 1) : (i - st.top());

        // Push this element to stack
        st.push(i);
    }
}
//13.Next Greater Element
public:
    void reverse(vector<long long> &res){
        int i=0,j=res.size()-1;
        while(i<j){
            swap(res[i],res[j]);
            i++;j--;
        }
    }
    //Function to find the next greater element for each element of the array.
    vector<long long> nextLargerElement(vector<long long> arr, int n){
        // Your code here
        vector<long long> res;
        res.push_back(-1);
        stack<int> st;
        st.push(n-1);
        long long int nextgreater;
        for(int i=n-2;i>=0;i--){
            while(st.empty()!=true&&arr[i]>=arr[st.top()]){
                st.pop();
            }
            nextgreater=(st.empty()==true)?(-1):arr[st.top()];
            res.push_back(nextgreater);
            st.push(i);
        }
        reverse(res);
        return res;
    }
//14.Maximum Rectangular Area in a Histogram
public:
    vector<int> nextSmaller(long long int arr[],int n){
        stack<int> st;
        st.push(-1);
        vector<int > res(n);
        for(int i=n-1;i>=0;i--){
            int curr=arr[i];
            while(st.top()!=-1&&curr<=arr[st.top()]){st.pop();}
            res[i]=st.top();
            st.push(i);
        }
        return res;
    }
     vector<int> prevSmaller(long long int arr[],int n){
        stack<int> st;
        st.push(-1);
        vector<int > res(n);
        for(int i=0;i<n;i++){
            int curr=arr[i];
            while(st.top()!=-1&&curr<=arr[st.top()]){st.pop();}
            res[i]=st.top();
            st.push(i);
        }
        return res;
    }
    //Function to find largest rectangular area possible in a given histogram.
    long long getMaxArea(long long arr[], int n)
    {
        // Your code here
        vector<int> next,prev;
        next=nextSmaller(arr,n);
        prev=prevSmaller(arr,n);
        long long int length,area,height,res=INT_MIN,right;
        for(int i=0;i<n;i++){
            if(next[i]==-1){right=n;}
            else right=next[i];
            length=right-prev[i]-1;//when prev[i] is -1 then it is handled implicitly eg 6,2 prev =-1,-1 next=1,-1 so for element 2 right=2 as it is -1 so len=2-(-1)-1==2 ,hei=2,area=4;
            height=arr[i];
            area=length*height;
            res=max(res,area);
        }
        return res;
    }
//15.The Celebrity Problem
public:
    //Function to find if there is a celebrity in the party or not.
    int celebrity(vector<vector<int> >& M, int n) 
    {
        // code here 
        stack<int> st;
        for(int i=0;i<n;i++){//push all indexes (id)
            st.push(i);            
        }
        while(st.size()>1){//pick top 2 ele and check if a knows b--> b is possible candidate and a is not a celebrity else vice versa
            int a=st.top();st.pop();
            int b=st.top();st.pop();
            if(M[a][b]==1) st.push(b);
            else st.push(a);
        }
        int rem=st.top();//possible candidate
        for(int i=0;i<n;i++){//check rem's column
            if(M[rem][i]==1) return -1;
        }
        for(int i=0;i<n;i++){//check other's acquaintance with rem
            if(M[i][rem]!=1&&i!=rem)return -1;
        }
        return rem;
    }
//16.Maximum of minimum for every window size
void printMaxOfMin(int arr[], int n)
{
// Used to find previous and next smaller
    stack<int> s; 

    // Arrays to store previous and next smaller
    int left[n+1];  
    int right[n+1]; 

    // Initialize elements of left[] and right[]
    for (int i=0; i<n; i++)
    {
        left[i] = -1;
        right[i] = n;
    }

    // Fill elements of left[] using logic discussed on
    // https://www.cdn.geeksforgeeks.org/next-greater-element/
    for (int i=0; i<n; i++)
    {
        while (!s.empty() && arr[s.top()] >= arr[i])
            s.pop();

        if (!s.empty())
            left[i] = s.top();

        s.push(i);
    }

    // Empty the stack as stack is 
// going to be used for right[]
    while (!s.empty())
        s.pop();
// Fill elements of right[] using same logic
    for (int i = n-1 ; i>=0 ; i-- )
    {
        while (!s.empty() && arr[s.top()] >= arr[i])
            s.pop();

        if(!s.empty())
            right[i] = s.top();

        s.push(i);
    }

    // Create and initialize answer array
    int ans[n+1];
    for (int i=0; i<=n; i++)
        ans[i] = 0;

    // Fill answer array by comparing minimums of all
    // lengths computed using left[] and right[]
    for (int i=0; i<n; i++)
    {
        // length of the interval
        int len = right[i] - left[i] - 1;

        // arr[i] is a possible answer for this length 
        // 'len' interval, check if arr[i] is more than
        // max for 'len'
        ans[len] = max(ans[len], arr[i]);
    }

    // Some entries in ans[] may not be filled yet. Fill 
    // them by taking values from right side of ans[]
    for (int i=n-1; i>=1; i--)
        ans[i] = max(ans[i], ans[i+1]);

    // Print the result
    for (int i=1; i<=n; i++)
        cout << ans[i] << " ";
}

QUEUE:
//01.Implement Queue using array
/* 

The structure of the class is
class MyQueue {
private:
    int arr[100005];
    int front;
    int rear;

public :
    MyQueue(){front=0;rear=0;}
    void push(int);
    int pop();
};
 */

//Function to push an element x in a queue.
void MyQueue :: push(int x)
{
        // Your Code
        if(rear>=100005)return;
        arr[rear]=x;
        rear++;
        return;
}

//Function to pop an element from queue and return that element.
int MyQueue :: pop()
{
        // Your Code
        if(front==rear)return -1;
        int res=arr[front];
        front++;
        return res;
        
}
//02.Operations on Queue
public:
    // Function to insert element into the queue
    void insert(queue<int> &q, int k){
        // Your code here
        q.push(k);
    }
    
    // Function to find frequency of an element
    // return the frequency of k
    int findFrequency(queue<int> &q, int k){
        // Your code here
        int res=0,n=q.size();
        for(int i=0;i<n;i++){
            if(q.front()==k)res++;
            q.push(q.front());
            q.pop();
        }
        return res;
    }
//03.Implement Queue using Linked List
/* Structure of a node in Queue
struct QueueNode
{
    int data;
    QueueNode *next;
    QueueNode(int a)
    {
        data = a;
        next = NULL;
    }
};

And structure of MyQueue
struct MyQueue {
    QueueNode *front;
    QueueNode *rear;
    void push(int);
    int pop();
    MyQueue() {front = rear = NULL;}
}; */

//Function to push an element into the queue.
void MyQueue:: push(int x)
{
        // Your Code
        QueueNode *node=new QueueNode(x);
        if(front==NULL){front=node;rear=node; return;}
        if(rear!=NULL){rear->next=node;rear=rear->next;}
}

//Function to pop front element from the queue.
int MyQueue :: pop()
{
        // Your Code 
        QueueNode *n=front;
        if(front==NULL)return -1;
        int res=n->data;
        front=n->next;
        delete n;
        return res;
}
//04.Queue Reversal
//Function to reverse the queue.v
void fun(queue<int> &q){
    if(q.empty()==true)return;
    int temp=q.front();
    q.pop();
    fun(q);
    q.push(temp);
}
queue<int> rev(queue<int> q)
{
    // add code here
    fun(q);
    return q;
    
}
//05.Queue using two Stacks
/* The structure of the class is
class StackQueue{
private:   
    // These are STL stacks ( http://goo.gl/LxlRZQ )
    stack<int> s1;
    stack<int> s2;
public:
    void push(int);
    int pop();
}; */

//Function to push an element in queue by using 2 stacks.
void StackQueue :: push(int x)
{
    // Your Code
        while(s2.empty()!=true){s1.push(s2.top());s2.pop();}
        s2.push(x);
        while(s1.empty()!=true){s2.push(s1.top());s1.pop();}
    
}

//Function to pop an element from queue by using 2 stacks.
int StackQueue :: pop()
{
        // Your Code  
        if(s2.empty()==true)return -1;
        int res=s2.top();
        s2.pop();
        return res;
}
//06. Stack using two queues
/* The structure of the class is
class QueueStack{
private:
    queue<int> q1;
    queue<int> q2;
public:
    void push(int);
    int pop();
};
 */

//Function to push an element into stack using two queues.
void QueueStack :: push(int x)
{
        // Your Code
        while(q2.empty()!=true){q1.push(q2.front());q2.pop();}
        q2.push(x);
        while(q1.empty()!=true){q2.push(q1.front());q1.pop();}
}

//Function to pop an element from stack using two queues. 
int QueueStack :: pop()
{
        // Your Code 
        if(q2.empty()==true)return -1;
        int res=q2.front();
        q2.pop();
        return res;
}
//07.Generate Binary Numbers
//Function to generate binary numbers from 1 to N using a queue.
vector<string> generate(int N)
{
	// Your code here
	/*
	//m-1 o(nlogn)
	vector<string> ans;
	string res="";
	while(N>0){
	    int curr=N;
	    res="";
	    while(curr>0){
	      res=res+to_string(curr&1); 
	      curr=curr>>1;
	    }
	    reverse(res.begin(),res.end());
	    ans.push_back(res);
	    N--;
	}
	reverse(ans.begin(),ans.end());
	return ans;
	*/
	//m-2 -o(n)
	vector<string> ans;
	queue<string> q;
	q.push("1");
	while(N--){
	    string temp=q.front();
	    ans.push_back(temp);
	    q.pop();
	    q.push(temp+"0");
	    q.push(temp+"1");
	}
	return ans;	
}
//08.Reverse First K elements of Queue
void funRev(queue<int> &q,int k){
    if(k<=0)return;
    int temp=q.front();
    q.pop();
    k--;
    funRev(q,k);
    q.push(temp);
    return;
}
// User function Template for C++
// Function to reverse first k elements of a queue.
queue<int> modifyQueue(queue<int> q, int k) {
    // add code here.
    funRev(q,k);
    int rem=q.size()-k;
    while(rem--){
        q.push(q.front());
        q.pop();
    }
    return q;
}
//09.Circular tour
public:
  
    //Function to find starting point where the truck can start to get through
    //the complete circle without exhausting its petrol in between.
    int tour(petrolPump p[],int n)
    {
       //Your code here
       int start=0,curr_petrol=0,prev_petrol=0;
       for(int i=0;i<n;i++){
           curr_petrol+=p[i].petrol-p[i].distance;
           if(curr_petrol<0){
               start=i+1; // if pi fails then no one form p0 to pi can be start so check from i+1 and add all petrol till now as prev and do curr=o for new start and lastly check if prev+curr petrol>=0 then possible else -1
               prev_petrol+=curr_petrol;
               curr_petrol=0;               
           }
       }
       return ((curr_petrol+prev_petrol)>=0)?start:-1;
    }

DEQUE:
//01.Deque Implementations
// dq : deque in which element is to be pushed
// x : element to be pushed

// Function to push element x to the back of the deque.
void push_back_pb(deque<int> &dq, int x) {
    // Your code here
    dq.push_back(x);
}

// Function to pop element from back of the deque.
void pop_back_ppb(deque<int> &dq) {
    if (!dq.empty())/*Your code here*/dq.pop_back();
        else return;
}

// Function to return element from front of the deque.
int front_dq(deque<int> &dq) {
    if (!dq.empty())/*Your code here*/return dq.front();
        else return -1;
}

// Function to push element x to the front of the deque.
void push_front_pf(deque<int> &dq, int x) {
    // Your code here
    dq.push_front(x);
}
//02.Maximum of all subarrays of size k
public:
    //Function to find maximum of each subarray of size k.
    vector <int> max_of_subarrays(int *arr, int n, int k)
    {
        // your code here
        vector<int> ans;
        deque<int> dq;//will store index of  max of window in front
        for(int i=0;i<k;i++){//first window
            while(!dq.empty()&&arr[i]>=arr[dq.back()]){
                dq.pop_back();
            }
            dq.push_back(i);
        }
        for(int i=k;i<n;i++){//remaining windows
            ans.push_back(arr[dq.front()]);//ans of previous window
            while(!dq.empty()&&dq.front()<=i-k){dq.pop_front();}
            while(!dq.empty()&&arr[i]>=arr[dq.back()]){
                dq.pop_back();
            }
            dq.push_back(i);
        }
        ans.push_back(arr[dq.front()]);//ans of last window
        return ans;
    }


TREES:
//01.Preorder Traversal
//Function to return a list containing the preorder traversal of the tree.
void funPreOrder(Node* root,vector<int> &ans){
   if(root==NULL)return;
   ans.push_back(root->data);
   funPreOrder(root->left,ans);
   funPreOrder(root->right,ans);
}
vector <int> preorder(Node* root)
{
  // Your code here
  vector<int> ans;
  funPreOrder(root,ans);
  return ans;
}
//02.Inorder Traversal
public:
    // Function to return a list containing the inorder traversal of the tree.
    void funInOrder(Node* root,vector<int> &ans){
       if(root==NULL)return;
       funInOrder(root->left,ans);
       ans.push_back(root->data);
       funInOrder(root->right,ans);
    }
    vector <int> inOrder(Node* root)
    {
      // Your code here
      vector<int> ans;
      funInOrder(root,ans);
      return ans;
    }
//03.Postorder Traversal
//Function to return a list containing the postorder traversal of the tree.
 void funPostOrder(Node* root,vector<int> &ans){
       if(root==NULL)return;
       funPostOrder(root->left,ans);
       funPostOrder(root->right,ans);
       ans.push_back(root->data);
    }
    vector <int> postOrder(Node* root)
    {
      // Your code here
      vector<int> ans;
      funPostOrder(root,ans);
      return ans;
    }
//04.Height of Binary Tree
public:
    //Function to find the height of a binary tree.
    int height(struct Node* node){
        // code here 
      if(node==NULL)return 0;
      else return(max(height(node->left),height(node->right)))+1;
    }
//05.Determine if Two Trees are Identical
public:
    //Function to check if two trees are identical.
    bool isIdentical(Node *r1, Node *r2)
    {
        //Your Code here
        if(r1==NULL&&r2==NULL){return true;}
        else if(r1!=NULL&&r2!=NULL){
                if(r1->data==r2->data){
                    if(isIdentical(r1->left,r2->left)){
                     return isIdentical(r1->right,r2->right);   
                    }else return false;
                }else return false;
        }
        else return false;
    }
//06.Children Sum Parent
 public:
    //Function to check whether all nodes of a tree have the value 
    //equal to the sum of their child nodes.
    int isSumProperty(Node *root)
    {
     // Add your code here
     if(root==NULL) return 1;//true
     if(root!=NULL&&root->left==NULL&&root->right==NULL) return 1;//true
     int sum=0;
     if(root->left!=NULL){sum+=root->left->data;}
     if(root->right!=NULL){sum+=root->right->data;}
     return (root->data==sum&&isSumProperty(root->left)&&isSumProperty(root->right));//check data==sum and left and right subtrees also hold this then only true overall.
    }
//07.Level order traversal
 public:
    //Function to return the level order traversal of a tree.
    vector<int> levelOrder(Node* node)
    {
      //Your code here
      vector<int> ans;
      if(node==NULL)return ans;
      queue<Node*> q;
      q.push(node);
      while(!q.empty()){
          Node *temp=q.front();
          q.pop();
          ans.push_back(temp->data);
          if(temp->left!=NULL)q.push(temp->left);
          if(temp->right!=NULL)q.push(temp->right);
      }
      return ans;
    }
//08.Level order traversal Line by Line
//Function to return the level order traversal line by line of a tree.
vector<vector<int>> levelOrder(Node* node)
{
  //Your code here
  vector<vector<int>> res;
   vector<int> ans;
  if(node==NULL)return res;
  queue<Node*> q;
  q.push(node);
  int levelnodes;
  while(!q.empty()){
      levelnodes=q.size();//means this time it has to process this much(q.size()) number of items which are in this level.valid for every next level elements 
      ans.erase(ans.begin(),ans.end());
      while(!q.empty()&&levelnodes>0){
          Node *temp=q.front();
          q.pop();
          ans.push_back(temp->data);
          if(temp->left!=NULL)q.push(temp->left);
          if(temp->right!=NULL)q.push(temp->right);
          levelnodes--;
      }
      res.push_back(ans);
  }
  return res;
}
//09.Level order traversal in spiral form
//Function to return a list containing the level order traversal in spiral form.
vector<int> findSpiral(Node *node)
{
    //Your code here
   vector<int> ans;
   vector<int> res;
  if(node==NULL)return ans;
  queue<Node*> q;
  q.push(node);
  int levelnodes;
  int flag=1;//1 means tedha  0 means sidha
  while(!q.empty()){
      levelnodes=q.size();//means this time it has to process this much(q.size()) number of items which are in this level.valid for every next level elements 
      if(flag==1){
          ans.erase(ans.begin(),ans.end());
          while(!q.empty()&&levelnodes>0){
              Node *temp=q.front();
              q.pop();
              ans.push_back(temp->data);
              if(temp->left!=NULL)q.push(temp->left);
              if(temp->right!=NULL)q.push(temp->right);
              levelnodes--;
          }
          for(int i=ans.size()-1;i>=0;i--){
              res.push_back(ans[i]);
          }
      }
      else{
          while(!q.empty()&&levelnodes>0){
              Node *temp=q.front();
              q.pop();
              res.push_back(temp->data);
              if(temp->left!=NULL)q.push(temp->left);
              if(temp->right!=NULL)q.push(temp->right);
              levelnodes--;
          }
      }
      flag=(flag==0)?1:0;
  }
  return res;    
}

//10.Maximum Width of Tree
// public:
    // Function to get the maximum width of a binary tree.
    int getMaxWidth(Node* node) {
        // Your code here
      if(node==NULL)return 0;
      queue<Node*> q;
      q.push(node);
      int levelnodes,res=INT_MIN;
      while(!q.empty()){
          levelnodes=q.size();//means this time it has to process this much(q.size()) number of items which are in this level.valid for every next level elements 
          res=max(res,levelnodes);
          while(!q.empty()&&levelnodes>0){
              Node *temp=q.front();
              q.pop();
              if(temp->left!=NULL)q.push(temp->left);
              if(temp->right!=NULL)q.push(temp->right);
              levelnodes--;
          }
          
      }
      return res;
    }
//11.Check for Balanced Tree
public:
    //Function to check whether a binary tree is balanced or not.
    int funIsBalanced(Node *root){
        if(root==NULL)return 0;
        int left=funIsBalanced(root->left);
        if(left==-1)return -1;
        int right=funIsBalanced(root->right);
        if(right==-1)return -1;
        if(abs(left-right)>1)return -1;
        else return max(left,right)+1;//return height which is max for this subtree
    }
    bool isBalanced(Node *root)
    {
        //  Your Code here
        return (funIsBalanced(root)==-1)?0:1;        
    }
//12.Left View of Binary Tree
vector<int> leftView(Node *root)
{
   // Your code here
  //doing just l.o.t
   vector<int> ans;
   if(root==NULL)return ans;
   queue<Node*>q;
   q.push(root);
   int count,i;
   while(q.empty()!=true){
       count=q.size();
       i=count;
       while(!q.empty()&&count>0){
           Node *temp=q.front();
           if(count==i)ans.push_back(temp->data);
           q.pop();
           if(temp->left!=NULL)q.push(temp->left);
           if(temp->right!=NULL)q.push(temp->right);
           count--;
       }
   }
   return ans;
}
//13.Right View of Binary Tree
//Function to return list containing elements of right view of binary tree.
    vector<int> rightView(Node *root)
    {
       // Your Code here
       vector<int> t;
       vector<int> ans;
       if(root==NULL)return ans;
       queue<Node*>q;
       q.push(root);
       int count,i;
       while(q.empty()!=true){
           count=q.size();
           t.clear();
           while(!q.empty()&&count>0){
               Node *temp=q.front();
               t.push_back(temp->data);
               q.pop();
               if(temp->left!=NULL)q.push(temp->left);
               if(temp->right!=NULL)q.push(temp->right);
               count--;
           }
           if(t.size()>0){
               int n=t.size()-1;
               ans.push_back(t[n]);
           }
       }
       return ans;
    }
//14.Lowest Common Ancestor in a Binary Tree
//Function to return the lowest common ancestor in a Binary Tree.
    Node* lca(Node* root ,int n1 ,int n2 )
    {
       //Your code here 
       if(root==NULL)return NULL;
       if(root->data==n1||root->data==n2) return root;//if found return this node
       Node* left=lca(root->left,n1,n2);
       Node* right=lca(root->right,n1,n2);
       //4 cases where n1 and n2 can be there
       if(left!=NULL&&right!=NULL)return root; //both are in different halfs or subtrees :one in left and other in right
       else if(left!=NULL)return left;//both in left subtree
       else if(right!=NULL)return right;//both in right subtree
       else return NULL;//both in none
    }
//15.Diameter of Binary Tree
 // Function to return the diameter of a Binary Tree.
    int res=INT_MIN;//will store diameter
    int height(Node* root){//modify height fun
        if(root==NULL)return 0;
        int lh=height(root->left);
        int rh=height(root->right);
        res=max(res,lh+rh+1);//stores diameter(max no of nodes on this path) through this node root
        return max(lh,rh)+1;
    }
    int diameter(Node* root) {
        // Your code here
        height(root);
        return res;
    }
//16.Vertical Width of a Binary Tree
//Function to find the vertical width of a Binary Tree.
int verticalWidth(Node* root)
{
    // Code here
    //doing just l.o.t by maintaining line number
    if(root==NULL)return 0;
    queue<pair<Node*,int>> q;
    unordered_set<int> s;
    q.push({root,0});
    while(q.empty()!=true){
        Node* temp=q.front().first;
        int line=q.front().second;
        q.pop();
        s.insert(line);
        if(temp->left!=NULL){q.push({temp->left,line-1});}
        if(temp->right!=NULL){q.push({temp->right,line+1});}
    }
    return s.size();
}
//17.Mirror Tree
 public:
    // Function to convert a binary tree into its mirror tree.
    void mirror(Node* node) {
        // code here
        if(node==NULL||node->left==NULL&&node->right==NULL)return;
        mirror(node->left);
        Node* left=node->left;
        mirror(node->right);
        Node* right=node->right;
        node->left=right;
        node->right=left;
        return;
    }
//18.Check if subtree
 //Function to check if S is a subtree of tree T.
    bool compare(Node* a,Node* b){
        if(a==NULL&&b==NULL)return true;
        if(a==NULL&&b!=NULL||a!=NULL&&b==NULL)return false;
        if(a->data!=b->data)return false;
        return compare(a->left,b->left)&&compare(a->right,b->right);
    }
    bool isSubTree(Node* T, Node* S) 
    {
        // Your code here
        if(T==NULL&&S==NULL)return true;
        if(T==NULL&&S!=NULL||T!=NULL&&S==NULL)return false;
        queue<Node*> q;
        q.push(T);
        Node *curr=NULL;
        while(!q.empty()){
           curr=q.front(); 
           if(curr->data==S->data){bool flag=compare(curr,S);if(flag==true)return true;}
           q.pop();
           if(curr->left)q.push(curr->left);
           if(curr->right)q.push(curr->right);
        }
        return false;
    }
//19.Make Binary Tree From Linked List
//Function to make binary tree from linked list.
void convert(Node *head, TreeNode *&root) {
    // Your code here
    if(head==NULL)return;
    queue<TreeNode*>q;
    root=new TreeNode(head->data);
    q.push(root);
    head=head->next;
    while(!q.empty()&&head!=NULL){
        TreeNode* parent=q.front();
        q.pop();
        if(head!=NULL){
            TreeNode* leftchild=new TreeNode(head->data);
            parent->left=leftchild;
            q.push(leftchild);
            head=head->next;
        }        
        if(head!=NULL){
            TreeNode* rightchild=new TreeNode(head->data);
            parent->right=rightchild;
            q.push(rightchild);
            head=head->next;
        }        
    }    
    return;
}
//20.Binary Tree to DLL
 public: 
    //Function to convert binary tree to doubly linked list and return it.
    Node *prev,*head;
    void funbToDLL(Node* root){//just do inorder traversal and store prev
      if(root==NULL){return;} 
      funbToDLL(root->left);
      if(prev){prev->right=root;root->left=prev;prev=root;}
      else {head=root,prev=root;}
      funbToDLL(root->right);
      return;
    }
    Node * bToDLL(Node *root)
    {
        // your code here
        if(root==NULL)return root;
        prev=NULL;
        funbToDLL(root);
        prev=NULL;
        return head;
    }
//21.Binary Tree to CDLL
//Function to convert binary tree into circular doubly linked list.
    Node *prev,*h,*tail;
    void funbTreeToCList(Node *root){
        if(root==NULL)return;
        funbTreeToCList(root->left);
        if(prev){
            prev->right=root;root->left=prev;prev=root;tail=root;
        }else{prev=root;tail=root;h=root;}
        funbTreeToCList(root->right);
        return;
    }
    Node *bTreeToCList(Node *root)
    {
    //add code here.
    if(root==NULL)return root;
    prev=NULL;h=tail=NULL;
    funbTreeToCList(root);
    if(h&&tail){h->left=tail;tail->right=h;}
    return h;
    }
//22.Connect Nodes at Same Level
//Function to connect nodes at same level.
    void connect(Node *root)
    {
       // Your Code Here
       if(root==NULL)return;
       queue<Node*> q;
       q.push(root);
       while(!q.empty()){
           int count=q.size();
           while(count>0){
           Node *curr=q.front();
           q.pop();
           if(count>1){curr->nextRight=q.front();}
           else if(count==1){curr->nextRight=NULL;}
           if(curr->left){q.push(curr->left);}
           if(curr->right){q.push(curr->right);}
           count--;
           }
       }
       return;
    }
//23.Construct Binary Tree from Parent Array
//Function to construct binary tree from parent array.
    void createNode(Node *created[],int i,int parentarr[],Node** root){
        if(created[i]!=NULL)return;
        Node* n=new Node(i);
        created[i]=n;
        if(parentarr[i]==-1){*root=n;return;}
        if(created[parentarr[i]]==NULL){
            createNode(created,parentarr[i],parentarr,root);
        }
        Node* daddy=created[parentarr[i]];
        if(daddy->left==NULL){daddy->left=n;}
        else if(daddy->right==NULL){daddy->right=n;}
        return;
    }
    Node *createTree(int parentarr[], int n)
    {
        // Your code here
        Node *root=NULL;
        Node *created[n];
        for(int i=0;i<n;i++){
            created[i]=NULL;
        }
        for(int i=0;i<n;i++){
            createNode(created,i,parentarr,&root);
        }
        return root;
    }
//24.Tree from Postorder and Inorder
/* Recursive function to construct binary of size n
from Inorder traversal in[] and Postorder traversal
post[]. Initial values of inStrt and inEnd should
be 0 and n -1. The function doesn't do any error
checking for cases where inorder and postorder
do not form a tree */
Node* buildUtil(int in[], int post[], int inStrt,
	int inEnd, int* pIndex, unordered_map<int, int>& mp)
{
	// Base case
	if (inStrt > inEnd)
		return NULL;

	/* Pick current node from Postorder traversal
	using postIndex and decrement postIndex */
	int curr = post[*pIndex];
	Node* node = newNode(curr);
	(*pIndex)--;

	/* If this node has no children then return */
	if (inStrt == inEnd)
		return node;

	/* Else find the index of this node in Inorder
	traversal */
	int iIndex = mp[curr];

	/* Using index in Inorder traversal, construct
	left and right subtress */
        //we call right first since we are building right subtree since postindex is decrementing and going from right to left
	node->right = buildUtil(in, post, iIndex + 1,
							inEnd, pIndex, mp);
	node->left = buildUtil(in, post, inStrt,
						iIndex - 1, pIndex, mp);

	return node;
}

// This function mainly creates an unordered_map, then
// calls buildTreeUtil()
struct Node* buildTree(int in[], int post[], int len)
{
	// Store indexes of all items so that we
	// we can quickly find later
	unordered_map<int, int> mp;
	for (int i = 0; i < len; i++)
		mp[in[i]] = i;

	int index = len - 1; // Index in postorder
	return buildUtil(in, post, 0, len - 1,
					&index, mp);
}

//25.Foldable Binary Tree
//here we just change right subtree of root to its mirror image and compare left and right subtree.if same structrue then foldable else not.
//Function to check whether a binary tree is foldable or not.
void mirror(Node* root){ 
    if(root==NULL)return;
    if(root->left==NULL&&root->right==NULL)return;
    mirror(root->left);
    mirror(root->right);
    Node* left=root->left;
    Node* right=root->right;
    root->left=right;
    root->right=left;
    return;
}
bool isStructureSame(Node* a,Node* b){
    if(a==NULL&&b==NULL)return true;
    if(a==NULL&&b!=NULL||a!=NULL&&b==NULL)return false;
    return isStructureSame(a->left,b->left)&&isStructureSame(a->right,b->right);
}
bool IsFoldable(Node* root)
{
    // Your code goes here
    if(root==NULL)return true;
    mirror(root->right);
    bool res=isStructureSame(root->left,root->right);
    return res;
}
//26.Maximum path sum from any node
/*For each node there can be four ways that the max path goes through the node: 
1. Node only 
2. Max path through Left Child + Node 
3. Max path through Right Child + Node 
4. Max path through Left Child + Node + Max path through Right Child
The idea is to keep trace of four paths and pick up the max one in the end. An important thing to note is, root of every subtree need to return maximum path sum such that at most one child of root is involved. This is needed for parent function call. In below code, this sum is stored in max_single and returned by the recursive function
*/
// This function returns overall maximum path sum in 'res'
// And returns max path sum going through root.
int findMaxUtil(Node* root, int &res)
{
	//Base Case
	if (root == NULL)
		return 0;

	// l and r store maximum path sum going through left and
	// right child of root respectively
	int l = findMaxUtil(root->left,res);
	int r = findMaxUtil(root->right,res);

	// Max path for parent call of root. This path must
	// include at-most one child of root
	int max_single = max(max(l, r) + root->data, root->data);//max of 1 2 3 cases

	// Max Top represents the sum when the Node under
	// consideration is the root of the maxsum path and no
	// ancestors of root are there in max sum path
	int max_top = max(max_single, l + r + root->data);//max of 1 2 3 and 4

	res = max(res, max_top); // Store the Maximum Result.

	return max_single;//max of 1 2 3 since we need to return to the called node : the path to be followed in this subtree.(either node or node-anychild)
}

// Returns maximum path sum in tree with given root
int findMaxSum(Node *root)
{
	// Initialize result
	int res = INT_MIN;

	// Compute and return result
	findMaxUtil(root, res);
	return res;
}
//27.Maximum difference between node and its ancestor
Node* funmaxDiff(Node* root,int* res){
    if(root==NULL)return NULL;
    if(root->left==NULL&&root->right==NULL)return root;
    Node* left=funmaxDiff(root->left,res);
    Node* right=funmaxDiff(root->right,res);
    if(left==NULL){
        int currmaxDiff=(root->data)-(right->data);
        Node* returnvalue=((root->data)<(right->data))?root:right;
        *res=max(*res,currmaxDiff);
        return returnvalue;
    }
    if(right==NULL){
        int currmaxDiff=(root->data)-(left->data);
        Node* returnvalue=((root->data)<(left->data))?root:left;
        *res=max(*res,currmaxDiff);
        return returnvalue;
    }
    int currmaxDiff=max((root->data)-(left->data),(root->data)-(right->data));
    Node* mini=((left->data)<(right->data))?left:right;
    Node* returnvalue=((root->data)<(mini->data))?root:mini;
    *res=max(*res,currmaxDiff);
    return returnvalue;
}

int maxDiff(Node* root)
{
    // Your code here
    if(root==NULL)return 0;
    int res=INT_MIN;
    funmaxDiff(root,&res);
    return res;
}
//28.Count Number of SubTrees having given Sum
//Function to count number of subtrees having sum equal to given sum.
int funcountSubtreesWithSumX(Node* root,int* count,int x){
    if(root==NULL)return 0;
    if(root->left==NULL&&root->right==NULL){if(root->data==x) (*count)++;return root->data;}
    int left=funcountSubtreesWithSumX(root->left,count,x);
    int right=funcountSubtreesWithSumX(root->right,count,x);
    int sum=0;
    if(root->data==x&&root->left==NULL&&root->right==NULL) (*count)++;
    sum=sum+(root->data)+left+right;
    if(sum==x)(*count)++;
    return sum;
}
int countSubtreesWithSumX(Node* root, int X)
{
	// Code here
	if(root==NULL)return 0;
	int count=0;
	funcountSubtreesWithSumX(root,&count,X);
	return count;
}
//29.Serialize and Deserialize a Binary Tree
public:
    //Function to serialize a tree and return a list containing nodes of tree.
    vector<int> serialize(Node *root) 
    {
        //Your code here
        vector<int> ans;
        if(root==NULL)return ans;
        queue<Node*> q;
        q.push(root);
        ans.push_back(root->data);
        while(!q.empty()){
           int count=q.size();
           while(count>0){
               Node* curr=q.front();
               q.pop();
               if(curr->left){ ans.push_back(curr->left->data);q.push(curr->left);}
               else ans.push_back(-100);
               if(curr->right){ ans.push_back(curr->right->data);q.push(curr->right);}
               else ans.push_back(-100);
               count--;
           }
        }
        return ans;
    }
    
    //Function to deserialize a list and construct the tree.
    Node * deSerialize(vector<int> &A)
    {
       //Your code here
       if(A.size()==0)return NULL;
       int i=0;
       Node* root=new Node(A[i]);
       queue<Node*>q;
       q.push(root);
       i++;
       while(!q.empty()){
           int count=q.size();
           while(count>0){
               Node* curr=q.front();
               q.pop();
               if(A[i]!=-100){Node* n=new Node(A[i]);curr->left=n;q.push(n);}
               //else curr->left=NULL;
               i++;
               if(A[i]!=-100){curr->right=new Node(A[i]);q.push(curr->right);}
               //else curr->right=NULL;
               i++;
               count--;
           }
       }
       return root;
    }
//30.Node at distance
void getKDistance(Node* root,int k,int level,map<int,pair<Node*,bool>> &mp,int &count){
    if(root == NULL){
        return;
    }
    
    mp[level].first = root;
    mp[level].second = false;
    
    if(root->left == NULL && root->right == NULL){
        if(level-k >= 0 && mp[level-k].second != true){
            mp[level-k].second = true;
            count++;
        }
    }
    
    getKDistance(root->left,k,level+1,mp,count);
    getKDistance(root->right,k,level+1,mp,count);
}

//Function to return count of nodes at a given distance from leaf nodes.
int printKDistantfromLeaf(Node* root, int k)
{
    int count = 0;
    map<int,pair<Node*,bool>> mp;//map[pathlen,{node(for value),visited(yes or no)}]
    getKDistance(root,k,0,mp,count);
    return count;
}
//31.ZigZag Tree Traversal
 //Function to store the zig zag order traversal of tree in a list.
    vector <int> zigZagTraversal(Node* node)
    {
    	// Code here
    	 vector<int> ans;
   vector<int> res;
  if(node==NULL)return ans;
  queue<Node*> q;
  q.push(node);
  int levelnodes;
  int flag=0;//1 means tedha  0 means sidha
  while(!q.empty()){
      levelnodes=q.size();//means this time it has to process this much(q.size()) number of items which are in this level.valid for every next level elements 
      if(flag==1){
          ans.erase(ans.begin(),ans.end());
          while(!q.empty()&&levelnodes>0){
              Node *temp=q.front();
              q.pop();
              ans.push_back(temp->data);
              if(temp->left!=NULL)q.push(temp->left);
              if(temp->right!=NULL)q.push(temp->right);
              levelnodes--;
          }
          for(int i=ans.size()-1;i>=0;i--){
              res.push_back(ans[i]);
          }
      }
      else{
          while(!q.empty()&&levelnodes>0){
              Node *temp=q.front();
              q.pop();
              res.push_back(temp->data);
              if(temp->left!=NULL)q.push(temp->left);
              if(temp->right!=NULL)q.push(temp->right);
              levelnodes--;
          }
      }
      flag=(flag==0)?1:0;
  }
  return res;  
    }
//32.Maximum sum of Non-adjacent nodes
/*
For every node, we find the following:

1.Maximum sum of non-adjacent nodes including the node.
2.Maximum sum of non-adjacent nodes excluding the node.
Now, we return both the values in the recursive call. The parent node of the previously calculated node gets the maximum sum (including & excluding) the child node. Accordingly, the parent now calculates the maximum sum(including & excluding) and returns. This process continues till root node. Finally, we return the max(sum including root, sum excluding root).
*/
pair<int, int> max_sum(Node* root)
{

    if (!root)

        return { 0, 0 };
 

    auto left = max_sum(root->left);

    auto right = max_sum(root->right);
 

    int no_root_l = left.first, root_l = left.second;
 

    int no_root_r = right.first, root_r = right.second;
 

    int root_sum_max

        = max(max(root->data, root->data + no_root_l),

              max(root->data + no_root_r,

                  root->data + no_root_r + no_root_l));

    int no_root_sum_max = max(

        max(root_l, root_r),

        max(max(root_l + root_r, no_root_l + no_root_r),

            max(root_l + no_root_r, root_r + no_root_l)));
 

    return { no_root_sum_max, root_sum_max };
}
 

int getMaxSum(Node* root)
{

    pair<int, int> ans = max_sum(root);

    return max(ans.first, ans.second);
}

BINARY SEARCH TREE:
//03.Insert a node in a BST
// Function to insert a node in a BST.
Node* fun(Node* root,int &key){
    if(root==NULL){return NULL;}
    if(root->data==key){return root;}
    if(root->data>key){
        Node* left=fun(root->left,key);
        if(left==NULL){root->left=new Node(key);}
        return root;
    }
    else{
        Node* right=fun(root->right,key);
        if(right==NULL){root->right=new Node(key);}
        return root;
    }
}
Node* insert(Node* root, int key) {
    // Your code here
    if(root==NULL){Node *n=new Node(key);
        root=n;
        return root;
    }
    fun(root,key);
    return root;
}
//04.Search a node in BST
// Function to search a node in BST.
bool search(Node* root, int x) {
    // Your code here
    if(root==NULL)return false;
    if(root->data==x)return true;
    if(root->data<x){return search(root->right,x);}
    else return search(root->left,x);
}
//05.Minimum element in BST
// Function to find the minimum element in the given BST.
void fun(Node* root,int &mini){
    if(root==NULL)return;
    mini=root->data;
    fun(root->left,mini);
    return;
}
int minValue(Node* root) {
    // Code 
    if(root==NULL)return -1;
    int mini;
    fun(root,mini);
    return mini;
}
//06.Find Common Nodes in two BSTs
 //Function to find the nodes that are common in both BST.
    void inorder(Node *root,auto &h){
      if(root==NULL)return;
      inorder(root->left,h);
      h.insert(root->data);
      inorder(root->right,h);
    }
    void fun(Node* root,auto &h,auto &ans){
        if(root==NULL)return;
        fun(root->left,h,ans);
        if(h.find(root->data)!=h.end()) ans.push_back(root->data);
        fun(root->right,h,ans);
    }
    vector <int> findCommon(Node *root1, Node *root2)
    {
     //Your code here
     vector<int> ans;
     if(root1==NULL&&root2==NULL)return ans;
     unordered_set<int> h;
     inorder(root1,h);
     fun(root2,h,ans);
     return ans;
    }
//07.Delete a node from BST
// Function to delete a node from BST.
Node *deleteNode(Node *root, int x) {
    // your code goes here
    if(root==NULL)return root;
    //reach to reqd node using binary search feature.
    if(root->data>x){
        root->left=deleteNode(root->left,x);
        return root;
    }
    else if(root->data<x){
        root->right=deleteNode(root->right,x);
        return root;
    }
    //reqd node reached
    if(root->left==NULL){
        Node* temp=root->right;
        delete root;
        return temp;
    }
    else if(root->right==NULL){
        Node* temp=root->left;
        delete root;
        return temp;
    }
    else{
        //both childs are there
        //plan is to delete succ node ,so reach to it and copy its data to root and delete succ. 
        Node *succparent=root;
        Node *succ=root->right;
        while(succ->left!=NULL){
            succparent=succ;
            succ=succ->left;
        }
        if(succparent==root){
            succparent->right=succ->right;
        }
        else{
            succparent->left=succ->right;
        }
        root->data=succ->data;
        delete succ;
        return root;
    }
}
//08.Lowest Common Ancestor in a BST
//Function to find the lowest common ancestor in a BST. 
Node* LCA(Node *root, int n1, int n2)
{
   //Your code here
   if(root==NULL)return NULL;
   if(root->data==n1||root->data==n2){
       return root;
   }
   Node *left=LCA(root->left,n1,n2);
   Node *right=LCA(root->right,n1,n2);
   if(left!=NULL&&right!=NULL){
       return root;
   }
   else if(left!=NULL){
       return left;
   }
   else if(right!=NULL){
       return right;
   }
}
//09.Print BST elements in given range
public:
  void helper(Node *root,int low,int high,vector<int>& ans){
      if(root==NULL)return;
      if(root->data>=low&&root->data<=high){
          ans.push_back(root->data);
          helper(root->left,low,high,ans);
          helper(root->right,low,high,ans);
      }
      else if(root->data>high){
          helper(root->left,low,high,ans);
      }
      else if(root->data<low){
          helper(root->right,low,high,ans);
      }
      
  }
    vector<int> printNearNodes(Node *root, int low, int high) {
        //code here   
        vector<int> ans;
        helper(root,low,high,ans);
        sort(ans.begin(),ans.end());
        return ans;
        
    }
//10.Pair Sum in BST
void inorder(Node *root,vector<int> & ans){
        if(root==NULL)return;
        inorder(root->left,ans);
        ans.push_back(root->data);
        inorder(root->right,ans);
    }
    // root : the root Node of the given BST
    // target : the target sum
    int isPairPresent(struct Node *root, int target)
    {
    //add code here.
        if(root==NULL) return 0;
        vector<int> ans;
        inorder(root,ans);
        unordered_set<int> h;
        for(auto i: ans){
            if(h.find(target-i)!=h.end()){return 1;}
            h.insert(i);
        }
        return 0;
    }
//11.Smaller on Right
later
//12.Floor in BST
int floor(Node* root, int key)
{
    if (!root)
        return INT_MAX;
 
    /* If root->data is equal to key */
    if (root->data == key)
        return root->data;
 
    /* If root->data is greater than the key */
    if (root->data > key)
        return floor(root->left, key);
 
    /* Else, the floor may lie in right subtree
      or may be equal to the root*/
    int floorValue = floor(root->right, key);
    return (floorValue <= key) ? floorValue : root->data;
}
//13.Ceil in BST
// User function Template for C++
int helper(Node *root,int &key,int& ans){
    if(root==NULL)return -1;
    if(root->data==key){
        ans=key;
        return key;
    }
    else if(root->data>key){
        int l=helper(root->left,key,ans);
        ans=(key<=l)?l:root->data;
        return ans;
    }
    else if(root->data<key){
        return helper(root->right,key,ans);
    }
}
// Function to return the ceil of given number in BST.
int findCeil(Node* root, int input) {
    if (root == NULL) return -1;

    // Your code here
    int ans=INT_MIN;
    ans=helper(root,input,ans);
    if(ans==-1)return -1;
    return ans;
}
//14.Vertical Traversal of Binary Tree
void lot(Node *root,auto & h){
        queue<pair<Node*,int>> q;
        q.push({root,0});
        h[0].push_back(root->data);
        while(q.empty()!=true){
            int size=q.size();
            while(size>0){
                pair<Node*,int> front=q.front();
                q.pop();
                if(front.first->left){
                    q.push({front.first->left,front.second-1});
                    h[front.second-1].push_back(front.first->left->data);
                }
                if(front.first->right){
                    q.push({front.first->right,front.second+1});
                    h[front.second+1].push_back(front.first->right->data);
                }
                size--;
            }
        }
    }
    //Function to find the vertical order traversal of Binary Tree.
    vector<int> verticalOrder(Node *root)
    {
        //Your code here
        if(root==NULL)return {-1};
        map<int,list<int>> h;
        lot(root,h);
        vector<int> ans;
        for(auto i:h){
            for(auto j:i.second)
              ans.push_back(j);
        }
        return ans;
    }
//15.Top View of Binary Tree
public:
    void lot(Node *root,auto & h){ //same like vertical traversal just store top node value(which will be first node seen for that index position from top) instead of list of values.
        queue<pair<Node*,int>> q;
        q.push({root,0});
        h[0]=root->data;
        while(q.empty()!=true){
            int size=q.size();
            while(size>0){
                pair<Node*,int> front=q.front();
                q.pop();
                if(front.first->left){
                    q.push({front.first->left,front.second-1});
                    if(h.find(front.second-1)==h.end()){
                       h[front.second-1]=front.first->left->data;
                    }
                }
                if(front.first->right){
                    q.push({front.first->right,front.second+1});
                    if(h.find(front.second+1)==h.end()){
                       h[front.second+1]=front.first->right->data;
                    }
                }
                size--;
            }
        }
    }
   
    //Function to return a list of nodes visible from the top view 
    //from left to right in Binary Tree.
    vector<int> topView(Node *root)
    {
        //Your code here
        if(root==NULL)return {-1};
        vector<int> ans;
        map<int,int> h;
        lot(root,h);
        for(auto i:h){
            ans.push_back(i.second);
        }
        return ans;
    }
//16.Bottom View of Binary Tree
void lot(Node *root,auto & h){ //same like vertical traversal just store latest or bottom most node value(which will be bottom most node seen for that index position from bottom) instead of list of values.
        queue<pair<Node*,int>> q;
        q.push({root,0});
        h[0]=root->data;
        while(q.empty()!=true){
            int size=q.size();
            while(size>0){
                pair<Node*,int> front=q.front();
                q.pop();
                if(front.first->left){
                    q.push({front.first->left,front.second-1});
                    h[front.second-1]=front.first->left->data;
                }
                if(front.first->right){
                    q.push({front.first->right,front.second+1});
                    h[front.second+1]=front.first->right->data;
                }
                size--;
            }
        }
    }
    vector <int> bottomView(Node *root) {
         //Your code here
        if(root==NULL)return {-1};
        vector<int> ans;
        map<int,int> h;
        lot(root,h);
        for(auto i:h){
            ans.push_back(i.second);
        }
        return ans;
    }
//17.Check for BST
//Function to check whether a Binary Tree is BST or not.
    bool checkSorted(vector<int> &ans){
        for(int i=1;i<ans.size();i++){
            if((ans[i]-ans[i-1])<0) return false;
        }
        return true;
    }
    void inorder(Node *root,vector<int> &ans){
        if(root==NULL) return;
        inorder(root->left,ans);
        ans.push_back(root->data);
        inorder(root->right,ans);
    }
    bool isBST(Node* root) 
    {
        // Your code here
        vector<int> ans;
        inorder(root,ans);
        return checkSorted(ans);
    }
//18.Find the Closest Element in BST
void helper(Node *root,int k,int &ans){
        if(root==NULL){
            return;
        }
        if(root->data>k){
            int diff=abs(root->data-k);
            ans=min(ans,diff);
            helper(root->left,k,ans);
        }
        else if(root->data<k){
            int diff=abs(root->data-k);
            ans=min(ans,diff);
            helper(root->right,k,ans);
        }
        else if(root->data==k){
            ans=min(ans,0);
        }
    }
    //Function to find the least absolute difference between any node
	//value of the BST and the given integer.
    int minDiff(Node *root, int K)
    {
        //Your code here
        if(root==NULL)return 0;
        int ans=INT_MAX;
        helper(root,K,ans);
        return ans;
    }
//19.Convert Level Order Traversal to BST
//User function Template for C++
struct NodeDetails{
    Node * ptr;
    int min;
    int max;
    NodeDetails(Node* p){
        this->ptr=p;
        min=INT_MIN;
        max=INT_MAX;
    }
};

//Function to construct the BST from its given level order traversal.
Node* constructBst(int arr[], int n)
{
    // Code here
    if(n==0) return NULL;
    int i=0;
    Node *root=new Node(arr[i]);
    i++;
    NodeDetails *rt=new NodeDetails(root);
    queue<NodeDetails*> q;
    q.push(rt);
    while(i<n){
        NodeDetails *front=q.front();
        q.pop();
        if(i<n&&((arr[i]<front->ptr->data)&&(arr[i]>front->min))){
            Node *left=new Node(arr[i]);
            i++;
            NodeDetails *l=new NodeDetails(left);
            l->min=front->min;
            l->max=front->ptr->data;
            q.push(l);
            front->ptr->left=left;
        }
        if(i<n&&((arr[i]>front->ptr->data)&&(arr[i]<front->max))){
            Node *right=new Node(arr[i]);
            i++;
            NodeDetails *r=new NodeDetails(right);
            r->max=front->max;
            r->min=front->ptr->data;
            q.push(r);
            front->ptr->right=right;
        }
    }
    return root;
}
//20.Count BST nodes that lie in a given range
void helper(Node *root,int &l,int &h,int &ans){
        if(root==NULL)return;
        if(root->data>=l&&root->data<=h){
            ans++;
            helper(root->left,l,h,ans);
            //v
            helper(root->right,l,h,ans);
        }else if(root->data<l){
            helper(root->right,l,h,ans);
        }else if(root->data>h){
            helper(root->left,l,h,ans);
        }
    }
    int getCount(Node *root, int l, int h)
    {
      // your code goes here  
      if(root==NULL)return -1;
      int ans=0;
      helper(root,l,h,ans);
      return ans;
    }
//21.Preorder to Postorder
public:
    int preIndex=0;
    Node* helper(int in[],int pre[],int is,int ie){
        if(is>ie)return NULL;
        int inIndex;
        Node *root=new Node(pre[preIndex]);
        preIndex++;
        for(int i=is;i<=ie;i++){
            if(in[i]==root->data){
                inIndex=i;
                break;
            }
        }
        root->left=helper(in,pre,is,inIndex-1);
        root->right=helper(in,pre,inIndex+1,ie);
        return root;
    }
    Node* buildTree(int in[],int pre[], int n)
    {
        // Code here
       
       return helper(in,pre,0,n-1);
    }
//22.Merge two BST 's
void inorder(Node* root,vector<int>& ans){
        if(root==NULL)return;
        inorder(root->left,ans);
        ans.push_back(root->data);
        inorder(root->right,ans);
    }
    void mergefun(vector<int>& a,vector<int>& b,vector<int> &ans){
        int i=0,j=0,k=0,s1=a.size(),s2=b.size();
        while(i<s1&&j<s2){
            if(a[i]<b[j]){ans.push_back(a[i]);i++;}
            else if(a[i]>b[j]){ans.push_back(b[j]);j++;}
            else if(a[i]=b[j]){ans.push_back(a[i]);ans.push_back(b[j]);i++;j++;}
        }
        while(i<s1){
            ans.push_back(a[i]);i++;
        }
        while(j<s2){
            ans.push_back(b[j]);j++;
        }
    }
    //Function to return a list of integers denoting the node 
    //values of both the BST in a sorted order.
    vector<int> merge(Node *root1, Node *root2)
    {
       //Your code here
       vector<int> a,b,ans;
       inorder(root1,a);
       inorder(root2,b);
       mergefun(a,b,ans);
       return ans;
    }
//23.Fixing Two nodes of a BST
 public:
   /*first store inorder and then two cases:
   1. The swapped nodes are not adjacent in the in-order traversal of the BST.
     For example, Nodes 5 and 25 are swapped in {3 5 7 8 10 15 20 25}. 
     The inorder traversal of the given tree is 3 25 7 8 10 15 20 5
    Observe carefully, during inorder traversal, 
    find node 7 is smaller than the previously visited node 25.
    Here save the context of node 25 (previous node).
    Again, find that node 5 is smaller than the previous node 20.
    This time, save the context of node 5 (the current node ).
    Finally, swap the two nodes values.
    2. The swapped nodes are adjacent in the inorder traversal of BST.
      For example, Nodes 7 and 8 are swapped in {3 5 7 8 10 15 20 25}. 
      The inorder traversal of the given tree is 3 5 8 7 10 15 20 25 
      Here only one point exists where a node value is smaller than the previous node value.
      e.g. node 7 is smaller than node 8. 
    */

    void inorder(Node* root,vector<Node*>& ans){
        if(root==NULL)return;
        inorder(root->left,ans);
        ans.push_back(root);
        inorder(root->right,ans);
    }
    void correctBST( struct Node* root )
    {
        // add code here.
        vector<Node*> ans;
        inorder(root,ans);
        int count=0;
        Node *temp1,*temp2,*prev,*last;
        for(auto i=ans.begin()+1;i!=ans.end();i++){
            if(((*i)->data)<((*(i-1))->data)){
                if(count==0){prev=(*(i-1));temp1=(*i);count++;}
                else if(count==1){temp2=(*i);count++;}
            }
        }
        if(count==1){
            prev->data=prev->data+temp1->data;
            temp1->data=prev->data-temp1->data;
            prev->data=prev->data-temp1->data;
        }
        else if(count==2){
            prev->data=prev->data+temp2->data;
            temp2->data=prev->data-temp2->data;
            prev->data=prev->data-temp2->data;
        }
        
    }

HEAP:
//01.Binary Heap Operations
/*The structure of the class is
struct MinHeap
{
    int *harr;
    int capacity, heap_size;
    MinHeap(int cap) {heap_size = 0; capacity = cap; harr = new int[cap];}
    int extractMin();
    void deleteKey(int i);
    void insertKey(int k);
    int parent(int i);
    int left(int i);
    int right(int i);
};*/
//Function to extract minimum value in heap and then to store 
//next minimum value at first index.
int MinHeap::extractMin() 
{
    // Your code here
    if(heap_size<=0)return -1;
    int temp=harr[0];
    harr[0]=harr[heap_size-1];
    harr[heap_size-1]=temp;
    heap_size--;
    MinHeapify(0);
    return harr[heap_size];
}

//Function to delete a key at ith index.
void MinHeap::deleteKey(int i)
{
    // Your code here
    if((heap_size<=0)||(i>=heap_size))return;
    decreaseKey(i,INT_MIN);
    extractMin();;
}

//Function to insert a value in Heap.
void MinHeap::insertKey(int k) 
{
    // Your code here
    if(heap_size<capacity){
        harr[heap_size++]=k;
        for(int i=heap_size-1;i>0&&harr[i]<harr[parent(i)];){
            int temp=harr[parent(i)];
            harr[parent(i)]=harr[i];
            harr[i]=temp;
            i=parent(i);
        }
    }
    
}

//Function to change value at ith index and store that value at first index.
void MinHeap::decreaseKey(int i, int new_val) 
{
    harr[i] = new_val;
    while (i != 0 && harr[parent(i)] > harr[i]) {
        swap(harr[i], harr[parent(i)]);
        i = parent(i);
    }
}

/* You may call below MinHeapify function in
   above codes. Please do not delete this code
   if you are not writing your own MinHeapify */
void MinHeap::MinHeapify(int i) 
{
    int l = left(i);
    int r = right(i);
    int smallest = i;
    if (l < heap_size && harr[l] < harr[i]) smallest = l;
    if (r < heap_size && harr[r] < harr[smallest]) smallest = r;
    if (smallest != i) {
        swap(harr[i], harr[smallest]);
        MinHeapify(smallest);
    }
}
//02.Heap Sort
public:
    int left(int i){return (2*i)+1;}
    int right(int i){return (2*i)+2;}
    int parent(int i){return floor((i-1)/2);}
    //Heapify function to maintain heap property.
    void Maxheapify(int arr[], int n, int i)  
    {
      // Your Code Here
      int largest=i;
      int l=left(i);
      int r=right(i);
      if(l<n&&arr[l]>arr[largest]){
          largest=l;
      }
      if(r<n&&arr[r]>arr[largest]){
          largest=r;
      }
      if(largest!=i){
          swap(arr[largest],arr[i]);
          Maxheapify(arr,n,largest);
      }
    }
    //Function to build a Heap from array.
    void buildHeap(int arr[], int n)  
    { 
    // Your Code Here
        for(int i=n/2-1;i>=0;i--){
            Maxheapify(arr,n,i);
        }
    }
    
    //Function to sort an array using Heap Sort.
    void heapSort(int arr[], int n)
    {
        //code here
        buildHeap(arr,n);
        int t=n;
        for(int i=n-1;i>=0;i--){
            swap(arr[0],arr[i]);
            Maxheapify(arr,i,0);
        }
    }
//03.K largest elements
//Function to return k largest elements from an array.
    vector<int> kLargest(int arr[], int n, int k)
    {
        // code here
        if(n<0) return {-1};
        if(k>n) return{-1};
        priority_queue<int> pq(arr,arr+n);
        vector<int> ans;
        for(int i=0;i<k;i++){
            ans.push_back(pq.top());
            pq.pop();
        }
        return ans;
    }

//05.Kth smallest element
 public:
    // arr : given array
    // l : starting index of the array i.e 0
    // r : ending index of the array i.e size-1
    // k : find kth smallest element and return using this function
    int kthSmallest(int arr[], int l, int r, int k) {
        //code here
        priority_queue<int> pq(arr,arr+r+1);
        int reqd=(r+1)-k+1;
        while(reqd>1){
            pq.pop();
            reqd--;
        }
        return pq.top();
    }
//06. Kth largest element in a stream
vector<int> kthLargest(int k, int arr[], int n) {
        // code here
        priority_queue<int,vector<int>,greater<int>> pq;
        vector<int> ans;
        for(int i=0; i<n; i++)
        {
            pq.push(arr[i]);
            if(pq.size() < k)
            ans.push_back(-1);
            else if(pq.size() == k)
            ans.push_back(pq.top());
            else
            {
                pq.pop();
                ans.push_back(pq.top());
            }
        }
        return ans;
    }
//07.K Most occurring elements
 static bool comp(pair<int,int> a,pair<int,int> b){
        if(a.second>b.second){
            return true;
        }else if(a.second==b.second){
            return a.first>b.first;
        }else return false;
    }
    vector<int> topK(vector<int>& nums, int k) {
        // Code here
        unordered_map<int,int> h;
        vector<pair<int,int>> v;
        vector<int> ans;
        for(auto i: nums){
            h[i]++;
        }
        for(auto i:h){
            v.push_back({i.first,i.second});
        }
        sort(v.begin(),v.end(),comp);
        for(auto i:v){
            if(k>0){
            ans.push_back(i.first);
            k--;
            }else break;
        }
        return ans;
    }
//08.Minimum Cost of ropes
//Function to return the minimum cost of connecting the ropes.
    long long minCost(long long arr[], long long n) {
        // Your code here
        priority_queue<long long int,vector<long long int>,greater<long long int>> pq(arr,arr+n);
        long long cost=0,currcost=0;
        if(pq.size()<=1) return 0;
        while(pq.size()>1){
            currcost=0;
            currcost+=pq.top();
            pq.pop();
            currcost+=pq.top();
            pq.pop();
            cost+=currcost;
            pq.push(currcost);
        }
        return cost;
    }
//09.Nearly sorted
 //Function to return the sorted array.
    vector <int> nearlySorted(int arr[], int num, int K){
        // Your code here
        priority_queue<int,vector<int>,greater<int>> pq;
        vector<int> ans;
        for(int i=0;i<num;i++){
            pq.push(arr[i]);
            if(pq.size()>K){
                ans.push_back(pq.top());
                pq.pop();
            }
        }
        while(pq.empty()!=true){
            ans.push_back(pq.top());
            pq.pop();
        }
        return ans;
    }
//10.Merge k Sorted Arrays
struct Triplet{
    int val;
    int arraypos;
    int valuepos;
    Triplet(int v,int ap,int vp){
        this->val=v;
        this->arraypos=ap;
        this->valuepos=vp;
    }
};
struct mycomp{
    bool operator()(Triplet &a,Triplet &b){
        return a.val>b.val;
    }
};
class Solution
{
    public:
    //Function to merge k sorted arrays.
   /*
   //m-1 -o(nlogn)  time-0.4 sec
    vector<int> mergeKArrays(vector<vector<int>> arr, int K)
    {
        //code here
        vector<int> ans;
        priority_queue<int,vector<int>,greater<int>> pq;
        for(int i=0;i<arr.size();i++){
            for(int j=0;j<arr[i].size();j++){
                pq.push(arr[i][j]);
            }
        }
        while(pq.empty()!=true){
            ans.push_back(pq.top());
            pq.pop();
        }
        return ans;
        
    }
    */
    // m-2 -o(nklogk)  time-0.33 sec
    vector<int> mergeKArrays(vector<vector<int>> arr, int K){
        priority_queue<Triplet,vector<Triplet>,mycomp> pq;
        vector<int> ans;
        int row=arr.size();
        for(int i=0;i<row;i++){
            Triplet t(arr[i][0],i,0);
            pq.push(t);
        }
        while(pq.empty()!=true){
            Triplet mini=pq.top();
            pq.pop();
            int val=mini.val;
            ans.push_back(val);
            int ap=mini.arraypos;
            int vp=mini.valuepos;
            if((vp+1)<arr[ap].size()){
                Triplet next(arr[ap][vp+1],ap,(vp+1));
                pq.push(next);
            }
        }
        return ans;
    }
    
};
//11.Rearrange characters
string rearrangeString(string str)
    {
        //code here
        int n=str.length();
        if(n==0)return "-1";
        int chars[26]={0};
        char maxchar;
        int maxcount=0;
        for(auto i:str){
            chars[i-'a']+=1;
            if(chars[i-'a']>((n+1)/2)) return "-1";
            if(chars[i-'a']>maxcount){maxcount=chars[i-'a'];maxchar=i;}
        }
        int ind=0;
        string res(n,' ');
        while(maxcount>0){
            res[ind]=maxchar;
            ind+=2;
            maxcount--;
            chars[maxchar-'a']--;
        }
        for(int i=0;i<26;i++){
                while(chars[i]>0){
                    ind=(ind>=n)?1:ind;
                    res[ind]=i+'a';
                    ind+=2;
                    chars[i]--;
                }
        }
        return res;
    }
//12.Find median in a stream
public:
    //time:o(nlogn) space :o(n)
    priority_queue<int> maxheap;//for left  to store all elements=<expected median)
    priority_queue<int,vector<int>,greater<int>> minheap;//for right to store all elements>expected median
    //Function to insert heap.
    void insertHeap(int &x)
    {
     if(maxheap.size()==0||maxheap.top()>x){
         maxheap.push(x);
     }else minheap.push(x);
     balanceHeaps();
    }
    
    //Function to balance heaps.
    void balanceHeaps()
    {
        if(maxheap.size()>minheap.size()+1){
            int temp=maxheap.top();
            maxheap.pop();
            minheap.push(temp);
        }else if(minheap.size()>maxheap.size()){
            int temp=minheap.top();
            minheap.pop();
            maxheap.push(temp);
        }
    }
    
    //Function to return Median.
    double getMedian()
    {
        if(maxheap.size()==minheap.size()){
            return double(maxheap.top()+minheap.top())/2;
        }else return maxheap.top();
    }

GRAPH:
//01.Print adjacency list
   // Function to return the adjacency list for each vertex.
    vector<vector<int>> printGraph(int V, vector<int> adj[]) {
        // Code here
        vector<vector<int>> adjlist(V,{0});
        for(int i=0;i<V;i++){
            adjlist[i][0]=i;
            for(auto j:adj[i]){
                adjlist[i].push_back(j);
            }
        }
        return adjlist;
    }
//02.BFS of graph
 // Function to return Breadth First Traversal of given graph.
    vector<int> bfsOfGraph(int V, vector<int> adj[]) {
        // Code here
        unordered_map<int,int> h;
        vector<int> ans;
        queue<int> q;
        q.push(0);
        h[0]++;
        ans.push_back(0);
        while(q.empty()!=true){
            int front=q.front();
            q.pop();
            for(auto it:adj[front]){
                if(h[it]<=0){
                    h[it]++;
                    ans.push_back(it);
                    q.push(it);
                }
            }
        }
        return ans;
    }
//03.DFS of Graph
 // Function to return a list containing the DFS traversal of the graph.
    vector<int> dfsOfGraph(int V, vector<int> adj[]) {
        // Code here
        stack<int> st;
        vector<int> ans;
        st.push(0);
        unordered_map<int,int> h;//visited array
        while(st.empty()!=true){
            int t=st.top();
            st.pop();
            if(h[t]<=0){
                h[t]=1;
                ans.push_back(t);
                for(int it=adj[t].size()-1;it>=0;it--){//we add connected elements in reverse order
                    if(h[adj[t][it]]<=0){
                        st.push(adj[t][it]);
                    }
                }
            }
        }
        return ans;
    }
//04.Find the number of islands
void checkneighbours(vector<vector<char>> &grid,int &m,int &n,int i,int j){
       if(i>=m||i<0||j>=n||j<0) return;
       if(grid[i][j]=='0') return;//if we are using visted array then ,also check if visited[i][j]==true
       grid[i][j]='0';//alternative of visited array is to mark it '0' which will mean it will be caught in base condn and will be treated as visited.
       checkneighbours(grid,m,n,i-1,j-1);
       checkneighbours(grid,m,n,i-1,j);
       checkneighbours(grid,m,n,i-1,j+1);
       checkneighbours(grid,m,n,i,j-1);
       checkneighbours(grid,m,n,i,j+1);
       checkneighbours(grid,m,n,i+1,j-1);
       checkneighbours(grid,m,n,i+1,j);
       checkneighbours(grid,m,n,i+1,j+1);
   }
    // Function to find the number of islands.
    int numIslands(vector<vector<char>>& grid) {
        // Code here
        int m=grid.size(),n=grid[0].size(),count=0;
        //vector<vector<bool>> visited(m,{false});
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){// if we are using visted array then ,also check &&visited[i][j]==false
                    count++;
                    checkneighbours(grid,m,n,i,j);
                }
            }
        }
        return count;
    }
//05.Detect cycle in an undirected graph
//mark curr node visited and for each of its child check if they are visited but their parent is not curr node. for such case it means there is an cycle in graph.if it was parent node then means the edge is normal undirected edge which leads 2 calls i.e form child to parent and parent to child thus doesn't means a cycle.
void dfs(int curr,int parent,vector<int> adj[],vector<bool> &visited,int &flag){
       visited[curr]=true;
       for(auto i:adj[curr]){
           if(visited[i]==false){
               dfs(i,curr,adj,visited,flag);
           }else if(visited[i]==true&&i!=parent){
               flag=1;
               return;
           }
       }
   }
    // Function to detect cycle in an undirected graph.
    bool isCycle(int V, vector<int> adj[]) {
        // Code here
        int flag=0;
        vector<bool> visited(V,false);
        for(int i=0;i<V;i++){
            if(visited[i]==false){
                dfs(i,-1,adj,visited,flag);
            }
        }
        return bool(flag);
    }
//06.Detect cycle in a directed graph
 //Kahn's algo like topological sort we do extraction & if extraction not possible means dependency and thus means cycle. 
    // Function to detect cycle in a directed graph.
    bool isCyclic(int V, vector<int> adj[]) {
        // code here
        vector<int> indegree(V,0);
        queue<int> q;
        int count=0;
        for(int i=0;i<V;i++){
            for(auto j:adj[i]){
                indegree[j]+=1;
            }
        }
        for(int i=0;i<V;i++){
            if(indegree[i]==0){
                q.push(i);
            }
        }
        while(q.empty()!=true){
            int front=q.front();
            q.pop();
            count++;
            for(auto child:adj[front]){
                indegree[child]--;
                if(indegree[child]==0){
                    q.push(child);
                }
            }
        }
        if(count==V) return false;
        else return true;
    }
//07.Find whether path exist
 bool dfs(vector<vector<int>>& grid,int i,int j){
        if(i<0||i>=grid.size()||j<0||j>=grid[0].size())return false;
        if(grid[i][j]==0) return false;
        if(grid[i][j]==2) return true;
        grid[i][j]=0;//to mark curr box as  visited hence next time it will be trapped in base case and won't apply dfs on it.
        return dfs(grid,i-1,j)||dfs(grid,i,j-1)||dfs(grid,i,j+1)||dfs(grid,i+1,j);
    }
    //Function to find whether a path exists from the source to destination.
    bool is_Possible(vector<vector<int>>& grid) 
    {
        //code here
        for(int i=0;i<grid.size();i++){
            for(int j=0;j<grid[i].size();j++){
                if(grid[i][j]==1){
                   return dfs(grid,i,j);
                }
            }
        }
        
    }
//08.Topological sort
//Function to return list containing vertices in Topological order. 
	vector<int> topoSort(int V, vector<int> adj[]) 
	{
	    // code here
	    vector<int> indegree(V,0),ans;
	    queue<int> q;
	    for(int i=0;i<V;i++){
	        for(auto j:adj[i]){
	            indegree[j]++;
	        }
	    }
	    for(int i=0;i<V;i++){
	        if(indegree[i]==0){
	            q.push(i);
	            ans.push_back(i);
	        }
	    }
	    while(q.empty()!=true){
	        int front=q.front();
	        q.pop();
	        for(auto child:adj[front]){
	            indegree[child]--;
	            if(indegree[child]==0){
	                q.push(child);
	                ans.push_back(child);
	            }
	        }
	    }
	    return ans;
	}